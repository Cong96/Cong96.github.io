<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>数组Array | 迷途书童的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="转载：http://blog.csdn.net/zhangjg_blog/article/details/16116613 前言数组是基本上所有语言都会有的一种数据类型，它表示一组相同类型的数据的集合，具有固定的长度，并且在内存中占据连续的空间。在C，C++等语言中，数组的定义简洁清晰，而在java中确有一些会让人迷惑">
<meta property="og:type" content="article">
<meta property="og:title" content="数组Array">
<meta property="og:url" content="https://cong96.github.io/2017/12/13/数组Array/index.html">
<meta property="og:site_name" content="迷途书童的博客">
<meta property="og:description" content="转载：http://blog.csdn.net/zhangjg_blog/article/details/16116613 前言数组是基本上所有语言都会有的一种数据类型，它表示一组相同类型的数据的集合，具有固定的长度，并且在内存中占据连续的空间。在C，C++等语言中，数组的定义简洁清晰，而在java中确有一些会让人迷惑的特性。本文就尝试分析这些特性。 Java中数组是对象吗Java和C++都是面">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2017-12-13T12:34:55.666Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="数组Array">
<meta name="twitter:description" content="转载：http://blog.csdn.net/zhangjg_blog/article/details/16116613 前言数组是基本上所有语言都会有的一种数据类型，它表示一组相同类型的数据的集合，具有固定的长度，并且在内存中占据连续的空间。在C，C++等语言中，数组的定义简洁清晰，而在java中确有一些会让人迷惑的特性。本文就尝试分析这些特性。 Java中数组是对象吗Java和C++都是面">
  
    <link rel="alternate" href="/atom.xml" title="迷途书童的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">迷途书童的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">一天进步一点</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://cong96.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-数组Array" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/13/数组Array/" class="article-date">
  <time datetime="2017-12-13T12:48:49.209Z" itemprop="datePublished">2017-12-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java基础/">Java基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      数组Array
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>转载：<a href="http://blog.csdn.net/zhangjg_blog/article/details/16116613" target="_blank" rel="noopener">http://blog.csdn.net/zhangjg_blog/article/details/16116613</a></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>数组是基本上所有语言都会有的一种数据类型，它表示一组相同类型的数据的集合，具有固定的长度，并且在内存中占据连续的空间。在C，C++等语言中，数组的定义简洁清晰，而在java中确有一些会让人迷惑的特性。本文就尝试分析这些特性。</p>
<h3 id="Java中数组是对象吗"><a href="#Java中数组是对象吗" class="headerlink" title="Java中数组是对象吗"></a>Java中数组是对象吗</h3><p>Java和C++都是面向对象的语言。在使用这些语言的时候，我们可以直接使用标准的类库，也可以使用组合和继承等面向对象的特性构建自己的类，并且根据自己构建的类创建对象。那么，我们是不是应该考虑这样一个问题：在面向对象的语言中，数组是对象吗？</p>
<p>要判断数组是不是对象，那么首先明确什么是对象，也就是对象的定义。在较高的层面上，对象是根据某个类创建出来的一个实例，表示某类事物中一个具体的个体。对象具有各种属性，并且具有一些特定的行为。而在较低的层面上，站在计算机的角度，对象就是内存中的一个内存块，在这个内存块封装了一些数据，也就是类中定义的各个属性，所以，对象是用来封装数据的。</p>
<p>在较高的层面上，数组不是某类事物中的一个具体的个体，而是多个个体的集合。那么它应该不是对象。而在计算机的角度，数组也是一个内存块，也封装了一些数据，这样的话也可以称之为对象。</p>
<p>这样的话， 数组既可以是对象， 也可以不是对象。至于到底是不是把数组当做对象，全凭Java的设计者决定。数组到底是不是对象， 通过代码验证：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">array</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];  </span><br><span class="line">	<span class="comment">//a.length;  //对属性的引用不能当成语句  </span></span><br><span class="line">	<span class="keyword">int</span> len = a.length;  <span class="comment">//数组中保存一个字段, 表示数组的长度  </span></span><br><span class="line">	  System.out.println(len);</span><br><span class="line">	<span class="comment">//以下方法说明数组可以调用方法,java中的数组是对象.这些方法是Object中的方法,所以可以肯定,数组的最顶层父类也是Object  </span></span><br><span class="line">	a.clone();  </span><br><span class="line">	a.toString();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在数组a上， 可以访问他的属性，也可以调用一些方法。<strong>这基本上可以认定，java中的数组也是对象，它具有java中其他对象的一些基本特点：封装了一些数据，可以访问属性，也可以调用方法。所以，数组是对象。</strong></p>
<p>而在C++中，数组虽然封装了数据，但数组名只是一个指针，指向数组中的首个元素，既没有属性，也没有方法可以调用。如下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;  </span><br><span class="line">    int a[] = &#123;1, 2, 3, 4&#125;;  </span><br><span class="line">    int* pa = a;  </span><br><span class="line">    //无法访问属性，也不能调用方法。  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Java中数组的类型"><a href="#Java中数组的类型" class="headerlink" title="Java中数组的类型"></a>Java中数组的类型</h3><p>Java是一种强类型的语言。既然是对象， 那么就必须属于一个类型，比如根据Person类创建一个对象，这个对象的类型就是Person。那么数组的类型是什么呢？看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] a1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;  </span><br><span class="line">	System.out.println(a1.getClass().getName());  </span><br><span class="line">	<span class="comment">//打印出的数组类的名字为[I  </span></span><br><span class="line">	  </span><br><span class="line">	String[] s = <span class="keyword">new</span> String[<span class="number">2</span>];  </span><br><span class="line">	System.out.println(s.getClass().getName());  </span><br><span class="line">	<span class="comment">//打印出的数组类的名字为  [Ljava.lang.String;  </span></span><br><span class="line">	  </span><br><span class="line">	String[][] ss = <span class="keyword">new</span> String[<span class="number">2</span>][<span class="number">3</span>];  </span><br><span class="line">	System.out.println(ss.getClass().getName());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[I</span><br><span class="line">[Ljava.lang.String;</span><br><span class="line">[[Ljava.lang.String;</span><br></pre></td></tr></table></figure>
<p>打印出a1的类型为[ I ，s 的类型是[Ljava.lang.String;  ,  ss的类型是[[Ljava.lang.String;  </p>
<p>所以，<strong>数组也是有类型的。</strong>只是这个类型显得比较奇怪。你可以说a1的类型是int[]，这也无可厚非。但是我们没有自己创建这个类，也没有在Java的标准库中找到这个类。也就是说不管是我们自己的代码，还是在JDK中。</p>
<p>这只能有一个解释，那就是<strong>虚拟机自动创建了数组类型</strong>，可以把数组类型和8种基本数据类型一样， 当做java的内建类型。这种类型的命名规则是这样的：</p>
<ul>
<li>每一维度用一个[表示；开头两个[，就代表是二维数组。</li>
</ul>
<ul>
<li>[后面是数组中元素的类型(包括基本数据类型和引用数据类型)</li>
</ul>
<p>在java语言层面上,s是数组,也是一个对象,那么他的类型应该是String[]，这样说是合理的。但是在JVM中，他的类型为[java.lang.String。顺便说一句普通的类在JVM里的类型为 包名+类名，也就是全限定名。同一个类型在java语言中和在虚拟机中的表示可能是不一样的。</p>
<h3 id="Java中数组的继承关系"><a href="#Java中数组的继承关系" class="headerlink" title="Java中数组的继承关系"></a>Java中数组的继承关系</h3><p>上面已经验证了，数组是对象，也就是说可以以操作对象的方式来操作数组。并且数组在虚拟机中有它特别的类型。既然是对象，遵循Java语言中的规则 – Object是上帝， 也就是说所有类的顶层父类都是Object。数组的顶层父类也必须是Object，这就说明数组对象可以向上直接转型到Object，也可以向下强制类型转换，也可以使用instanceof关键字做类型判定。 这一切都和普通对象一样。如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">typeTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//1     在test1()中已经测试得到以下结论: 数组也是对象, 数组的顶层父类是Object, 所以可以向上转型  </span></span><br><span class="line">	<span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>];  </span><br><span class="line">	Object obj = a ; <span class="comment">//数组的父类也是Object,可以将a向上转型到Object  </span></span><br><span class="line">	  </span><br><span class="line">	<span class="comment">//2     那么能向下转型吗?  </span></span><br><span class="line">	<span class="keyword">int</span>[] b = (<span class="keyword">int</span>[])obj;  <span class="comment">//可以进行向下转型  </span></span><br><span class="line">	  </span><br><span class="line">	<span class="comment">//3     能使用instanceof关键字判定吗?  </span></span><br><span class="line">	<span class="keyword">if</span>(obj <span class="keyword">instanceof</span> <span class="keyword">int</span>[])&#123;  <span class="comment">//可以用instanceof关键字进行类型判定  </span></span><br><span class="line">	    System.out.println(<span class="string">"obj的真实类型是int[]"</span>);  </span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>Object[]类型的引用可以指向String[]类型的数组对象？ 由上文的验证可以得知数组类型的顶层父类一定是Object，那么上面代码中s的直接父类是谁呢？难道说String[]继承自Object[]，而Object[]又继承自Object? 让我们通过反射的方式来验证这个问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">extendsTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	String[] s = <span class="keyword">new</span> String[<span class="number">5</span>];  </span><br><span class="line">	Object[] obja = s;   <span class="comment">//成立,说明可以用Object[]的引用来接收String[]的对象  </span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 由代码可知，String[]的直接父类就是Object而不是Object[]。可是Object[]的引用明明可以指向String[]类型的对象。</span></span><br><span class="line"><span class="comment">	 *  </span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *这个看起来是违反了Java单继承的原则。</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *  数组类直接继承了Object，关于Object[]类型的引用能够指向String[]类型的对象，这种情况只能是Java语法之中的一个特例，并不是严格意义上的继承。也就是说，String[]不继承自Object[]，但是我可以允许你向上转型到Object[]，这种特性是赋予你的一项特权。</span></span><br><span class="line"><span class="comment">	 * Ojbect[]的引用能够指向String[]类型的对象 这就是Java把数组设计成了协变</span></span><br><span class="line"><span class="comment">	 * 至于为什么把数组设计为协变的，这个问题也是值得我们研究的</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	System.out.println(s.getClass().getSuperclass().getName());</span><br><span class="line">	<span class="comment">//Arrays.equals(a, a2)</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由代码可知，String[]的直接父类就是Object而不是Object[]。可是Object[]的引用明明可以指向String[]类型的对象。</p>
<p>这样的话就违背了Java单继承的原则。String[]不可能即继承Object，又继承Object[]。上面的类图肯定是错误的。那么只能这样解释：数组类直接继承了Object，关于Object[]类型的引用能够指向String[]类型的对象，这种情况只能是Java语法之中的一个特例，并不是严格意义上的继承。也就是说，<strong>String[]不继承自Object[]，但是我可以允许你向上转型到Object[]，这种特性是赋予你的一项特权。</strong></p>
<p>其实这种关系可以这样表述：<strong>如果有两个类A和B，如果B继承（extends）了A，那么A[]类型的引用就可以指向B[]类型的对象。</strong>这就是所谓的协变，关于协变，下面会讲到。</p>
<p>注意：<strong>数组的这种用法不能作用于基本类型数据。</strong></p>
<h3 id="Java中数组是协变的"><a href="#Java中数组是协变的" class="headerlink" title="Java中数组是协变的"></a>Java中数组是协变的</h3><p>上面我们已经证明了Java中的数组是协变的，但是Java为什么要把数组设计成协变的呢？</p>
<p>这是原文并没有很好的给出解释的，我们需要自己去继续寻找答案。</p>
<p>下面转一个知乎上的答案：<a href="https://www.zhihu.com/question/21394322" target="_blank" rel="noopener">https://www.zhihu.com/question/21394322</a></p>
<p>因为在SE5之前，Java中还没有泛型，但很多代码波切需要泛型来解决问题。、、</p>
<p>For Example:比较两个素质是否”值相等的”Arrays.equals()方法，因为底层实现调用的是Object.equals()方法,和数组中具体元素类型无关。所以不想让每个类型都要重新定义Arrays.equals()方法。而是”泛化“地接受任何元素类型的数组为参数。要让Object[]能接受所有的数组类型，那个时候有有没有泛型，最简单的方法就是让数组接受协变。把String[],Integer[]都定义成Object的派生类，然后多态就起作用了。</p>
<p><strong>那么为什么数组可以设计成协变的呢</strong></p>
<p>这是因为数组有一个独有特性：</p>
<p><strong>数组记得它内部元素的具体类型，并且会在运行时做类型检查</strong></p>
<p>而且这句话也是为什么不能创建泛型数组的原因，数组创建时必须知道确切类型。</p>
<p>所以下面这段代码可以通过编译，但是运行报错：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">covariant</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Number[] num = <span class="keyword">new</span> Integer[<span class="number">10</span>]; </span><br><span class="line">	<span class="comment">//java.lang.ArrayStoreException: java.lang.Double</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	num[<span class="number">0</span>] = <span class="number">2.1</span>;</span><br><span class="line"><span class="comment">//List&lt;Integer&gt; integerList=new ArrayList&lt;Integer&gt;();</span></span><br><span class="line"><span class="comment">//List&lt;Number&gt; num1=integerList;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会报java.lang.ArrayStoreException: java.lang.Double错误</p>
<p>num变量记得它内部元素是Integer.所以运行时给它插入double类型的时候不让执行。</p>
<p>这恰恰是数组的有点，也是当初”敢于“把数组设计成协变的原因。</p>
<p>虽然向上转型后，编译期类型检查放松了，但因为数组运行时对内部元素类型看的紧，不匹配的类型还是插不进去的。</p>
<p>这同样也是为什么容器Collection不能设计为协变的原因。Collection不做运行时类型检查。</p>
<p>如果Collection接受协变，List\<integer>的引用能够传给List\<number>:</number></integer></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//List&lt;Integer&gt; integerList=new ArrayList&lt;Integer&gt;();</span></span><br><span class="line"><span class="comment">//List&lt;Number&gt; num1=integerList; //假设接受协变</span></span><br></pre></td></tr></table></figure>
<p>这时候我想往List\<number>里插入一个Double。它不会像数组这样拒绝，而是会选择默默承受。</number></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">num.add(<span class="keyword">new</span> Double(<span class="number">2.1</span>));</span><br></pre></td></tr></table></figure>
<p>然后当我们从原先的integerList里面取东西，才会发现出问题了。虽然看上去从integerList里取Integer，我们的操作无可指责。但取出来的却是Double型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer itg=integerList.get(<span class="number">0</span>);    <span class="comment">//BOOM！</span></span><br></pre></td></tr></table></figure>
<p>与其等到拿出来之后才发现不对，那还不如当初就不让插入，这就是数组的好处。</p>
<p>而且，在引入了通配符(Wildcard)之后，协变的功能也已经被实现了。而且配合通配符的”上界“和”下界“一起用，容器内元素的类型还是受到严格控制的，虽然有点复杂。</p>
<p>关于泛型通配符，会有专门的文章介绍。</p>
<p>所以总的来说，虽然数组的协变不是一个完美的设计，但也不能算非常烂。起码还能用，没有捅出大篓子。而且数组又不支持泛型，底层类库到处是Object[]，现在也不可能改了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2017/12/13/数组Array/" data-id="cjb52pr07000vgkbzt1pf5mwx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/12/13/CopyOnwriteArrayList/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          CopyOnwriteArrayList
        
      </div>
    </a>
  
  
    <a href="/2017/12/13/String/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">String类</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java-WEB/">Java WEB</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java基础/">Java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mybatis/">Mybatis</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/12/24/--Tomcat是如何处理web.xml的（下）/">Tomcat是如何处理web.xml的（下）</a>
          </li>
        
          <li>
            <a href="/2017/12/24/Tomcat是如何处理server.xml的/">Tomcat是如何加载server.xml的</a>
          </li>
        
          <li>
            <a href="/2017/12/24/Tomcat是如何处理web.xml的/">Tomcat是如何处理web.xml的</a>
          </li>
        
          <li>
            <a href="/2017/12/24/Tomcat是如何处理请求的/">Tomcat是如何处理请求的</a>
          </li>
        
          <li>
            <a href="/2017/12/24/Tomcat是如何接受请求的/">Tomcat Connector节点</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>