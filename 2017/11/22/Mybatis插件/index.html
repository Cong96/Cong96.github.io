<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Mybatis插件 | 迷途书童的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前言：最近项目有个需求，需要将所有产品的ID和Name组成Map传递到前台,以ID为key，以Name为Value。 即需要达到可以通过map.get(id)方便地获取name的值的效果。 然后就开始测试在Mybatis中哪种方法可行。首先看看直接使用resultType=”map” Mapper文件如下： 123&a">
<meta property="og:type" content="article">
<meta property="og:title" content="Mybatis插件">
<meta property="og:url" content="https://cong96.github.io/2017/11/22/Mybatis插件/index.html">
<meta property="og:site_name" content="迷途书童的博客">
<meta property="og:description" content="前言：最近项目有个需求，需要将所有产品的ID和Name组成Map传递到前台,以ID为key，以Name为Value。 即需要达到可以通过map.get(id)方便地获取name的值的效果。 然后就开始测试在Mybatis中哪种方法可行。首先看看直接使用resultType=”map” Mapper文件如下： 123&amp;lt;select id=&quot;testMap&quot; resultType=&quot;map&quot;&amp;">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2017-12-24T14:05:09.271Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Mybatis插件">
<meta name="twitter:description" content="前言：最近项目有个需求，需要将所有产品的ID和Name组成Map传递到前台,以ID为key，以Name为Value。 即需要达到可以通过map.get(id)方便地获取name的值的效果。 然后就开始测试在Mybatis中哪种方法可行。首先看看直接使用resultType=”map” Mapper文件如下： 123&amp;lt;select id=&quot;testMap&quot; resultType=&quot;map&quot;&amp;">
  
    <link rel="alternate" href="/atom.xml" title="迷途书童的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">迷途书童的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">一天进步一点</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://cong96.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Mybatis插件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/22/Mybatis插件/" class="article-date">
  <time datetime="2017-11-22T15:52:37.741Z" itemprop="datePublished">2017-11-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Mybatis/">Mybatis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Mybatis插件
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>前言：最近项目有个需求，需要将所有产品的ID和Name组成Map传递到前台,以ID为key，以Name为Value。</p>
<p>即需要达到可以通过map.get(id)方便地获取name的值的效果。</p>
<p>然后就开始测试在Mybatis中哪种方法可行。首先看看直接使用resultType=”map”</p>
<p>Mapper文件如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">"testMap"</span> resultType=<span class="string">"map"</span>&gt;</span><br><span class="line"> select    id,name from coach </span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<p>CoachDao接口定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Map&lt;Object, Object&gt; testMap();</span><br></pre></td></tr></table></figure>
<p>测试方法如下：特意没有引入Spring，只有Mybatis方便DebugMybatis源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testMap() &#123;</span><br><span class="line">	SqlSession session = null;</span><br><span class="line">	System.out.println(&quot;Dd&quot;);</span><br><span class="line">	try &#123;</span><br><span class="line"></span><br><span class="line">		session = MybatisUtil.getCurrentSession();</span><br><span class="line">		CoachDao mapper = session.getMapper(CoachDao.class);</span><br><span class="line">		Map&lt;Object, Object&gt; map = mapper.testMap();</span><br><span class="line">		System.out.println(JSON.toJSONString(map));</span><br><span class="line"></span><br><span class="line">	&#125; catch (Exception e) &#123;</span><br><span class="line">		// TODO: handle exception</span><br><span class="line">		logger.error(&quot;testMap Error:&#123;&#125;&quot;, e);</span><br><span class="line">	&#125; finally &#123;</span><br><span class="line">		session.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们debug观察下这次sql的执行过程。</p>
<p>我们从debug到MapperMethod这个类开始看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public Object execute(SqlSession sqlSession, Object[] args) &#123;</span><br><span class="line">   Object result;</span><br><span class="line">   if (SqlCommandType.INSERT == command.getType()) &#123;</span><br><span class="line">     Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">     result = rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">   &#125; else if (SqlCommandType.UPDATE == command.getType()) &#123;</span><br><span class="line">     Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">     result = rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">   &#125; else if (SqlCommandType.DELETE == command.getType()) &#123;</span><br><span class="line">     Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">     result = rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">   &#125; else if (SqlCommandType.SELECT == command.getType()) &#123;</span><br><span class="line">     if (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">       executeWithResultHandler(sqlSession, args);</span><br><span class="line">       result = null;</span><br><span class="line">     &#125; else if (method.returnsMany()) &#123;</span><br><span class="line">       result = executeForMany(sqlSession, args);</span><br><span class="line">     &#125; else if (method.returnsMap()) &#123;</span><br><span class="line">       result = executeForMap(sqlSession, args);</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">       result = sqlSession.selectOne(command.getName(), param);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     throw new BindingException(&quot;Unknown execution method for: &quot; + command.getName());</span><br><span class="line">   &#125;</span><br><span class="line">   if (result == null &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</span><br><span class="line">     throw new BindingException(&quot;Mapper method &apos;&quot; + command.getName() </span><br><span class="line">         + &quot; attempted to return null from a method with a primitive return type (&quot; + method.getReturnType() + &quot;).&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   return result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>显然我们这里执行的是SqlCommandType.SELECT == command.getType()这一个分支的。</p>
<p>我们看看这个分支的流程，首先要判断是否参数中包含ResultHandler类型的参数，</p>
<p>然后判断是否是返回Collection容器类型或者数组类型，</p>
<p>接着判断是否Method方法参数中带有@MapKey注解且返回类型为Map,看到这里我们会想到这个是否能够实现我们想要的功能呢，这个我们接下来会测试。</p>
<p>然后终于到达我们我们要走的分支</p>
<p>执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = sqlSession.selectOne(command.getName(), param);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">selectOne</span><span class="params">(String statement, Object parameter)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Popular vote was to return null on 0 results and throw exception on too many.</span></span><br><span class="line">  List&lt;T&gt; list = <span class="keyword">this</span>.&lt;T&gt;selectList(statement, parameter);</span><br><span class="line">  <span class="keyword">if</span> (list.size() == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> TooManyResultsException(<span class="string">"Expected one result (or null) to be returned by selectOne(), but found: "</span> + list.size());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现实际上Mybatis给我们返回的是一个List，只不过当执行selectOne时，需要sql执行后返回的List集合中只有一个元素。而在这里我们知道上面的sql返回的是多行结果集，而多行结果集在没有经过插件处理的时候显然返回的List中有多个结果，这个时候就会报错。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.ibatis.exceptions.TooManyResultsException: <span class="function">Expected one <span class="title">result</span> <span class="params">(or <span class="keyword">null</span>)</span> to be returned by <span class="title">selectOne</span><span class="params">()</span>, but found: 13</span></span><br></pre></td></tr></table></figure>
<p>所以第一种方案不行。</p>
<p>那我们把方法的返回类型改一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Map&lt;Object, Object&gt;&gt; testMap();</span><br></pre></td></tr></table></figure>
<p>可以保证程序正确运行，但是是List类型返回值而且其中的每一个Map是由两个元素构成的，分别以ID和NAME为键，即（”id”:123）、(“name”:”Jack”)的形式保存在Map中的。与我们想要的Map结构也不相同，虽然可以转化为我们想要的Map，但是这种转化不是很优雅，我们得找到一个更优雅更通用的方法。</p>
<ul>
<li><p>MapKey注解</p>
<p>​    那我们接着来试试之前用到的MapKey注解看能不能达到我想要的效果呢，查阅相关资料，我们开始尝试。</p>
<p>我们更改方法,将方法带上注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MapKey</span>(<span class="string">"ID"</span>)</span><br><span class="line"><span class="keyword">public</span> Map&lt;Integer, Map&lt;String, Object&gt;&gt; testMapKey();</span><br></pre></td></tr></table></figure>
<p>@MapKey(“ID”)这个注解表示最外层Map的key为查询结果中字段名为“id”的值。</p>
<p>那此刻只要Mybatis有把Value设为查询结果中的name字段的值不就好了吗。</p>
<p>但是很遗憾的是，Mybatis并没有直接实现这个功能。</p>
<p>我们看selectMap源码，当我们在没有对查询结果使用插件的时候，我们存进Map的Value只能是我们查询结果集的指定返回类型。而我们这里resultType=“map”，也就是说返回的类型就是Map。那你说我们把resultType=“string”就可以了把，很显然，这里存在问题，因为我们的结果包含两列，不可能做到resulType=“string” 。所以使用MapKey注解也是无法达到我们想要的效果的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public &lt;K, V&gt; Map&lt;K, V&gt; selectMap(String statement, Object parameter, String mapKey, RowBounds rowBounds) &#123;</span><br><span class="line">  final List&lt;?&gt; list = selectList(statement, parameter, rowBounds);</span><br><span class="line">  final DefaultMapResultHandler&lt;K, V&gt; mapResultHandler = new DefaultMapResultHandler&lt;K, V&gt;(mapKey,</span><br><span class="line">      configuration.getObjectFactory(), configuration.getObjectWrapperFactory());</span><br><span class="line">  final DefaultResultContext context = new DefaultResultContext();</span><br><span class="line">  for (Object o : list) &#123;</span><br><span class="line">    context.nextResultObject(o);</span><br><span class="line">    mapResultHandler.handleResult(context);</span><br><span class="line">  &#125;</span><br><span class="line">  Map&lt;K, V&gt; selectedMap = mapResultHandler.getMappedResults();</span><br><span class="line">  return selectedMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看看使用MapKey注解的返回情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">==&gt;  Preparing: select id,name from coach </span><br><span class="line">==&gt; Parameters: </span><br><span class="line">&lt;==    Columns: ID, NAME</span><br><span class="line">&lt;==        Row: <span class="number">12</span>, phil jackson</span><br><span class="line">&lt;==        Row: <span class="number">17</span>, phil jackson</span><br><span class="line">&lt;==        Row: <span class="number">1</span>, jackson</span><br><span class="line">&lt;==        Row: <span class="number">14</span>, phil jackson</span><br><span class="line">&lt;==        Row: <span class="number">18</span>, phil jackson</span><br><span class="line">&lt;==        Row: <span class="number">2</span>, jackson</span><br><span class="line">&lt;==        Row: <span class="number">10</span>, jackson</span><br><span class="line">&lt;==        Row: <span class="number">13</span>, phil jackson</span><br><span class="line">&lt;==        Row: <span class="number">15</span>, phil jackson</span><br><span class="line">&lt;==        Row: <span class="number">16</span>, phil jackson1</span><br><span class="line">&lt;==        Row: <span class="number">5</span>, jackson</span><br><span class="line">&lt;==        Row: <span class="number">3</span>, jackson</span><br><span class="line">&lt;==        Row: <span class="number">11</span>, jackson</span><br><span class="line">&lt;==      Total: <span class="number">13</span></span><br><span class="line">&#123;<span class="number">1</span>:&#123;<span class="string">"ID"</span>:<span class="number">1</span>,<span class="string">"NAME"</span>:<span class="string">"jackson"</span>&#125;,<span class="number">2</span>:&#123;<span class="string">"ID"</span>:<span class="number">2</span>,<span class="string">"NAME"</span>:<span class="string">"jackson"</span>&#125;,<span class="number">3</span>:&#123;<span class="string">"ID"</span>:<span class="number">3</span>,<span class="string">"NAME"</span>:<span class="string">"jackson"</span>&#125;,<span class="number">5</span>:&#123;<span class="string">"ID"</span>:<span class="number">5</span>,<span class="string">"NAME"</span>:<span class="string">"jackson"</span>&#125;,<span class="number">10</span>:&#123;<span class="string">"ID"</span>:<span class="number">10</span>,<span class="string">"NAME"</span>:<span class="string">"jackson"</span>&#125;,<span class="number">11</span>:&#123;<span class="string">"ID"</span>:<span class="number">11</span>,<span class="string">"NAME"</span>:<span class="string">"jackson"</span>&#125;,<span class="number">12</span>:&#123;<span class="string">"ID"</span>:<span class="number">12</span>,<span class="string">"NAME"</span>:<span class="string">"phil jackson"</span>&#125;,<span class="number">13</span>:&#123;<span class="string">"ID"</span>:<span class="number">13</span>,<span class="string">"NAME"</span>:<span class="string">"phil jackson"</span>&#125;,<span class="number">14</span>:&#123;<span class="string">"ID"</span>:<span class="number">14</span>,<span class="string">"NAME"</span>:<span class="string">"phil jackson"</span>&#125;,<span class="number">15</span>:&#123;<span class="string">"ID"</span>:<span class="number">15</span>,<span class="string">"NAME"</span>:<span class="string">"phil jackson"</span>&#125;,<span class="number">16</span>:&#123;<span class="string">"ID"</span>:<span class="number">16</span>,<span class="string">"NAME"</span>:<span class="string">"phil jackson1"</span>&#125;,<span class="number">17</span>:&#123;<span class="string">"ID"</span>:<span class="number">17</span>,<span class="string">"NAME"</span>:<span class="string">"phil jackson"</span>&#125;,<span class="number">18</span>:&#123;<span class="string">"ID"</span>:<span class="number">18</span>,<span class="string">"NAME"</span>:<span class="string">"phil jackson"</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>从结果集我们可以看出，以ID作为Key，但是Value是上面一种情况的Map集合，结构仍然为（（”id”:123）、(“name”:”Jack”)）显然是不符合要求的。</p>
</li>
</ul>
<p>也就是说，很遗憾，我们的这种需求Mybatis并没有直接的支持，那我们该怎么办呢，这时候就需要用到Mybatis留给我们的重要接口Mybatis中的拦截器，通过使用提供给用户可以自定义实现特殊功能，其功能特别强大。我们可以在Mybatis最重要的四大组件中使用拦截器（通过动态代理和反射注解等技术实现,这三个技术就是框架的核心，其定义就不多说了），让我们能够自定义的对四大组件的功能进行丰富和更改等。</p>
<p>在说拦截器之前，我们需要说一下四大组件</p>
<p>这部分后续补充</p>
<h3 id="二-Mybatis中的拦截器"><a href="#二-Mybatis中的拦截器" class="headerlink" title="二.Mybatis中的拦截器"></a>二.Mybatis中的拦截器</h3><p>现在我们来看Mybatis中的拦截器，Mybatis很贴心的为我们提供了Interceptor接口，作为一个优秀的开源框架，Mybatis和Spring一样都很好的遵守了开闭原则。基本都是面向接口的编程，特别是Spring，你会发现是Spring中大量的运用了模板方法模式来设计。在Mybatis中，我们要自定义我们的拦截器只需要实现这个接口。那我们首先就来瞅瞅这个接口都定义了哪些方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Object <span class="title">plugin</span><span class="params">(Object target)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>plugin方法是拦截器用于封装目标对象的，通过该方法我们可以返回目标对象本身，也可以返回一个它的代理。当返回的是代理的时候我们可以对其中的方法进行拦截来调用intercept方法(因为intercept方法的参数Invocation封装了原对象的相关信息)，当然也可以调用其他方法。setProperties方法是用于在Mybatis配置文件中指定一些属性的。       定义自己的Interceptor最重要的是要实现plugin方法和intercept方法，在plugin方法中我们可以决定是否要进行拦截进而决定要返回一个什么样的目标对象。而intercept方法就是要进行拦截的时候要执行的方法。而对于plugin方法而言，其实Mybatis已经为我们提供了一个实现。Mybatis中有一个叫做Plugin的类，里面有一个静态方法wrap(Object target,Interceptor interceptor)，通过该方法可以决定要返回的对象是目标对象还是对应的代理。Mybatis已经尽可能的帮我们做的更多了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">public class Plugin implements InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">  private Object target;</span><br><span class="line">  private Interceptor interceptor;</span><br><span class="line">  private Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap;</span><br><span class="line"></span><br><span class="line">  private Plugin(Object target, Interceptor interceptor, Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap) &#123;</span><br><span class="line">    this.target = target;</span><br><span class="line">    this.interceptor = interceptor;</span><br><span class="line">    this.signatureMap = signatureMap;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static Object wrap(Object target, Interceptor interceptor) &#123;</span><br><span class="line">    Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor);</span><br><span class="line">    Class&lt;?&gt; type = target.getClass();</span><br><span class="line">    Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);</span><br><span class="line">    if (interfaces.length &gt; 0) &#123;</span><br><span class="line">      return Proxy.newProxyInstance(</span><br><span class="line">          type.getClassLoader(),</span><br><span class="line">          interfaces,</span><br><span class="line">          new Plugin(target, interceptor, signatureMap));</span><br><span class="line">    &#125;</span><br><span class="line">    return target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass());</span><br><span class="line">      if (methods != null &amp;&amp; methods.contains(method)) &#123;</span><br><span class="line">        return interceptor.intercept(new Invocation(target, method, args));</span><br><span class="line">      &#125;</span><br><span class="line">      return method.invoke(target, args);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      throw ExceptionUtil.unwrapThrowable(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private static Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; getSignatureMap(Interceptor interceptor) &#123;</span><br><span class="line">    Intercepts interceptsAnnotation = interceptor.getClass().getAnnotation(Intercepts.class);</span><br><span class="line">    if (interceptsAnnotation == null) &#123; // issue #251</span><br><span class="line">      throw new PluginException(&quot;No @Intercepts annotation was found in interceptor &quot; + interceptor.getClass().getName());      </span><br><span class="line">    &#125;</span><br><span class="line">    Signature[] sigs = interceptsAnnotation.value();</span><br><span class="line">    Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = new HashMap&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt;();</span><br><span class="line">    for (Signature sig : sigs) &#123;</span><br><span class="line">      Set&lt;Method&gt; methods = signatureMap.get(sig.type());</span><br><span class="line">      if (methods == null) &#123;</span><br><span class="line">        methods = new HashSet&lt;Method&gt;();</span><br><span class="line">        signatureMap.put(sig.type(), methods);</span><br><span class="line">      &#125;</span><br><span class="line">      try &#123;</span><br><span class="line">        Method method = sig.type().getMethod(sig.method(), sig.args());</span><br><span class="line">        methods.add(method);</span><br><span class="line">      &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">        throw new PluginException(&quot;Could not find method on &quot; + sig.type() + &quot; named &quot; + sig.method() + &quot;. Cause: &quot; + e, e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return signatureMap;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private static Class&lt;?&gt;[] getAllInterfaces(Class&lt;?&gt; type, Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap) &#123;</span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; interfaces = new HashSet&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">    while (type != null) &#123;</span><br><span class="line">      for (Class&lt;?&gt; c : type.getInterfaces()) &#123;</span><br><span class="line">        if (signatureMap.containsKey(c)) &#123;</span><br><span class="line">          interfaces.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      type = type.getSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">    return interfaces.toArray(new Class&lt;?&gt;[interfaces.size()]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先看一下Plugin的wrap方法，它根据当前的Interceptor上面的注解定义哪些接口需要拦截，然后判断当前目标对象是否有实现对应需要拦截的接口，如果没有则返回目标对象本身，如果有则返回一个代理对象。而这个代理对象的InvocationHandler正是一个Plugin。所以当目标对象在执行接口方法时，如果是通过代理对象执行的，则会调用对应InvocationHandler的invoke方法，也就是Plugin的invoke方法。(至于到底为什么会调用这个方法，我相信其实有不少人都不是真的明白，这个我在之前的博客中有说过，因为在调用代理对象的方法的时候实际上调用的就是InvocationHandler的invoke方法，InvocationHandler对象作为代理对象的构造器参数注入，要彻底明白</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">         type.getClassLoader(),</span><br><span class="line">         interfaces,</span><br><span class="line">         <span class="keyword">new</span> Plugin(target, interceptor, signatureMap));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这句话到底做了什么才能彻底理解JDK动态代理</p>
<p>)所以接着我们来看一下该invoke方法的内容。这里invoke方法的逻辑是：如果当前执行的方法是定义好的需要拦截的方法，则把目标对象、要执行的方法以及方法参数封装成一个Invocation对象，再把封装好的Invocation作为参数传递给当前拦截器的intercept方法。如果不需要拦截，则直接调用当前的方法。Invocation中定义了定义了一个proceed方法，其逻辑就是调用当前方法，所以如果在intercept中需要继续调用当前方法的话可以调用invocation的procced方法。</p>
<p>​       这就是Mybatis中实现Interceptor拦截的一个思想，如果用户觉得这个思想有问题或者不能完全满足你的要求的话可以通过实现自己的Plugin来决定什么时候需要代理什么时候需要拦截。以下讲解的内容都是基于Mybatis的默认实现即通过Plugin来管理Interceptor来讲解的。</p>
<p>​       对于实现自己的Interceptor而言有两个很重要的注解，一个是@Intercepts，其值是一个@Signature数组。@Intercepts用于表明当前的对象是一个Interceptor，而@Signature则表明要拦截的接口、方法以及对应的参数类型。</p>
<p>那在真正的去写自己的拦截器之前，我们必须得要知道Mybatis拦截器应该作用在什么地方。</p>
<p>而他又是怎么起作用的。之前我们说过Mybatis拦截器主要是作用在四大组件上的,那么是怎么起作用的呢。</p>
<p>我们还是看源码。</p>
<p>我们在执行一次SQL过程中进行debug，当debug到SimpleExecutor执行器时，执行了doQuery方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException &#123;</span><br><span class="line">  Statement stmt = null;</span><br><span class="line">  try &#123;</span><br><span class="line">    Configuration configuration = ms.getConfiguration();</span><br><span class="line">    StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">    return handler.&lt;E&gt;query(stmt, resultHandler);</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    closeStatement(stmt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们主要看这行代码：</p>
<p>这行代码实际上生生成了除了执行器的其他三大组件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public StatementHandler newStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) &#123;</span><br><span class="line">  StatementHandler statementHandler = new RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">  statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br><span class="line">  return statementHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先new RoutingStatementHandler();看这个类的源码，发现实际上生成了delegate属性的StatementHandler对象,而且实际上的StatementHandler这个组件的方法执行就是执行delegate的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public RoutingStatementHandler(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) &#123;</span><br><span class="line"></span><br><span class="line">   switch (ms.getStatementType()) &#123;</span><br><span class="line">     case STATEMENT:</span><br><span class="line">       delegate = new SimpleStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">       break;</span><br><span class="line">     case PREPARED:</span><br><span class="line">       delegate = new PreparedStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">       break;</span><br><span class="line">     case CALLABLE:</span><br><span class="line">       delegate = new CallableStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">       break;</span><br><span class="line">     default:</span><br><span class="line">       throw new ExecutorException(&quot;Unknown statement type: &quot; + ms.getStatementType());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>我们看构造方法总共有三个可选的StatementHandler。</p>
<p>我们发现这三个StatementHandler都继承了BaseStatementHandler,我们知道在创建一个子类实例对象是一定会先执行父类的构造方法，那我们来看看BaseStatementHandler的构造方法都做了什么工作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">protected BaseStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) &#123;</span><br><span class="line">  this.configuration = mappedStatement.getConfiguration();</span><br><span class="line">  this.executor = executor;</span><br><span class="line">  this.mappedStatement = mappedStatement;</span><br><span class="line">  this.rowBounds = rowBounds;</span><br><span class="line"></span><br><span class="line">  this.typeHandlerRegistry = configuration.getTypeHandlerRegistry();</span><br><span class="line">  this.objectFactory = configuration.getObjectFactory();</span><br><span class="line"></span><br><span class="line">  if (boundSql == null) &#123; // issue #435, get the key before calculating the statement</span><br><span class="line">    generateKeys(parameterObject);</span><br><span class="line">    boundSql = mappedStatement.getBoundSql(parameterObject);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.boundSql = boundSql;</span><br><span class="line"></span><br><span class="line">  this.parameterHandler = configuration.newParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">  this.resultSetHandler = configuration.newResultSetHandler(executor, mappedStatement, rowBounds, parameterHandler, resultHandler, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看这个类的源码，我们会发现，她包含了其他两个组件，并且在构造方法里创建了这两个组件实现类的对象。</p>
<p>我们查看具体创建组件对象的源码，我们都会调用 interceptorChain.pluginAll方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public ParameterHandler newParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql) &#123;</span><br><span class="line">    ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">    parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);</span><br><span class="line">    return parameterHandler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public ResultSetHandler newResultSetHandler(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler,</span><br><span class="line">      ResultHandler resultHandler, BoundSql boundSql) &#123;</span><br><span class="line">    ResultSetHandler resultSetHandler = new DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);</span><br><span class="line">    resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);</span><br><span class="line">    return resultSetHandler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public StatementHandler newStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) &#123;</span><br><span class="line">    StatementHandler statementHandler = new RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">    statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br><span class="line">    return statementHandler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Executor newExecutor(Transaction transaction) &#123;</span><br><span class="line">    return newExecutor(transaction, defaultExecutorType);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Executor newExecutor(Transaction transaction, ExecutorType executorType) &#123;</span><br><span class="line">    executorType = executorType == null ? defaultExecutorType : executorType;</span><br><span class="line">    executorType = executorType == null ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    if (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">      executor = new BatchExecutor(this, transaction);</span><br><span class="line">    &#125; else if (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">      executor = new ReuseExecutor(this, transaction);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      executor = new SimpleExecutor(this, transaction);</span><br><span class="line">    &#125;</span><br><span class="line">    if (cacheEnabled) &#123;</span><br><span class="line">      executor = new CachingExecutor(executor);</span><br><span class="line">    &#125;</span><br><span class="line">    executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    return executor;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>终于找到了使用拦截器的地方了。</p>
<p>我们看看InterceptorChain的源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorChain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;Interceptor&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">      target = interceptor.plugin(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptor</span><span class="params">(Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">    interceptors.add(interceptor);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Interceptor&gt; <span class="title">getInterceptors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableList(interceptors);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类是收集所有拦截器的类，那如何收集所有的拦截器呢，通过配置文件加载到Configuration对象中。</p>
<p>通过如下方式写入Mybatis配置文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">      &lt;plugins&gt;  </span><br><span class="line">        &lt;plugin interceptor=&quot;com.wangcc.ssm.mybatis.interceptor.PageInterceptor&quot;&gt;  </span><br><span class="line">           &lt;property name=&quot;databaseType&quot; value=&quot;Oracle&quot;/&gt;  </span><br><span class="line">       &lt;/plugin&gt;  </span><br><span class="line">   &lt;plugin interceptor=&quot;com.wangcc.ssm.mybatis.interceptor.ParamMapInterceptor&quot;/&gt;  </span><br><span class="line">&lt;/plugins&gt;</span><br></pre></td></tr></table></figure>
<h3 id="三-实现自己的Mybatis拦截器"><a href="#三-实现自己的Mybatis拦截器" class="headerlink" title="三.实现自己的Mybatis拦截器"></a>三.实现自己的Mybatis拦截器</h3><p>好了，回到我们要解决的需求，我们要通过Mybatis拦截器来解决问题了。</p>
<p>通过前面几种情况，我们知道了，Mybatis自带的返回类型处理不能满足我们这个需求的要求。所以我们理所当然的想到，我们使用拦截器的目标是ResultSetHandler。我们知道返回结果是由ResultSetHandler的handleResultSets方法对当前的Statement处理后的返回结果，所以我们如果要改变返回结果的话就需要使用Mybatis的拦截器对ResultSetHandler接口的handleResultSets方法进行拦截。</p>
<p>这个时候我们就确定了该拦截器的注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts</span>(<span class="meta">@Signature</span>(method = <span class="string">"handleResultSets"</span>, type = ResultSetHandler.class, args = &#123; Statement.class &#125;))</span><br></pre></td></tr></table></figure>
<p>在之前分析四大组件对象生成时，说过每一个对象都要调用interceptorChain.pluginAll方法，这里的注解中的type = ResultSetHandler.class会使该拦截器只作用在ResultSetHandler上，但是目前来会对每一个ResultSetHandler都会起作用，所以我们还得在这个拦截器中想办法再做一层过滤，对于不需要拦截的调用Invocation的proceed()方法，而需要拦截的则实现我们自己的逻辑，返回对应的结果。现在我们要想的是怎么做这一层过滤以及怎么实现改变返回结果的效果。</p>
<ul>
<li><p>首先，这个过滤该怎样来实现呢，一般来说，通过parameterObj来过滤， 通过ParameterHandler得到：parameterHandler.getParameterObject();（我们定义的Dao层方法的参数）</p>
<p>​    那这里我们需要给出一个怎样的参数呢：</p>
<p>​    首先他得满足这几个条件</p>
<ul>
<li>（1）    可以指定哪个字段为返回Map的Key；</li>
<li>（2）    可以指定哪个字段为返回Map的Value；</li>
<li>（3）    可以附带其他参数；</li>
</ul>
</li>
</ul>
<p>那我们这里就给出我定义的参数ComplexParamMap</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComplexParamMap</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ParamMap paramMap;</span><br><span class="line">	<span class="keyword">private</span> T obj;<span class="comment">// 使用实体类的属性作为查询参数</span></span><br><span class="line">	<span class="keyword">private</span> Map&lt;String, Object&gt; params = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();<span class="comment">// 其他的参数我们把它分装成一个Map对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParamMap</span> <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 作为Key的字段对应MapParam的Key</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_FIELD = <span class="string">"mapKeyField"</span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 作为Value的字段对应MapParam的Key</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String VALUE_FIELD = <span class="string">"mapValueField"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ParamMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 指定keyField和valueField</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> keyField</span></span><br><span class="line"><span class="comment">	 *            Map中key对应的字段</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> valueField</span></span><br><span class="line"><span class="comment">	 *            Map中value对应的字段</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ParamMap</span><span class="params">(String keyField, String valueField)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.put(KEY_FIELD, keyField);</span><br><span class="line">		<span class="keyword">this</span>.put(VALUE_FIELD, valueField);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用泛型，方便 使用实体类的属性作为查询参数。</p>
<p>定义一个HashMap params 方便我们加入一些独立参数来作为查询参数。</p>
<p>ParamMap paramMap; 指定对应字段为返回Map的Key和Value；</p>
<ul>
<li><p>确定了过滤条件之后,我们就可以开始处理我们的逻辑了。</p>
<p>​    </p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts</span>(<span class="meta">@Signature</span>(method = <span class="string">"handleResultSets"</span>, type = ResultSetHandler.class, args = &#123; Statement.class &#125;))</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParamMapInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(ParamMapInterceptor.class);</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		Object target = invocation.getTarget();</span><br><span class="line">			<span class="comment">//目前Mybatis只有DefaultResultSetHandler这一种ResultSetHandler实现类</span></span><br><span class="line">      <span class="keyword">if</span> (target <span class="keyword">instanceof</span> DefaultResultSetHandler) &#123;</span><br><span class="line">          </span><br><span class="line">			DefaultResultSetHandler resultSetHandler = (DefaultResultSetHandler) target;</span><br><span class="line"></span><br><span class="line">			ParameterHandler parameterHandler = ReflectUtil.getFieldValue(resultSetHandler, <span class="string">"parameterHandler"</span>);</span><br><span class="line">			Object parameterObj = parameterHandler.getParameterObject();</span><br><span class="line">			<span class="keyword">if</span> (parameterObj <span class="keyword">instanceof</span> ComplexParamMap) &#123;</span><br><span class="line">				ComplexParamMap paramMap = (ComplexParamMap) parameterObj;</span><br><span class="line">				Statement stmt = (Statement) invocation.getArgs()[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">				<span class="keyword">return</span> handleResultSet(stmt.getResultSet(), paramMap);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> invocation.proceed();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> Object <span class="title">handleResultSet</span><span class="params">(ResultSet resultSet, ComplexParamMap cmap)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (resultSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">			ParamMap paramMap = cmap.getParamMap();</span><br><span class="line">			String keyField = paramMap.get(ParamMap.KEY_FIELD);</span><br><span class="line">			String valueField = paramMap.get(ParamMap.VALUE_FIELD);</span><br><span class="line">			Map&lt;Object, Object&gt; map = <span class="keyword">new</span> HashMap&lt;Object, Object&gt;();</span><br><span class="line">			<span class="comment">// 因为原方法返回的是List&lt;Object&gt;类型，所以</span></span><br><span class="line">			List&lt;Object&gt; resultList = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">					Object key = resultSet.getObject(keyField);</span><br><span class="line">					Object value = resultSet.getObject(valueField);</span><br><span class="line">					map.put(key, value);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				logger.error(<span class="string">"ParamMapInterceptor 的Method handleResultSet 使用ResultSet时出错"</span>);</span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				closeResultSet(resultSet);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			resultList.add(map);</span><br><span class="line">			<span class="keyword">return</span> resultList;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">closeResultSet</span><span class="params">(ResultSet resultSet)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (resultSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">				resultSet.close();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			logger.error(<span class="string">"关闭ResultSet资源时出错"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到现在我们就算完成了我们的第一个Mybatis拦截器了。</p>
<p>我们将这个拦截器注册到我们的Mybatis配置文件，注意在配置文件中的顺序位置。</p>
<p>然后开始测试，看是否能达到我们的要求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">	public void test() &#123;</span><br><span class="line">		SqlSession session = null;</span><br><span class="line">		System.out.println(&quot;Dd&quot;);</span><br><span class="line">		try &#123;</span><br><span class="line"></span><br><span class="line">			session = MybatisUtil.getCurrentSession();</span><br><span class="line">			CoachDao mapper = session.getMapper(CoachDao.class);</span><br><span class="line">			// Coach coach = mapper.getCoachById(1);</span><br><span class="line">			// System.out.println(coach);</span><br><span class="line">			ComplexParamMap&lt;Coach&gt; cmap = new ComplexParamMap&lt;Coach&gt;();</span><br><span class="line">			Coach coach = new Coach();</span><br><span class="line">			coach.setName(&quot;jackson&quot;);</span><br><span class="line">			ParamMap paramMap = new ParamMap(&quot;name&quot;, &quot;age&quot;);</span><br><span class="line">			cmap.setParamMap(paramMap);</span><br><span class="line">			Map&lt;String, Object&gt; params = new HashMap&lt;String, Object&gt;();</span><br><span class="line">			params.put(&quot;name&quot;, &quot;jackson&quot;);</span><br><span class="line">			cmap.setParams(params);</span><br><span class="line">			cmap.setObj(coach);</span><br><span class="line">			Map&lt;Object, Object&gt; map = mapper.queryMap(cmap);</span><br><span class="line">			System.out.println(JSON.toJSONString(map));</span><br><span class="line">			Page&lt;Coach, ?&gt; page = new Page&lt;&gt;();</span><br><span class="line">			page.setSelf(coach);</span><br><span class="line">			page.setPageSize(4);</span><br><span class="line">			page.setPageNo(2);</span><br><span class="line">			List&lt;Coach&gt; list = mapper.querybyPage(page);</span><br><span class="line">			System.out.println(JSON.toJSONString(list));</span><br><span class="line"></span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			// TODO: handle exception</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; finally &#123;</span><br><span class="line">			session.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>Mapper配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;queryMap&quot; resultType=&quot;map&quot; parameterType=&quot;ComplexParamMap&quot;&gt;</span><br><span class="line">select id,name from coach where name=#&#123;obj.name&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<p>查看输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">==&gt; Parameters: jackson(String)</span><br><span class="line">&lt;==    Columns: ID, NAME</span><br><span class="line">&lt;==        Row: 1, jackson</span><br><span class="line">&lt;==        Row: 2, jackson</span><br><span class="line">&lt;==        Row: 10, jackson</span><br><span class="line">&lt;==        Row: 5, jackson</span><br><span class="line">&lt;==        Row: 3, jackson</span><br><span class="line">&lt;==        Row: 11, jackson</span><br><span class="line">&lt;==      Total: 6</span><br><span class="line">&#123;1:&quot;jackson&quot;,2:&quot;jackson&quot;,3:&quot;jackson&quot;,5:&quot;jackson&quot;,10:&quot;jackson&quot;,11:&quot;jackson&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>完美的结果。</p>
<p>接下来我们再看下在Mybatis中使用广泛的分页插件拦截器。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2017/11/22/Mybatis插件/" data-id="cjbkujwuj0001ocbz8q6bt4rn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/11/26/MapperMethod/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          MapperMethod
        
      </div>
    </a>
  
  
    <a href="/2017/11/19/HashMap/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">HashMap</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java-WEB/">Java WEB</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java基础/">Java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mybatis/">Mybatis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringMVC/">SpringMVC</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/01/07/--SpringMVC配置文件的解析(二)/">SpringMVC配置文件的解析(二)</a>
          </li>
        
          <li>
            <a href="/2018/01/07/SpringMVC配置文件详解(一)/">SpringMVC配置文件详解</a>
          </li>
        
          <li>
            <a href="/2018/01/07/--SpringMVC配置文件解析(三)/">SpringMVC配置文件解析(三)</a>
          </li>
        
          <li>
            <a href="/2018/01/06/--SpringMVC配置文件解析(四)/">SpringMVC配置文件详解（四）</a>
          </li>
        
          <li>
            <a href="/2017/12/24/--Tomcat是如何处理web.xml的（下）/">Tomcat是如何处理web.xml的（下）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>