<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>ResultSetHandler | 迷途书童的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="ResultSetHandler介绍ResultSetHandler是处理结果集的接口，在我看来他的实现类DefaultResultSetHandler是最难理解的一个组件，之所以复杂是因为Mybatis中ResultMap的设计非常强大，他可以满足用户的很多需求。 MyBatis是基于“数据库结构不可控”的思想建立的">
<meta property="og:type" content="article">
<meta property="og:title" content="ResultSetHandler">
<meta property="og:url" content="https://cong96.github.io/2017/11/26/ResultSetHandler/index.html">
<meta property="og:site_name" content="迷途书童的博客">
<meta property="og:description" content="ResultSetHandler介绍ResultSetHandler是处理结果集的接口，在我看来他的实现类DefaultResultSetHandler是最难理解的一个组件，之所以复杂是因为Mybatis中ResultMap的设计非常强大，他可以满足用户的很多需求。 MyBatis是基于“数据库结构不可控”的思想建立的，也就是我们希望数据库遵循第三范式或BCNF，但实际事与愿违，那么结果集映射就">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2017-11-26T15:44:12.723Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ResultSetHandler">
<meta name="twitter:description" content="ResultSetHandler介绍ResultSetHandler是处理结果集的接口，在我看来他的实现类DefaultResultSetHandler是最难理解的一个组件，之所以复杂是因为Mybatis中ResultMap的设计非常强大，他可以满足用户的很多需求。 MyBatis是基于“数据库结构不可控”的思想建立的，也就是我们希望数据库遵循第三范式或BCNF，但实际事与愿违，那么结果集映射就">
  
    <link rel="alternate" href="/atom.xml" title="迷途书童的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">迷途书童的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">一天进步一点</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://cong96.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-ResultSetHandler" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/26/ResultSetHandler/" class="article-date">
  <time datetime="2017-11-26T08:57:57.064Z" itemprop="datePublished">2017-11-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Mybatis/">Mybatis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      ResultSetHandler
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="ResultSetHandler介绍"><a href="#ResultSetHandler介绍" class="headerlink" title="ResultSetHandler介绍"></a>ResultSetHandler介绍</h3><p>ResultSetHandler是处理结果集的接口，在我看来他的实现类DefaultResultSetHandler是最难理解的一个组件，之所以复杂是因为Mybatis中ResultMap的设计非常强大，他可以满足用户的很多需求。</p>
<p>MyBatis是基于“数据库结构不可控”的思想建立的，也就是我们希望数据库遵循第三范式或BCNF，但实际事与愿违，那么结果集映射就是MyBatis为我们提供这种理想与现实间转换的手段了，为了实现这一灵活的转化，给用户带来便利，Mybatis做了很多努力，这些努力的具体实现大多都体现在DefaultResultSetHandler这个类中。所以在后面我们会通过查询过程的Debug来好好分析这个类。</p>
<p>我们先看看ResultSetHandler接口的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResultSetHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">handleResultSets</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">handleOutputParameters</span><span class="params">(CallableStatement cs)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个接口只定义了两个方法</p>
<p>handleResultSets就是用来处理结果集的方法，如何将数据库执行后返回的结果集转化为我们在Mapper文件中定义的ResultMap对应的返回，就是通过这个方法实现的。</p>
<p>handleOutputParameters这个方法目前还没有用到，因为目前还没有使用到存储过程。</p>
<h3 id="handleResultSets"><a href="#handleResultSets" class="headerlink" title="handleResultSets"></a>handleResultSets</h3><p>我们接着分析查询的过程</p>
<p>现在代码已经执行到了这个阶段</p>
<p>PreparedStatementHandler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">   PreparedStatement ps = (PreparedStatement) statement;</span><br><span class="line"><span class="comment">//执行数据库操作</span></span><br><span class="line">   ps.execute();</span><br><span class="line">   <span class="comment">//调用handleResultSets处理结果集</span></span><br><span class="line">   <span class="keyword">return</span> resultSetHandler.&lt;E&gt; handleResultSets(ps);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>执行ps.execute();后</p>
<p>控制台如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Setting autocommit to <span class="keyword">false</span> on JDBC Connection [com.mysql.jdbc.JDBC4Connection@<span class="number">2</span>ed2d9cb]</span><br><span class="line">==&gt;  Preparing: select * <span class="function">from t_user where t_id <span class="title">in</span> <span class="params">( ? , ? , ? )</span> </span></span><br><span class="line"><span class="function"></span>==&gt; Parameters: <span class="number">1</span>(Integer), <span class="number">3</span>(Integer), <span class="number">25</span>(Integer)</span><br></pre></td></tr></table></figure>
<p>进入handleResultSets方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">handleResultSets</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">   ErrorContext.instance().activity(<span class="string">"handling results"</span>).object(mappedStatement.getId());</span><br><span class="line">   	<span class="comment">//先新建一个存放最终的结果的ArrayList</span></span><br><span class="line">   <span class="keyword">final</span> List&lt;Object&gt; multipleResults = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> resultSetCount = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//得到ResultSet结果集， 然后对ResultSetMetaData元数据封装一下</span></span><br><span class="line">   ResultSetWrapper rsw = getFirstResultSet(stmt);</span><br><span class="line"><span class="comment">//得到该SqlMapper配置文件指定的ResultMap</span></span><br><span class="line">   List&lt;ResultMap&gt; resultMaps = mappedStatement.getResultMaps();</span><br><span class="line">   <span class="keyword">int</span> resultMapCount = resultMaps.size();</span><br><span class="line">  <span class="comment">//校验ResultMap的数量，不能为0或者不存在，如果是，则会抛出异常</span></span><br><span class="line">   validateResultMapsCount(rsw, resultMapCount);</span><br><span class="line">   <span class="keyword">while</span> (rsw != <span class="keyword">null</span> &amp;&amp; resultMapCount &gt; resultSetCount) &#123;</span><br><span class="line">     <span class="comment">//依次从List集合中按index取ResultMap</span></span><br><span class="line">     ResultMap resultMap = resultMaps.get(resultSetCount);</span><br><span class="line">     <span class="comment">//然后加入针对ResultMap处理结果集的方法</span></span><br><span class="line">     handleResultSet(rsw, resultMap, multipleResults, <span class="keyword">null</span>);</span><br><span class="line">     rsw = getNextResultSet(stmt);</span><br><span class="line">     cleanUpAfterHandlingResultSet();</span><br><span class="line">     resultSetCount++;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   String[] resultSets = mappedStatement.getResulSets();</span><br><span class="line">   <span class="keyword">if</span> (resultSets != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="keyword">while</span> (rsw != <span class="keyword">null</span> &amp;&amp; resultSetCount &lt; resultSets.length) &#123;</span><br><span class="line">       ResultMapping parentMapping = nextResultMaps.get(resultSets[resultSetCount]);</span><br><span class="line">       <span class="keyword">if</span> (parentMapping != <span class="keyword">null</span>) &#123;</span><br><span class="line">         String nestedResultMapId = parentMapping.getNestedResultMapId();</span><br><span class="line">         ResultMap resultMap = configuration.getResultMap(nestedResultMapId);</span><br><span class="line">         handleResultSet(rsw, resultMap, <span class="keyword">null</span>, parentMapping);</span><br><span class="line">       &#125;</span><br><span class="line">       rsw = getNextResultSet(stmt);</span><br><span class="line">       cleanUpAfterHandlingResultSet();</span><br><span class="line">       resultSetCount++;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> collapseSingleResultList(multipleResults);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>getFirstResultSet</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ResultSetWrapper <span class="title">getFirstResultSet</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  </span><br><span class="line">    ResultSet rs = stmt.getResultSet();</span><br><span class="line">    <span class="keyword">while</span> (rs == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// move forward to get the first resultset in case the driver</span></span><br><span class="line">      <span class="comment">// doesn't return the resultset as the first result (HSQLDB 2.1)</span></span><br><span class="line">      <span class="keyword">if</span> (stmt.getMoreResults()) &#123;</span><br><span class="line">        rs = stmt.getResultSet();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stmt.getUpdateCount() == -<span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">// no more results. Must be no resultset</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rs != <span class="keyword">null</span> ? <span class="keyword">new</span> ResultSetWrapper(rs, configuration) : <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法就是为了得到ResultSet结果集，如果成功得到结果集，就将结果集封装一下，返回封装好的ResultSetWrapper对象</p>
<p>这个方法里面用到了一些原生JDBC的API方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">getResultSet</span><br><span class="line">ResultSet getResultSet()</span><br><span class="line">                       throws SQLException以 ResultSet 对象的形式获取当前结果。每个结果只应调用一次此方法。 </span><br><span class="line"></span><br><span class="line">返回：</span><br><span class="line">以 ResultSet 对象的形式返回当前结果；如果结果是更新计数或没有更多的结果，则返回 null </span><br><span class="line">抛出： </span><br><span class="line">SQLException - 如果发生数据库访问错误，或者在已关闭的 Statement 上调用此方法</span><br><span class="line">另请参见：</span><br><span class="line">execute(java.lang.String)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">getMoreResults</span><br><span class="line">boolean getMoreResults(int current)</span><br><span class="line">                       throws SQLException将此 Statement 对象移动到下一个结果，根据给定标志指定的指令处理所有当前 ResultSet 对象；如果下一个结果为 ResultSet 对象，则返回 true。 </span><br><span class="line">当以下表达式为 true 时没有更多结果： </span><br><span class="line"></span><br><span class="line">     // stmt is a Statement object</span><br><span class="line">     ((stmt.getMoreResults(current) == false) &amp;&amp; (stmt.getUpdateCount() == -1))</span><br><span class="line"> </span><br><span class="line">参数：</span><br><span class="line">current - 下列 Statement 常量之一，这些常量指示将对使用 getResultSet 方法获取的当前 ResultSet 对象发生的操作：Statement.CLOSE_CURRENT_RESULT、Statement.KEEP_CURRENT_RESULT 或 Statement.CLOSE_ALL_RESULTS </span><br><span class="line">返回：</span><br><span class="line">如果下一个结果为 ResultSet 对象，则返回 true；如果其为更新计数或者不存在更多的结果，则返回 false </span><br><span class="line">抛出： </span><br><span class="line">SQLException - 如果发生数据库访问错误，在已关闭的 Statement 上调用此方法，或者提供的参数不是以下参数之一：Statement.CLOSE_CURRENT_RESULT、Statement.KEEP_CURRENT_RESULT 或 Statement.CLOSE_ALL_RESULTS </span><br><span class="line">SQLFeatureNotSupportedException - 如果 DatabaseMetaData.supportsMultipleOpenResults 返回 false，并且 Statement.KEEP_CURRENT_RESULT 或 Statement.CLOSE_ALL_RESULTS 作为参数提供。</span><br><span class="line">从以下版本开始： </span><br><span class="line">1.4 </span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">getUpdateCount</span><br><span class="line">int getUpdateCount()</span><br><span class="line">                   throws SQLException以更新计数的形式获取当前结果；如果结果为 ResultSet 对象或没有更多结果，则返回 -1。每个结果只应调用一次此方法。 </span><br><span class="line"></span><br><span class="line">返回：</span><br><span class="line">以更新计数的形式返回当前结果；如果当前结果为 ResultSet 对象或没有更多结果，则返回 -1 </span><br><span class="line">抛出： </span><br><span class="line">SQLException - 如果发生数据库访问错误，或者在已关闭的 Statement 上调用此方法</span><br><span class="line">另请参见：</span><br><span class="line">execute(java.lang.String)</span><br></pre></td></tr></table></figure>
<p>我们也有必要了解这个封装的对象ResultSetWrapper</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResultSetWrapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ResultSet resultSet;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> TypeHandlerRegistry typeHandlerRegistry;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; columnNames = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; classNames = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;JdbcType&gt; jdbcTypes = <span class="keyword">new</span> ArrayList&lt;JdbcType&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Map&lt;Class&lt;?&gt;, TypeHandler&lt;?&gt;&gt;&gt; typeHandlerMap = <span class="keyword">new</span> HashMap&lt;String, Map&lt;Class&lt;?&gt;, TypeHandler&lt;?&gt;&gt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> Map&lt;String, List&lt;String&gt;&gt; mappedColumnNamesMap = <span class="keyword">new</span> HashMap&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> Map&lt;String, List&lt;String&gt;&gt; unMappedColumnNamesMap = <span class="keyword">new</span> HashMap&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ResultSetWrapper</span><span class="params">(ResultSet rs, Configuration configuration)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="comment">//注入了TypeHandlerRegistry,TypeHandler的注册中心</span></span><br><span class="line">    <span class="keyword">this</span>.typeHandlerRegistry = configuration.getTypeHandlerRegistry();</span><br><span class="line">    <span class="comment">//注入了ResultSet</span></span><br><span class="line">    <span class="keyword">this</span>.resultSet = rs;</span><br><span class="line">    <span class="comment">//得到ResultSet的元数据 可用于获取关于 ResultSet 对象中列的类型和属性信息的对象。</span></span><br><span class="line">    <span class="keyword">final</span> ResultSetMetaData metaData = rs.getMetaData();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> columnCount = metaData.getColumnCount();</span><br><span class="line">    <span class="comment">//对元数据的相关有用信息进行封装</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= columnCount; i++) &#123;</span><br><span class="line">      <span class="comment">//将返回的元数据的ColumnName添加到一个String类型的ArrayList中，如果SQL中使用了AS ColumnLable就取ColumnLable，否则就取ColumnName.</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      getColumnLabel</span></span><br><span class="line"><span class="comment">String getColumnLabel(int column)</span></span><br><span class="line"><span class="comment">                      throws SQLException获取用于打印输出和显示的指定列的建议标题。建议标题通常由 SQL AS 子句来指定。如果未指定 SQL AS，则从 getColumnLabel 返回的值将和 getColumnName 方法返回的值相同。</span></span><br><span class="line"><span class="comment">                      </span></span><br><span class="line"><span class="comment">                      getColumnName</span></span><br><span class="line"><span class="comment">String getColumnName(int column)</span></span><br><span class="line"><span class="comment">                     throws SQLException获取指定列的名称。 </span></span><br><span class="line"><span class="comment">      </span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      </span><br><span class="line">      columnNames.add(configuration.isUseColumnLabel() ? metaData.getColumnLabel(i) : metaData.getColumnName(i));</span><br><span class="line">     </span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      getColumnType</span></span><br><span class="line"><span class="comment">int getColumnType(int column)</span></span><br><span class="line"><span class="comment">                  throws SQLException获取指定列的 SQL 类型。</span></span><br><span class="line"><span class="comment">      得到元数据指定Column的SQL 类型类型，将类型也存储到一个List集合中</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      jdbcTypes.add(JdbcType.forCode(metaData.getColumnType(i)));</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      getColumnClassName</span></span><br><span class="line"><span class="comment">String getColumnClassName(int column)</span></span><br><span class="line"><span class="comment">                          throws SQLException如果调用方法 ResultSet.getObject 从列中获取值，则返回构造其实例的 Java 类的完全限定名称。ResultSet.getObject 可能返回此方法所返回的类的子类。 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">column - 第一列是 1，第二个列是 2，…… </span></span><br><span class="line"><span class="comment">返回：</span></span><br><span class="line"><span class="comment">Java 编程语言中类的完全限定名称，方法 ResultSet.getObject 将使用该名称获取指定列中的值。此名称为用于自定义映射关系的类名称。 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      </span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="comment">//将列对应的类完全限定名也加入一个List中</span></span><br><span class="line">      classNames.add(metaData.getColumnClassName(i));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>handleResultSet</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleResultSet</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, List&lt;Object&gt; multipleResults, ResultMapping parentMapping)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//是否有父Mapper</span></span><br><span class="line">     <span class="keyword">if</span> (parentMapping != <span class="keyword">null</span>) &#123;</span><br><span class="line">       handleRowValues(rsw, resultMap, <span class="keyword">null</span>, RowBounds.DEFAULT, parentMapping);</span><br><span class="line">     &#125; </span><br><span class="line">     <span class="comment">//如果没有</span></span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">//且ResultHandler为空，即Method参数列表中没有ResultHandler</span></span><br><span class="line">       <span class="keyword">if</span> (resultHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">//新建一个DefaultResultHandler</span></span><br><span class="line">         DefaultResultHandler defaultResultHandler = <span class="keyword">new</span> DefaultResultHandler(objectFactory);</span><br><span class="line">        <span class="comment">//然后将新的resultHandler注入到handleRowValues中，对结果集进行处理</span></span><br><span class="line">         handleRowValues(rsw, resultMap, defaultResultHandler, rowBounds, <span class="keyword">null</span>);</span><br><span class="line">         multipleResults.add(defaultResultHandler.getResultList());</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         handleRowValues(rsw, resultMap, resultHandler, rowBounds, <span class="keyword">null</span>);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     closeResultSet(rsw.getResultSet()); <span class="comment">// issue #228 (close resultsets)</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>handleRowValues</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleRowValues</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler resultHandler, RowBounds rowBounds, ResultMapping parentMapping)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (resultMap.hasNestedResultMaps()) &#123;</span><br><span class="line">     ensureNoRowBounds();</span><br><span class="line">     checkResultHandler();</span><br><span class="line">     handleRowValuesForNestedResultMap(rsw, resultMap, resultHandler, rowBounds, parentMapping);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     handleRowValuesForSimpleResultMap(rsw, resultMap, resultHandler, rowBounds, parentMapping);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>handleRowValuesForSimpleResultMap</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleRowValuesForSimpleResultMap</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler resultHandler, RowBounds rowBounds, ResultMapping parentMapping)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">//临时存储结果的上下文</span></span><br><span class="line">    DefaultResultContext resultContext = <span class="keyword">new</span> DefaultResultContext();</span><br><span class="line">    <span class="comment">//这个方法与RowBounds有关，目前没有理解这个方法，但是这个方法目前不是特别重要。</span></span><br><span class="line">    skipRows(rsw.getResultSet(), rowBounds);</span><br><span class="line">    <span class="comment">//判断是否需要继续执行</span></span><br><span class="line">    <span class="comment">//shouldProcessMoreRows会去校验上下文的标志位以及行数是否超过RowBounds的限制</span></span><br><span class="line">    <span class="comment">// rsw.getResultSet().next()就很好理解了,看下API的解释就明了了</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    next</span></span><br><span class="line"><span class="comment">boolean next()</span></span><br><span class="line"><span class="comment">             throws SQLException将光标从当前位置向前移一行。ResultSet 光标最初位于第一行之前；第一次调用 next 方法使第一行成为当前行；第二次调用使第二行成为当前行，依此类推。 </span></span><br><span class="line"><span class="comment">当调用 next 方法返回 false 时，光标位于最后一行的后面。任何要求当前行的 ResultSet 方法调用将导致抛出 SQLException。如果结果集的类型是 TYPE_FORWARD_ONLY，则其 JDBC 驱动程序实现对后续 next 调用是返回 false 还是抛出 SQLException 将由供应商指定。 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如果对当前行开启了输入流，则调用 next 方法将隐式关闭它。读取新行时，将清除 ResultSet 对象的警告链。 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">返回：</span></span><br><span class="line"><span class="comment">如果新的当前行有效，则返回 true；如果不存在下一行，则返回 false </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//当执行了rsw.getResultSet().next()后，第一个结果集就出来了</span></span><br><span class="line">    <span class="comment">//控制台新增输出： </span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    &lt;==    Columns: t_id, t_name, address</span></span><br><span class="line"><span class="comment">&lt;==        Row: 1, kobe, los</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span> (shouldProcessMoreRows(resultContext, rowBounds) &amp;&amp; rsw.getResultSet().next()) &#123;</span><br><span class="line">      <span class="comment">//这个方法目前没有深究，但是看到Discriminated我想应该是校验是否在SqlMapper中用到了discriminate把，之后测试了这一情况再来细说</span></span><br><span class="line">      ResultMap discriminatedResultMap = resolveDiscriminatedResultMap(rsw.getResultSet(), resultMap, <span class="keyword">null</span>);</span><br><span class="line">      <span class="comment">//这里终于到了正式处理结果集的时候了，</span></span><br><span class="line">      Object rowValue = getRowValue(rsw, discriminatedResultMap);</span><br><span class="line">      storeObject(resultHandler, resultContext, rowValue, parentMapping, rsw.getResultSet());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>getRowValue(rsw, discriminatedResultMap)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">getRowValue</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ResultLoaderMap lazyLoader = <span class="keyword">new</span> ResultLoaderMap();</span><br><span class="line">  <span class="comment">//创建我们要返回的对象类型，这里是User</span></span><br><span class="line">    Object resultObject = createResultObject(rsw, resultMap, lazyLoader, <span class="keyword">null</span>);</span><br><span class="line">  <span class="comment">// 创建的实例不为空而且也不是基本类型（泛指） </span></span><br><span class="line">  <span class="keyword">if</span> (resultObject != <span class="keyword">null</span> &amp;&amp; !typeHandlerRegistry.hasTypeHandler(resultMap.getType())) &#123;</span><br><span class="line">      <span class="comment">//构造出一个Mybatis自己定义的MetaObject</span></span><br><span class="line">      <span class="keyword">final</span> MetaObject metaObject = configuration.newMetaObject(resultObject);</span><br><span class="line">    <span class="comment">//判断是否有指定构造方法</span></span><br><span class="line">      <span class="keyword">boolean</span> foundValues = resultMap.getConstructorResultMappings().size() &gt; <span class="number">0</span>;</span><br><span class="line"> 	<span class="comment">//判断是否有autoMapping，如果没有执行if下的语句，目前还没有弄清楚autoMapping是什么属性</span></span><br><span class="line">    <span class="keyword">if</span> (shouldApplyAutomaticMappings(resultMap, !AutoMappingBehavior.NONE.equals(configuration.getAutoMappingBehavior()))) &#123;      </span><br><span class="line">      <span class="comment">//处理没有显式用result节点声明的ColumnName</span></span><br><span class="line">        foundValues = applyAutomaticMappings(rsw, resultMap, metaObject, <span class="keyword">null</span>) || foundValues;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">//处理显式使用result节点声明的ColumnName</span></span><br><span class="line">      foundValues = applyPropertyMappings(rsw, resultMap, metaObject, lazyLoader, <span class="keyword">null</span>) || foundValues;</span><br><span class="line">      foundValues = lazyLoader.size() &gt; <span class="number">0</span> || foundValues;</span><br><span class="line">      resultObject = foundValues ? resultObject : <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">return</span> resultObject;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>createResultObject(ResultSetWrapper rsw, ResultMap resultMap, ResultLoaderMap lazyLoader, String</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">createResultObject</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, ResultLoaderMap lazyLoader, String columnPrefix)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> List&lt;Class&lt;?&gt;&gt; constructorArgTypes = <span class="keyword">new</span> ArrayList&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> List&lt;Object&gt; constructorArgs = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">    <span class="keyword">final</span> Object resultObject = createResultObject(rsw, resultMap, constructorArgTypes, constructorArgs, columnPrefix);</span><br><span class="line">  <span class="comment">//创建的实例不为空而且也不是基本类型（泛指）</span></span><br><span class="line">    <span class="keyword">if</span> (resultObject != <span class="keyword">null</span> &amp;&amp; !typeHandlerRegistry.hasTypeHandler(resultMap.getType())) &#123;</span><br><span class="line">      <span class="keyword">final</span> List&lt;ResultMapping&gt; propertyMappings = resultMap.getPropertyResultMappings();</span><br><span class="line">      <span class="comment">//就看下propertyMappings里面是不是带有查询，即select属性</span></span><br><span class="line">	<span class="comment">//propertyMappings 很显然就对应ResultMap节点中的Result节点</span></span><br><span class="line">      <span class="keyword">for</span> (ResultMapping propertyMapping : propertyMappings) &#123;</span><br><span class="line">        <span class="comment">//如果带有select属性而且指定了是懒加载</span></span><br><span class="line">        <span class="keyword">if</span> (propertyMapping.getNestedQueryId() != <span class="keyword">null</span> &amp;&amp; propertyMapping.isLazy()) &#123; <span class="comment">// issue gcode #109 &amp;&amp; issue #149</span></span><br><span class="line">          <span class="comment">//具体这种方式是如何创建的，目前还没有测试过，后续再细说</span></span><br><span class="line">          <span class="keyword">return</span> configuration.getProxyFactory().createProxy(resultObject, lazyLoader, configuration, objectFactory, constructorArgTypes, constructorArgs);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultObject;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>createResultObject</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">createResultObject</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs, String columnPrefix)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">//先得到ResultMap要返回的类型，也就是我们在Mapper文件中对ResultMap配置时的type属性</span></span><br><span class="line">  <span class="keyword">final</span> Class&lt;?&gt; resultType = resultMap.getType();</span><br><span class="line">  <span class="comment">//这个目前测试的都是为null的，看这个命名应该是ResultMap中有指定对应的返回类型的构造方法吧</span></span><br><span class="line">  <span class="keyword">final</span> List&lt;ResultMapping&gt; constructorMappings = resultMap.getConstructorResultMappings();</span><br><span class="line">  <span class="comment">//如果对应的返回类型不是JavaBean或者集合类型等，而是基本类型或者是他的一些包装类和时间日期等类型</span></span><br><span class="line">  <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(resultType)) &#123;</span><br><span class="line">  <span class="comment">//创建基本类型的返回类型的实例</span></span><br><span class="line">    <span class="keyword">return</span> createPrimitiveResultObject(rsw, resultMap, columnPrefix);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果指定了构造方法，使用构造方法来创建实例</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (constructorMappings.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> createParameterizedResultObject(rsw, resultType, constructorMappings, constructorArgTypes, constructorArgs, columnPrefix);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//要不然使用objectFactory来创建实例</span></span><br><span class="line">    <span class="keyword">return</span> objectFactory.create(resultType);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>objectFactory.create(resultType)</strong></p>
<p>DefaultObjectFactory</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> create(type, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(Class&lt;T&gt; type, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; classToCreate = resolveInterface(type);</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="comment">// we know types are assignable</span></span><br><span class="line">    T created = (T) instantiateClass(classToCreate, constructorArgTypes, constructorArgs);</span><br><span class="line">    <span class="keyword">return</span> created;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">instantiateClass</span><span class="params">(Class&lt;T&gt; type, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Constructor&lt;T&gt; constructor;</span><br><span class="line">      <span class="comment">//如果没有在ResultMap中指定构造方法,Mybatis默认该类只有默认的无参构造方法</span></span><br><span class="line">      <span class="keyword">if</span> (constructorArgTypes == <span class="keyword">null</span> || constructorArgs == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        getDeclaredConstructor</span></span><br><span class="line"><span class="comment">public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</span></span><br><span class="line"><span class="comment">                                      throws NoSuchMethodException,</span></span><br><span class="line"><span class="comment">                                             SecurityException返回一个 Constructor 对象，该对象反映此 Class 对象所表示的类或接口的指定构造方法。parameterTypes 参数是 Class 对象的一个数组，它按声明顺序标识构造方法的形参类型。 如果此 Class 对象表示非静态上下文中声明的内部类，则形参类型作为第一个参数包括显示封闭的实例。 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">parameterTypes - 参数数组 </span></span><br><span class="line"><span class="comment">返回：</span></span><br><span class="line"><span class="comment">带有指定参数列表的构造方法的 Constructor 对象 </span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//这里调用该方法时没有指定参数，意思即试图返回该类的无参构造方法，如果没有无参构造方法，就会抛出异常，然后再后面的catch住，后抛出给用户</span></span><br><span class="line">        constructor = type.getDeclaredConstructor();</span><br><span class="line">        <span class="keyword">if</span> (!constructor.isAccessible()) &#123;</span><br><span class="line">          constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果存在无参构造方法，就直接创建一个实例且返回</span></span><br><span class="line">        <span class="keyword">return</span> constructor.newInstance();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果有指定构造方法，试图返回相应的有参构造方法，如果失败，抛出异常后catch住重新抛出给用户</span></span><br><span class="line">      constructor = type.getDeclaredConstructor(constructorArgTypes.toArray(<span class="keyword">new</span> Class[constructorArgTypes.size()]));</span><br><span class="line">      <span class="keyword">if</span> (!constructor.isAccessible()) &#123;</span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> constructor.newInstance(constructorArgs.toArray(<span class="keyword">new</span> Object[constructorArgs.size()]));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      StringBuilder argTypes = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">      <span class="keyword">if</span> (constructorArgTypes != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; argType : constructorArgTypes) &#123;</span><br><span class="line">          argTypes.append(argType.getSimpleName());</span><br><span class="line">          argTypes.append(<span class="string">","</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      StringBuilder argValues = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">      <span class="keyword">if</span> (constructorArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object argValue : constructorArgs) &#123;</span><br><span class="line">          argValues.append(String.valueOf(argValue));</span><br><span class="line">          argValues.append(<span class="string">","</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ReflectionException(<span class="string">"Error instantiating "</span> + type + <span class="string">" with invalid types ("</span> + argTypes + <span class="string">") or values ("</span> + argValues + <span class="string">"). Cause: "</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>当我们分析完这段代码的时候，我们就可以很清楚的知道为什么当我们没有在ResultMap中显式的指定构造方法时，如果我们对我们的JavaBean创建了一个有参构造方法而此时没有显式的给出无参构造方法，这时运行程序，就会抛出Error instantiating异常。</p>
<p>有些同学可能会觉得看源码的用处不大，甚至是浪费时间，但是我不这样觉得，看源码还是有很多好处的。</p>
<p>1、看源码我们可以学习框架的设计思想，学习设计模式。</p>
<p>2、看源码可以加深对JDK API的认识，再复杂的代码都是基于JDK API写出来的，对JDK API的熟悉度会一定程度决定你的编码质量。</p>
<p>3、看源码虽然确实很花时间，但是看了源码之后我们才真正的做到了知其然，也知其所以然，这是一个热爱的代码，热爱编程了必须要有的专研精神，看了源码，我们就知道了，这个框架到底为什么要这样用，为什么那样配置就不对，为什么会报这个错误，这样我们才能利用用框架工具，而不是被框架牵着走。</p>
<p>啰嗦完了，继续往下看。</p>
<p><strong>configuration.newMetaObject(resultObject)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MetaObject <span class="title">newMetaObject</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> MetaObject.forObject(object, objectFactory, objectWrapperFactory);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MetaObject <span class="title">forObject</span><span class="params">(Object object, ObjectFactory objectFactory, ObjectWrapperFactory objectWrapperFactory)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> SystemMetaObject.NULL_META_OBJECT;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> MetaObject(object, objectFactory, objectWrapperFactory);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="title">MetaObject</span><span class="params">(Object object, ObjectFactory objectFactory, ObjectWrapperFactory objectWrapperFactory)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.originalObject = object;</span><br><span class="line">   <span class="keyword">this</span>.objectFactory = objectFactory;</span><br><span class="line">   <span class="keyword">this</span>.objectWrapperFactory = objectWrapperFactory;</span><br><span class="line"><span class="comment">//如果object已经是封装过的ObjectWarpper,就不需要再封装了，直接转化为ObjectWarpper类型就好了</span></span><br><span class="line">   <span class="keyword">if</span> (object <span class="keyword">instanceof</span> ObjectWrapper) &#123;</span><br><span class="line">     <span class="keyword">this</span>.objectWrapper = (ObjectWrapper) object;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果是已经封装了，去Factory里取</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (objectWrapperFactory.hasWrapperFor(object)) &#123;</span><br><span class="line">     <span class="keyword">this</span>.objectWrapper = objectWrapperFactory.getWrapperFor(<span class="keyword">this</span>, object);</span><br><span class="line">   &#125; </span><br><span class="line">   <span class="comment">//如果是Map类型，创建一个MapWrapper</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (object <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">     <span class="keyword">this</span>.objectWrapper = <span class="keyword">new</span> MapWrapper(<span class="keyword">this</span>, (Map) object);</span><br><span class="line">   &#125; </span><br><span class="line">   <span class="comment">//如果是Collection类型，一定要注意哦，Collection和Map是平级的哦，Map可不属于Collection</span></span><br><span class="line">   <span class="comment">//Collection下面有List Set等</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (object <span class="keyword">instanceof</span> Collection) &#123;</span><br><span class="line">     <span class="keyword">this</span>.objectWrapper = <span class="keyword">new</span> CollectionWrapper(<span class="keyword">this</span>, (Collection) object);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">//否则创建一个JavaBean 普通Java对象的包装类</span></span><br><span class="line">     <span class="keyword">this</span>.objectWrapper = <span class="keyword">new</span> BeanWrapper(<span class="keyword">this</span>, object);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>BeanWarpper的创建</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BeanWrapper</span><span class="params">(MetaObject metaObject, Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(metaObject);</span><br><span class="line">    <span class="keyword">this</span>.object = object;</span><br><span class="line">    <span class="keyword">this</span>.metaClass = MetaClass.forClass(object.getClass());</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MetaClass <span class="title">forClass</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MetaClass(type);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">MetaClass</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.reflector = Reflector.forClass(type);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>this.reflector = Reflector.forClass(type);</p>
<p>这里的reflector是MetaClass的一个属性对应的类是Reflector,是Mybatis处理反射最重要的类。</p>
<p>Reflector</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Reflector <span class="title">forClass</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (classCacheEnabled) &#123;</span><br><span class="line">      <span class="comment">// synchronized (clazz) removed see issue #461</span></span><br><span class="line">      Reflector cached = REFLECTOR_MAP.get(clazz);</span><br><span class="line">      <span class="keyword">if</span> (cached == <span class="keyword">null</span>) &#123;</span><br><span class="line">        cached = <span class="keyword">new</span> Reflector(clazz);</span><br><span class="line">        REFLECTOR_MAP.put(clazz, cached);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> cached;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Reflector(clazz);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="title">Reflector</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">    type = clazz;</span><br><span class="line">   <span class="comment">//添加默认的无参构造方法</span></span><br><span class="line">    addDefaultConstructor(clazz);</span><br><span class="line">   <span class="comment">//添加Get方法 </span></span><br><span class="line">   addGetMethods(clazz);</span><br><span class="line">   <span class="comment">//添加Set方法 </span></span><br><span class="line">   addSetMethods(clazz);</span><br><span class="line">   <span class="comment">//添加Field属性 </span></span><br><span class="line">   addFields(clazz);</span><br><span class="line">    readablePropertyNames = getMethods.keySet().toArray(<span class="keyword">new</span> String[getMethods.keySet().size()]);</span><br><span class="line">    writeablePropertyNames = setMethods.keySet().toArray(<span class="keyword">new</span> String[setMethods.keySet().size()]);</span><br><span class="line">   <span class="comment">//下面的两个put元素的操作是很重要的，我们看到他们把对应的PropertyName的大写作为Key,</span></span><br><span class="line">   <span class="comment">//把PropertyName作为Value存入这个HashMap中</span></span><br><span class="line">    <span class="keyword">for</span> (String propName : readablePropertyNames) &#123;</span><br><span class="line">      caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (String propName : writeablePropertyNames) &#123;</span><br><span class="line">      caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>applyAutomaticMappings</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">applyAutomaticMappings</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, MetaObject metaObject, String columnPrefix)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">//得到没有显式声明的ColumnName 的 List</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;String&gt; unmappedColumnNames = rsw.getUnmappedColumnNames(resultMap, columnPrefix);</span><br><span class="line">    <span class="keyword">boolean</span> foundValues = <span class="keyword">false</span>;</span><br><span class="line">  <span class="comment">//后续的赋值操作比较简单，就不详细分析了</span></span><br><span class="line">    <span class="keyword">for</span> (String columnName : unmappedColumnNames) &#123;</span><br><span class="line">      String propertyName = columnName;</span><br><span class="line">      <span class="keyword">if</span> (columnPrefix != <span class="keyword">null</span> &amp;&amp; columnPrefix.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// When columnPrefix is specified,</span></span><br><span class="line">        <span class="comment">// ignore columns without the prefix.</span></span><br><span class="line">        <span class="keyword">if</span> (columnName.toUpperCase(Locale.ENGLISH).startsWith(columnPrefix)) &#123;</span><br><span class="line">          propertyName = columnName.substring(columnPrefix.length());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//对这句代码还是有必要分析一下的，因为这里就是驼峰命名可以不显式声明ColumnName的原因所在</span></span><br><span class="line">      <span class="keyword">final</span> String property = metaObject.findProperty(propertyName, configuration.isMapUnderscoreToCamelCase());</span><br><span class="line">      <span class="keyword">if</span> (property != <span class="keyword">null</span> &amp;&amp; metaObject.hasSetter(property)) &#123;</span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt; propertyType = metaObject.getSetterType(property);</span><br><span class="line">        <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(propertyType)) &#123;</span><br><span class="line">          <span class="keyword">final</span> TypeHandler&lt;?&gt; typeHandler = rsw.getTypeHandler(propertyType, columnName);</span><br><span class="line">          <span class="keyword">final</span> Object value = typeHandler.getResult(rsw.getResultSet(), columnName);</span><br><span class="line">          <span class="keyword">if</span> (value != <span class="keyword">null</span> || configuration.isCallSettersOnNulls()) &#123; <span class="comment">// issue #377, call setter on nulls</span></span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span> || !propertyType.isPrimitive()) &#123;</span><br><span class="line">              metaObject.setValue(property, value);</span><br><span class="line">            &#125;</span><br><span class="line">            foundValues = <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> foundValues;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>getUnmappedColumnNames</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getUnmappedColumnNames</span><span class="params">(ResultMap resultMap, String columnPrefix)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">   List&lt;String&gt; unMappedColumnNames = unMappedColumnNamesMap.get(getMapKey(resultMap, columnPrefix));</span><br><span class="line">   <span class="keyword">if</span> (unMappedColumnNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">     loadMappedAndUnmappedColumnNames(resultMap, columnPrefix);</span><br><span class="line">     unMappedColumnNames = unMappedColumnNamesMap.get(getMapKey(resultMap, columnPrefix));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> unMappedColumnNames;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadMappedAndUnmappedColumnNames</span><span class="params">(ResultMap resultMap, String columnPrefix)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">   List&lt;String&gt; mappedColumnNames = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">   List&lt;String&gt; unmappedColumnNames = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">   <span class="keyword">final</span> String upperColumnPrefix = columnPrefix == <span class="keyword">null</span> ? <span class="keyword">null</span> : columnPrefix.toUpperCase(Locale.ENGLISH);</span><br><span class="line">   <span class="keyword">final</span> Set&lt;String&gt; mappedColumns = prependPrefixes(resultMap.getMappedColumns(), upperColumnPrefix);</span><br><span class="line">   <span class="keyword">for</span> (String columnName : columnNames) &#123;</span><br><span class="line">     <span class="keyword">final</span> String upperColumnName = columnName.toUpperCase(Locale.ENGLISH);</span><br><span class="line">     <span class="keyword">if</span> (mappedColumns.contains(upperColumnName)) &#123;</span><br><span class="line">       mappedColumnNames.add(upperColumnName);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       unmappedColumnNames.add(columnName);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   mappedColumnNamesMap.put(getMapKey(resultMap, columnPrefix), mappedColumnNames);</span><br><span class="line">   unMappedColumnNamesMap.put(getMapKey(resultMap, columnPrefix), unmappedColumnNames);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>loadMappedAndUnmappedColumnNames这个方法将没有显式的在ResultMap节点中的Result节点声明的property和显式声明的property分别存到unmappedColumnNames和unmappedColumnNames中。</p>
<p><strong>findProperty(propertyName, configuration.isMapUnderscoreToCamelCase())</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">final</span> String property = metaObject.findProperty(propertyName, configuration.isMapUnderscoreToCamelCase()); </span><br><span class="line"><span class="comment">//如果设置了数据库列名使用驼峰命名可以不用显式声明result，会把列名的下划线去掉，使其与JavaBean 属性名相同</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">findProperty</span><span class="params">(String name, <span class="keyword">boolean</span> useCamelCaseMapping)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (useCamelCaseMapping) &#123;</span><br><span class="line">      name = name.replace(<span class="string">"_"</span>, <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> findProperty(name);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>如果设置了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;setting name=<span class="string">"mapUnderscoreToCamelCase"</span> value=<span class="string">"true"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>上述的useCamelCaseMapping就是true了</p>
<p><strong>applyPropertyMappings</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">applyPropertyMappings</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, MetaObject metaObject, ResultLoaderMap lazyLoader, String columnPrefix)</span></span></span><br><span class="line"><span class="function">     <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> List&lt;String&gt; mappedColumnNames = rsw.getMappedColumnNames(resultMap, columnPrefix);</span><br><span class="line">   <span class="keyword">boolean</span> foundValues = <span class="keyword">false</span>;</span><br><span class="line">   <span class="keyword">final</span> List&lt;ResultMapping&gt; propertyMappings = resultMap.getPropertyResultMappings();</span><br><span class="line">   <span class="keyword">for</span> (ResultMapping propertyMapping : propertyMappings) &#123;</span><br><span class="line">     <span class="keyword">final</span> String column = prependPrefix(propertyMapping.getColumn(), columnPrefix);</span><br><span class="line">     <span class="keyword">if</span> (propertyMapping.isCompositeResult() </span><br><span class="line">         || (column != <span class="keyword">null</span> &amp;&amp; mappedColumnNames.contains(column.toUpperCase(Locale.ENGLISH))) </span><br><span class="line">         || propertyMapping.getResultSet() != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">//我们主要需要看的是这个方法的具体实现，其他的都比较好理解，</span></span><br><span class="line">       Object value = getPropertyMappingValue(rsw.getResultSet(), metaObject, propertyMapping, lazyLoader, columnPrefix);</span><br><span class="line">       <span class="keyword">final</span> String property = propertyMapping.getProperty(); <span class="comment">// issue #541 make property optional</span></span><br><span class="line">       <span class="keyword">if</span> (value != NO_VALUE &amp;&amp; property != <span class="keyword">null</span> &amp;&amp; (value != <span class="keyword">null</span> || configuration.isCallSettersOnNulls())) &#123; <span class="comment">// issue #377, call setter on nulls</span></span><br><span class="line">         <span class="keyword">if</span> (value != <span class="keyword">null</span> || !metaObject.getSetterType(property).isPrimitive()) &#123;</span><br><span class="line">           metaObject.setValue(property, value);</span><br><span class="line">         &#125;</span><br><span class="line">         foundValues = <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> foundValues;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>getPropertyMappingValue</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">getPropertyMappingValue</span><span class="params">(ResultSet rs, MetaObject metaResultObject, ResultMapping propertyMapping, ResultLoaderMap lazyLoader, String columnPrefix)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">//如果result节点中select属性存在</span></span><br><span class="line">  <span class="keyword">if</span> (propertyMapping.getNestedQueryId() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//在本次查询中是不会用到这个方法的，因为result节点中并没有</span></span><br><span class="line">    <span class="keyword">return</span> getNestedQueryMappingValue(rs, metaResultObject, propertyMapping, lazyLoader, columnPrefix);</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">//这一分支应该是这个select属性对应的查询结果ResultMap中的result节点依然有select属性，当然目前还没有验证</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (propertyMapping.getResultSet() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    addPendingChildRelation(rs, metaResultObject, propertyMapping);</span><br><span class="line">    <span class="keyword">return</span> NO_VALUE;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propertyMapping.getNestedResultMapId() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// the user added a column attribute to a nested result map, ignore it</span></span><br><span class="line">    <span class="keyword">return</span> NO_VALUE;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> TypeHandler&lt;?&gt; typeHandler = propertyMapping.getTypeHandler();</span><br><span class="line">    <span class="keyword">final</span> String column = prependPrefix(propertyMapping.getColumn(), columnPrefix);</span><br><span class="line">    <span class="keyword">return</span> typeHandler.getResult(rs, column);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们的ResultMap是这样的</p>
<p>。。。待补充</p>
<p>那么就会用到这个方法</p>
<p><strong>getNestedQueryMappingValue</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">getNestedQueryMappingValue</span><span class="params">(ResultSet rs, MetaObject metaResultObject, ResultMapping propertyMapping, ResultLoaderMap lazyLoader, String columnPrefix)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String nestedQueryId = propertyMapping.getNestedQueryId();</span><br><span class="line">    <span class="keyword">final</span> String property = propertyMapping.getProperty();</span><br><span class="line">    <span class="keyword">final</span> MappedStatement nestedQuery = configuration.getMappedStatement(nestedQueryId);</span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; nestedQueryParameterType = nestedQuery.getParameterMap().getType();</span><br><span class="line">  <span class="comment">//得到该result节点对应column的值，这个值将作为select对应的select Mapper的参数传入  </span></span><br><span class="line">  <span class="keyword">final</span> Object nestedQueryParameterObject = prepareParameterForNestedQuery(rs, propertyMapping, nestedQueryParameterType, columnPrefix);</span><br><span class="line">    Object value = NO_VALUE;</span><br><span class="line">    <span class="keyword">if</span> (nestedQueryParameterObject != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">final</span> BoundSql nestedBoundSql = nestedQuery.getBoundSql(nestedQueryParameterObject);</span><br><span class="line">      <span class="keyword">final</span> CacheKey key = executor.createCacheKey(nestedQuery, nestedQueryParameterObject, RowBounds.DEFAULT, nestedBoundSql);</span><br><span class="line">      <span class="comment">//ofType  如果没有指定ofType,应该会取selct Mapper中对应的ResultMap Type把，这个做实验就知道会不会这样取了</span></span><br><span class="line">      <span class="keyword">final</span> Class&lt;?&gt; targetType = propertyMapping.getJavaType();</span><br><span class="line">      <span class="keyword">if</span> (executor.isCached(nestedQuery, key)) &#123;</span><br><span class="line">        executor.deferLoad(nestedQuery, metaResultObject, property, key, targetType);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> ResultLoader resultLoader = <span class="keyword">new</span> ResultLoader(configuration, executor, nestedQuery, nestedQueryParameterObject, targetType, key, nestedBoundSql);</span><br><span class="line">        <span class="comment">//如果是懒加载，不要立即查出结果，先缓存</span></span><br><span class="line">        <span class="keyword">if</span> (propertyMapping.isLazy()) &#123;</span><br><span class="line">          lazyLoader.addLoader(property, metaResultObject, resultLoader);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//执行查询，得到结果</span></span><br><span class="line">          value = resultLoader.loadResult();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>loadResult</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">loadResult</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">//selectList并不难理解</span></span><br><span class="line">   List&lt;Object&gt; list = selectList();</span><br><span class="line">  <span class="comment">//extractObjectFromList就是转化下返回的类型</span></span><br><span class="line">   resultObject = resultExtractor.extractObjectFromList(list, targetType);</span><br><span class="line">   <span class="keyword">return</span> resultObject;</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="keyword">private</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">   Executor localExecutor = executor;</span><br><span class="line">   <span class="keyword">if</span> (Thread.currentThread().getId() != <span class="keyword">this</span>.creatorThreadId || localExecutor.isClosed()) &#123;</span><br><span class="line">     localExecutor = newExecutor();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> localExecutor.&lt;E&gt; query(mappedStatement, parameterObject, RowBounds.DEFAULT, Executor.NO_RESULT_HANDLER, cacheKey, boundSql);</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (localExecutor != executor) &#123;</span><br><span class="line">       localExecutor.close(<span class="keyword">false</span>);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>extractObjectFromList</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">extractObjectFromList</span><span class="params">(List&lt;Object&gt; list, Class&lt;?&gt; targetType)</span> </span>&#123;</span><br><span class="line">    Object value = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (targetType != <span class="keyword">null</span> &amp;&amp; targetType.isAssignableFrom(list.getClass())) &#123;</span><br><span class="line">      value = list;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetType != <span class="keyword">null</span> &amp;&amp; objectFactory.isCollection(targetType)) &#123;</span><br><span class="line">      value = objectFactory.create(targetType);</span><br><span class="line">      MetaObject metaObject = configuration.newMetaObject(value);</span><br><span class="line">      metaObject.addAll(list);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetType != <span class="keyword">null</span> &amp;&amp; targetType.isArray()) &#123;</span><br><span class="line">      Class&lt;?&gt; arrayComponentType = targetType.getComponentType();</span><br><span class="line">      Object array = Array.newInstance(arrayComponentType, list.size());</span><br><span class="line">      <span class="keyword">if</span> (arrayComponentType.isPrimitive()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">          Array.set(array, i, list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        value = array;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        value = list.toArray((Object[])array);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Statement returned more than one row, where no more than one was expected."</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.size() == <span class="number">1</span>) &#123;</span><br><span class="line">        value = list.get(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>到这里对ResultSetHandler的讲解就稍微告一段落了</p>
<p>目前还有MapKey(差实验)，鉴别器（），缓存，懒加载还没有讲到。</p>
<p>ResultSetHandler是Mybatis最复杂的一部分，它对应着ResultMap的处理，而ResultMap的配置也是配置文件中最难的。</p>
<p>在这里再说下我之前的一个疑问，也是自己对泛型没有很好的理解到位。</p>
<p>当我第一次看到这段代码时</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    PreparedStatement ps = (PreparedStatement) statement;</span><br><span class="line">    ps.execute();</span><br><span class="line">    <span class="keyword">return</span> resultSetHandler.&lt;E&gt; handleResultSets(ps);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>我对这行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> resultSetHandler.&lt;E&gt; handleResultSets(ps);</span><br></pre></td></tr></table></figure>
<p>是蛮疑惑的，resultSetHandler.\<e> handleResultSets(ps);</e></p>
<p>这种在调用方法前使用泛型的，代表这个方法肯定是泛型方法，否则肯定是不能这样用的。</p>
<p>但是我们发现在DefaultResultSetHandler中这个方法的返回类型是List\<object>,并不是一个泛型方法呀？</object></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">handleResultSets</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>但是依然在返回给我们结果的时候进行了强制的类型转化，也就是实现了泛型方法的效果。</p>
<p>这是为什么呢？在一开始我是十分想不通的。</p>
<p>当然在ResultSetHandler接口中，这是一个泛型方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">handleResultSets</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException</span>;</span><br></pre></td></tr></table></figure>
<p>这说明实现了这个接口的方法，即使在实现类指定了某个具体的类型，还是具有泛型方法的特性的，还是会被当做泛型方法的。</p>
<p>至于为什么会这样，我的理解是，只要实现的方法是泛型方法，即使实现类里明确指定了特定的返回类型，依然会在编译时期，完成类型的强制转化，依然是具有泛型方法特性的。</p>
<p>最后，我们举个例子来验证一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wangcc.MyJavaSE.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResultSetHandler</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">handleResultSets</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultResultSetHandler</span> <span class="keyword">implements</span> <span class="title">ResultSetHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">handleResultSets</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">		list.add(<span class="string">"Kobe"</span>);</span><br><span class="line">		list.add(<span class="string">"james"</span>);</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		ResultSetHandler resultSetHandler = <span class="keyword">new</span> DefaultResultSetHandler();</span><br><span class="line">		List&lt;String&gt; list = resultSetHandler.&lt;String&gt;handleResultSets();</span><br><span class="line">		<span class="keyword">for</span> (String str : list) &#123;</span><br><span class="line">			System.out.println(str);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个测试类是可以正常运行的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2017/11/26/ResultSetHandler/" data-id="cjb52pqzh000lgkbz0bhp0hsp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/11/29/Memory Leak/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Memory
        
      </div>
    </a>
  
  
    <a href="/2017/11/26/ParameterHandler/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">ParameterHandler</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CAS/">CAS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java-WEB/">Java WEB</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaWEB/">JavaWEB</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java基础/">Java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mybatis/">Mybatis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringMVC/">SpringMVC</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js-css/">js&&css</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/02/06/Spring事务实现的四种方式/">Spring事务实现之编程式事务</a>
          </li>
        
          <li>
            <a href="/2018/02/06/Spring事务管理/">Spring事务管理</a>
          </li>
        
          <li>
            <a href="/2018/02/06/使用代理代理技术完成Spring事务管理/">Spring事务管理之AOP方法</a>
          </li>
        
          <li>
            <a href="/2018/02/05/CAS简单实例/">CAS简单实例</a>
          </li>
        
          <li>
            <a href="/2018/02/05/CAS/">CAS</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>