<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>HashMap | 迷途书童的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="JDK7之前用JDK7的源码分析过一次HashMap,但是分析的并不完善，只分析了put方法和get方法，有一个很重要的方法 resize()方法并没有分析。 扩容方法resize()方法是一个很重要的方法，当我们调用put方法的时候，如果Hash数组的实际大小已经大于加载因子*容量的时候，我们就需要进行扩容操作，防止">
<meta property="og:type" content="article">
<meta property="og:title" content="HashMap">
<meta property="og:url" content="https://cong96.github.io/2017/11/19/HashMap/index.html">
<meta property="og:site_name" content="迷途书童的博客">
<meta property="og:description" content="JDK7之前用JDK7的源码分析过一次HashMap,但是分析的并不完善，只分析了put方法和get方法，有一个很重要的方法 resize()方法并没有分析。 扩容方法resize()方法是一个很重要的方法，当我们调用put方法的时候，如果Hash数组的实际大小已经大于加载因子*容量的时候，我们就需要进行扩容操作，防止Hash冲突堆积太多，影响效率。  jdk version:jdk1.7.0.0">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2017-11-29T13:15:54.829Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HashMap">
<meta name="twitter:description" content="JDK7之前用JDK7的源码分析过一次HashMap,但是分析的并不完善，只分析了put方法和get方法，有一个很重要的方法 resize()方法并没有分析。 扩容方法resize()方法是一个很重要的方法，当我们调用put方法的时候，如果Hash数组的实际大小已经大于加载因子*容量的时候，我们就需要进行扩容操作，防止Hash冲突堆积太多，影响效率。  jdk version:jdk1.7.0.0">
  
    <link rel="alternate" href="/atom.xml" title="迷途书童的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">迷途书童的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">一天进步一点</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://cong96.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-HashMap" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/19/HashMap/" class="article-date">
  <time datetime="2017-11-19T10:15:42.019Z" itemprop="datePublished">2017-11-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java基础/">Java基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      HashMap
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="JDK7"><a href="#JDK7" class="headerlink" title="JDK7"></a>JDK7</h3><p>之前用JDK7的源码分析过一次HashMap,但是分析的并不完善，只分析了put方法和get方法，有一个很重要的方法 resize()方法并没有分析。</p>
<p>扩容方法resize()方法是一个很重要的方法，当我们调用put方法的时候，如果Hash数组的实际大小已经大于加载因子*容量的时候，我们就需要进行扩容操作，防止Hash冲突堆积太多，影响效率。 </p>
<p>jdk version:jdk1.7.0.0_76</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">           inflateTable(threshold);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">       <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">       <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">       <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">           Object k;</span><br><span class="line">           <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">               V oldValue = e.value;</span><br><span class="line">               e.value = value;</span><br><span class="line">               e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       modCount++;</span><br><span class="line">       addEntry(hash, key, value, i);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">    <span class="comment">//为什么不要移位操作&lt;&lt;</span></span><br><span class="line">    resize(<span class="number">2</span> * table.length);</span><br><span class="line">           hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">           bucketIndex = indexFor(hash, table.length);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       createEntry(hash, key, value, bucketIndex);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>我们看下这个方法的具体实现，然后看看在JDK8中是如何进行改进的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">       Entry[] oldTable = table;</span><br><span class="line">       <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="comment">//如果原来的容量已经是最大容量了,就只能任由他进行HASH碰撞</span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">           threshold = Integer.MAX_VALUE;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">       transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">       table = newTable;</span><br><span class="line">       threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line"><span class="comment">//对Hash数组进行遍历，所有元素遍历</span></span><br><span class="line">     <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">       <span class="comment">//对Hash数组每个元素后面带着的链表进行遍历，采用头插法将元素插入到新的Hash表中。    </span></span><br><span class="line">       <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">         <span class="comment">//先将e的下一个节点保存起来</span></span><br><span class="line">               Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">               <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                   e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">               &#125;</span><br><span class="line">         <span class="comment">//得到节点对应的hash数组的位置</span></span><br><span class="line">               <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">               <span class="comment">//开始头插</span></span><br><span class="line">         <span class="comment">//当前节点的next节点指向原头节点</span></span><br><span class="line">         </span><br><span class="line">         		e.next = newTable[i];</span><br><span class="line">         <span class="comment">//将当前节点置为头结点      </span></span><br><span class="line">         newTable[i] = e;</span><br><span class="line">         	<span class="comment">//将之前保存起来的next节点赋给e，开始下一个重复步骤进行头插</span></span><br><span class="line">               e = next;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>我们看到在JDK7中使用的resize()方法是对一个每个元素都进行重新找到在新的Hash数组的位置，采用的是头插法，也就是说将所有的元素都倒置了。</p>
<h3 id="JDK8"><a href="#JDK8" class="headerlink" title="JDK8"></a>JDK8</h3><p>HashMap和ConcurrentHashMap在JDK8中都进行了巨大的改变。</p>
<p>在HashMap中，为了增加插入删除等操作的效率，我们的HashMap在JDK8中的底层数据结构中增加了红黑树数据结构，当Hash数组的某个元素的链表长度大于8且数组大小大于。。。时，链表会变成红黑树，当链表长度大于8但长度没有超过。。。时会先执行扩容操作，而当扩容的时候，如果发现某个红黑树结构的元素个数小于6时，红黑树又会变成链表，这个具体实现，我们后面再说。</p>
<p>那么为什么我们要选用红黑树这种比较复杂的数据结构呢？</p>
<p>至于树形数据结构对于数组或者链表的优点，我们可以很简单的得出。</p>
<p>但是为什么是选择了红黑树而不是AVL（二叉平衡树）呢。这个就需要我们好好想想了。</p>
<p>红黑树的查询性能略逊色于AVL树，因为他比AVL树会稍微不平衡，也就是说红黑树的查询性能只比相同内容的avl树最多多一次比较，但是，红黑树在插入和删除上完爆avl树，avl树每次插入删除会进行大量的</p>
<p>平衡度计算，而红黑树为了维持红黑性质所做的红黑变换和旋转的开销，相较于avl树为了维持平衡的开销要小得多。</p>
<p>当然，红黑树并不适应所有应用树的领域。如果数据基本上是静态的，那么让他们待在他们能够插入，并且不影响平衡的地方会具有更好的性能。如果数据完全是静态的，例如，做一个哈希表，性能可能会更好一些。</p>
<p>在实际的系统中，例如，需要使用动态规则的防火墙系统，使用红黑树而不是散列表被实践证明具有更好的伸缩性。</p>
<p>简单说，如果你的应用中，搜索的次数远远大于插入和删除，那么选择AVL，如果搜索，插入删除次数几乎差不多，应该选择RB。</p>
<p><strong>红黑树是牺牲了严格的高度平衡的优越条件</strong>为 代价红黑树能够以O(log2 n)的时间复杂度进行搜索、插入、删除操作。此外，由于它的设计，任何不平衡都会在三次旋转之内解决。当然，还有一些更好的，但实现起来更复杂的数据结构 能够做到一步旋转之内达到平衡，但红黑树能够给我们一个比较“便宜”的解决方案。红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更高. </p>
<ul>
<li><p>Node内部类</p>
<p>我们先来看看HashMap的Hash数组的元素的数据结构是怎样的，在JDK7以及以前的版本中，都是使用的Entry作为元素，但是在JDK8中是使用Node,当然他肯定还是得实现Map.Entry\<k,v>这个接口</k,v></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h3><p>我们先关注put方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line">       <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">         <span class="comment">//先看table有没有初始化，没有的话初始化一个Hash数组</span></span><br><span class="line">       <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">           n = (tab = resize()).length;</span><br><span class="line">         <span class="comment">//如果数组元素没有被占用，则该节点赋给该数组元素，即为该数组元素后面的链表的头结点</span></span><br><span class="line">       <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">           tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           Node&lt;K,V&gt; e; K k;</span><br><span class="line">         <span class="comment">//如果链表头结点（Hash数组元素）的key与我们要插入的key相同，可以直接替换value</span></span><br><span class="line">           <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">               ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">               e = p;</span><br><span class="line">         <span class="comment">//如果不是头节点key相同，而且是红黑树类型节点,调用红黑树类型的插入方式</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">               e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">//如果不是直接替换头结点，那么开始进行咔咔的遍历</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                 <span class="comment">//当遍历完了之后还是没找着</span></span><br><span class="line">                   <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="comment">//新建一个node节点指向原最后一个节点的next节点</span></span><br><span class="line">                       p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                     <span class="comment">//如果遍历玩还没找到而且元素大于7了，厉害了，开始变身TreeNode，变成红黑树结构</span></span><br><span class="line">                       <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                           treeifyBin(tab, hash);</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                 <span class="comment">//如果遍历的过程中找到了key相同的，跳出循环</span></span><br><span class="line">                   <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                       ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   p = e;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">         <span class="comment">//然后在这里进行替换原值的操作</span></span><br><span class="line">           <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">               V oldValue = e.value;</span><br><span class="line">               <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                   e.value = value;</span><br><span class="line">               afterNodeAccess(e);</span><br><span class="line">      	<span class="comment">//当e!=null的时候直接返回了，之前我再这里纠结了一下为什么没有++modCount呀</span></span><br><span class="line">             <span class="comment">//fail-fast机制不要遵循了吗</span></span><br><span class="line">             <span class="comment">//仔细一看，扑街，只有当是替换Value的时候，而没有新增的Node节点的时候才会直接返回</span></span><br><span class="line">             <span class="comment">//当是处理TreeNode红黑树节点的时候，方法返回的是null，也就是e==null</span></span><br><span class="line">             <span class="comment">//当需要从链表转化为红黑树的时候，也是新增节点，e指向null的时候才执行。</span></span><br><span class="line">             <span class="comment">//也就是这个方法中所有返回e==null的分支对应的都是新增节点，会在下面的代码中执行++modCount;</span></span><br><span class="line">             <span class="comment">//所有不返回null的分支都对应着修改Value值。</span></span><br><span class="line">             <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        </span><br><span class="line">       ++modCount;</span><br><span class="line">       <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">           resize();</span><br><span class="line">       afterNodeInsertion(evict);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>具体代码就不再次分析了。</p>
<p>put方法的流程：</p>
<p>先确定Key位于哪个Hash桶，如果对应Hash数组中没有元素，直接将这个Node赋给Hash数组中该元素（table[i]=node）,如果找到了对应的Hash桶，如果对应的还是之前的链表结构，则遍历Node链表，如果发现Key已经存在，替换Value,返回，如果没找到，这个时候就需要新增节点了，直接用尾插法插到链表的尾部（这一点和JDK7以及之前插入方法不同，之前的插入方法是头插法）如果链表的长度已经不小于7了，链表的结构要变成红黑树的结构。如果这个hash桶的结构在插入新节点前已经变成了红黑树，则遍历TreeNode组成的红黑树结构，看是否Key已经存在，如果存在则替换，如果没有，则将新节点插入红黑树结构。这个流程我们能够狠轻松的整理出来，但是，如何用代码实现，如何用最少的代码实现，却并没有那么简单。如何用最少的代码，也就是如何找到规律，万物皆有形可测，编写程序就是要找到一些事情的规律，化繁为简。</p>
<ul>
<li>将链表结构改为红黑树结构</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">  <span class="comment">//如果还没有初始化表或者表的长度小于64，那么不急着将链表结构改为红黑树结构，先进行扩容操作。</span></span><br><span class="line">      <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">          resize();</span><br><span class="line">  <span class="comment">//开始转化，转化之前确认这个链表是有元素的</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">          TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//将Node节点转化为TreeNode节点</span></span><br><span class="line">              TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">              <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                  hd = p;</span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//prev是TreeNode的属性</span></span><br><span class="line">                  p.prev = tl;</span><br><span class="line">                <span class="comment">//注意next还是Node的属性</span></span><br><span class="line">                  tl.next = p;</span><br><span class="line">              &#125;</span><br><span class="line">              tl = p;</span><br><span class="line">          &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line"> <span class="comment">//让桶的第一个元素指向新建的红黑树头结点，以后这个桶里的元素就是红黑树而不是链表了</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">              hd.treeify(tab);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">          TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">              next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">              x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">              <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  x.parent = <span class="keyword">null</span>;</span><br><span class="line">                  x.red = <span class="keyword">false</span>;</span><br><span class="line">                  root = x;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                  K k = x.key;</span><br><span class="line">                  <span class="keyword">int</span> h = x.hash;</span><br><span class="line">                  Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">                  <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                      <span class="keyword">int</span> dir, ph;</span><br><span class="line">                      K pk = p.key;</span><br><span class="line">                      <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                          dir = -<span class="number">1</span>;</span><br><span class="line">                      <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                          dir = <span class="number">1</span>;</span><br><span class="line">                      <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                               (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                          dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">                      TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                      <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                          x.parent = xp;</span><br><span class="line">                          <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                              xp.left = x;</span><br><span class="line">                          <span class="keyword">else</span></span><br><span class="line">                              xp.right = x;</span><br><span class="line">                          root = balanceInsertion(root, x);</span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">  <span class="comment">//确保你返回的是root节点</span></span><br><span class="line">          moveRootToFront(tab, root);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>插入红黑树节点</p>
<p>putTreeVal是TreeNode的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">           Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">           TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">           <span class="comment">//这是一个无限循环，我们得看看他的退出条件</span></span><br><span class="line">           <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">             <span class="comment">//dir应该是左子树或右子树的一个判断</span></span><br><span class="line">               <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">             <span class="comment">//如果Node的hash值小于当前节点的值</span></span><br><span class="line">               <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                 <span class="comment">//右子树</span></span><br><span class="line">                   dir = -<span class="number">1</span>;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                 <span class="comment">//左子树</span></span><br><span class="line">                   dir = <span class="number">1</span>;</span><br><span class="line">             <span class="comment">//如果key相等hash值相等，即我们找到了这个节点返回</span></span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                   <span class="keyword">return</span> p;</span><br><span class="line">             <span class="comment">//</span></span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                         <span class="comment">// /**</span></span><br><span class="line">    * Returns x<span class="string">'s Class if it is of the form "class C implements</span></span><br><span class="line"><span class="string">    * Comparable&lt;C&gt;", else null.</span></span><br><span class="line"><span class="string">    */</span></span><br><span class="line"><span class="string">                         (kc = comparableClassFor(k)) == null) ||</span></span><br><span class="line"><span class="string">                        //</span></span><br><span class="line"><span class="string">   /**</span></span><br><span class="line"><span class="string">    * Returns k.compareTo(x) if x matches kc (k'</span>s screened comparable</span><br><span class="line">    * <span class="class"><span class="keyword">class</span>), <span class="title">else</span> 0.</span></span><br><span class="line"><span class="class">    */</span></span><br><span class="line"><span class="class">                        (<span class="title">dir</span> </span>= compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">                                 <span class="comment">//如果当前节点和要添加的节点哈希值相等，但是两个节点的键不是一个类，只好去挨个对比左右孩子 </span></span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                       TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                       searched = <span class="keyword">true</span>;</span><br><span class="line">                       <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                            (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                           ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                            (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                           <span class="keyword">return</span> q;</span><br><span class="line">                   &#125;</span><br><span class="line">                 <span class="comment">//                //哈希值相等，但键无法比较，只好通过特殊的方法给个结果</span></span><br><span class="line"><span class="comment">//这个方法用于 a 和 b 哈希值相同但是无法比较时，直接根据两个引用的地址进行比较</span></span><br><span class="line">   <span class="comment">//这里源码注释也说了，这个树里不要求完全有序，只要插入时使用相同的规则保持平衡即可</span></span><br><span class="line">                   dir = tieBreakOrder(k, pk);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">               <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">                   TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">                   <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                       xp.left = x;</span><br><span class="line">                   <span class="keyword">else</span></span><br><span class="line">                       xp.right = x;</span><br><span class="line">                   xp.next = x;</span><br><span class="line">                   x.parent = x.prev = xp;</span><br><span class="line">                   <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">                       ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">                   moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>红黑树的插入</p>
<p>首先，我们知道，当插入节点的父节点的是黑色时，不用执行任何操作。</p>
<p>所以，要调整的是当插入节点的父节点是红色时，而插入的节点是红色的时候，是不会改变 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点这一条的，主要要注意的就是红色节点的子节点一定是黑节点这一条。</p>
<p>关于它的特性，需要注意的是：</p>
<p>分析之前，我们要牢记一点，插入之前这棵树是从局部到整体都符合红黑树的定义的。</p>
<p>而且我们调整的思路，永远都是先让底层局部符合定义，再逐级往上调整。</p>
<p>再强调一次，下列穷举的情况都是建立在这棵树符合红黑树的定义的情况下。</p>
<ul>
<li><p>当父节点和叔叔节点都是红色</p>
<p>这个时候我们插入一个红色节点，很显然违反了红色节点的子节点是黑色节点这个规定。</p>
<p>这个我们就像某些时刻处理异常一样，先给他把问题抛给上层。将叔叔节点和父节点都变成黑色，祖父节点变成红色。这样做至少保证了从祖父节点开始是局部符合红黑树的定义的（除了根节点是黑色节点不能确定以外），刚开始，我以为这种情况就大功告成了，后来才发现要考虑一种情况，那就是我们能确定这种情况下祖父节点是黑色，那么这种情况下祖父的父节点是红色还是黑色，我们是无法知道的，倘若是红色，那么当祖父变成红色后，就违反了原则了。所以我们要将祖父节点看成是新的当前节点，继续进行调整（因为已经保证祖父节点以下的都满足了）</p>
</li>
<li><p>当父节点是红色 叔叔节点是黑色且插入节点是父节点的左节点</p>
<p>首先，我们说过插入一个新节点的操作是不会影响 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点这一条的，因为默认插入的是红色，但是会影响红色的子节点必须是黑色这一条。</p>
<p>在这种情况下，祖父是黑色，叔叔是黑色，父节点是红色，我们还是秉守我们的一大原则，把问题尽可能往上层抛，我们从祖父节点开始看，设从祖父节点到左边（父节点）某一个叶子节点的路径包含的黑节点为n（父节点以下的黑节点）+1（祖父节点本身），到右边（叔叔节点）某一个叶子节点的路径包含的黑色节点为n-1(叔叔节点以下的黑节点)+1（叔叔节点）+1（祖父节点本身），都为n+1个黑节点。我们将父节点设为黑色，祖父节点设为红色，就解决了红色的子节点是黑色这一条不遵守的问题，但是这样做会带来新的问题， 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点这一条不符合了。相当于祖父节点到父节点这一分支（n+1）多了一个黑节点而到叔叔那一分支(n 少了原祖父节点这一黑节点)少了一个黑节点，这显然违反了我们的原则，那怎么样去调整呢，这个时候我们以父节点为中心开始右旋。使父节点变成祖父节点，那么现在从祖父节点到左边（原父节点）这一分支还是n+1,右边，由于新的祖父节点是祖父节点是黑色节点，所以黑节点+1为n+1,所以从祖父节点开始，都符合红黑树，此时，祖父节点又成为了黑节点，无需再进行改动。</p>
</li>
<li><p>当父节点是红色 叔叔节点是黑色且插入节点是父节点的右节点</p>
<p>很明显当情况为第二种情况的时候，已经调整好了，所以我们只需要将这种情况调整为第二种情况即可。如何做到第二种情况，以父节点为中心，进行左旋操作即可。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//先将插入的节点设为红色，为什么设为红色，设为红色不会违背，每个节点都其子孙节点的路径经过的黑色节点都一样多这条原则，我们调整红黑树的原则是让他尽可能的少违背红黑树的五大原则，然后就是尽可能的先做到局部符合原则。但是设为红色可能会违反红色节点的子节点一定是黑色这条原则，那么我们就来穷举下违背原则时可能出现的所有情况，有时候你别看着穷举好像很笨的样子，但是有时候大道至简才是真理，最直观的去分析可能会更快的得出结论。</span></span><br><span class="line"> 暴力穷举 </span><br><span class="line"> <span class="number">1</span>.父节点是红色节点，叔叔节点是红色节点</span><br><span class="line">   将父节点和叔叔节点都涂黑，将祖父节点涂红，此时，从祖父节点开始局部符合原则，然后把问题往上抛，将祖父节点设为当前节点。</span><br><span class="line"> <span class="number">2</span>.父节点是红色节点，叔叔节点是黑色节点</span><br><span class="line">    I.父节点是红色节点，叔叔节点是黑色节点，且当前节点是父节点的左子节点</span><br><span class="line">   	很显然，违反的是红色节点的子节点是黑色节点这一条，那么我们就把父节点涂黑，祖父节点（黑色）涂红，然后以祖父节点右旋一波，perfect，强行稳住了。符合原则。</span><br><span class="line">    II.父节点是红色节点，叔叔节点是黑色节点，且当前节点是父节点的右子节点</span><br><span class="line">    x.red = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">      <span class="comment">//如果是根节点，不多逼逼，直接将其涂黑，搞定</span></span><br><span class="line">        <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//如果父节点不是红色或者祖父节点是空的，即父节点是根节点，这里根节点必须是黑节点呀，为什么还要加一个祖父节点为空的判断呀</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">      <span class="comment">//如果父节点是祖父节点的左节点</span></span><br><span class="line">        <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">          <span class="comment">//如果叔叔节点是红色</span></span><br><span class="line">            <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123;</span><br><span class="line">              <span class="comment">//      将父节点和叔叔节点都涂黑，将祖父节点涂红，此时，从祖父节点开始局部符合原则，然后把问题往上抛，将祖父节点设为当前节点。</span></span><br><span class="line">              xppr.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//叔叔节点是黑色</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//如果当前节点是父节店的右子节点，情况2的I</span></span><br><span class="line">                <span class="keyword">if</span> (x == xp.right) &#123;</span><br><span class="line">                  <span class="comment">//以父节点为中心强行来一波左旋操作，使得父节点变为当前节点的左子节点，然后将父节点置为当前节点</span></span><br><span class="line">                  <span class="comment">//也就是变为当前节点是父节点左子节点的情况</span></span><br><span class="line">                    root = rotateLeft(root, x = xp);</span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">//现在就是到了情况2的II了</span></span><br><span class="line">              <span class="comment">//如果父节点不为空</span></span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="comment">//父节点置为黑色</span></span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                      <span class="comment">//祖父节点置为红色</span></span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                      <span class="comment">//右旋</span></span><br><span class="line">                        root = rotateRight(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (xppl != <span class="keyword">null</span> &amp;&amp; xppl.red) &#123;</span><br><span class="line">                xppl.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == xp.left) &#123;</span><br><span class="line">                    root = rotateRight(root, x = xp);</span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateLeft(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个左旋的代码，看着其实很烦呀，虽然一眼看过去很简洁，但是太多骚操作了，在之前代码简洁之道的学习中，我们多次强调过千万不要在平时编程中写只有自己看的懂代码，千万不要喜欢用三元表达式，最好做到一句话只做一件事，写代码，让机器看得懂是最简单的事，如何让人看懂才是问题的关键所在。当然编写JDK源码的人都是大神，追求简单高效无可厚非，我们这些平凡人还是不要秀骚操作比较好。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateLeft</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class="line">	<span class="comment">//左旋操作，实际就是更改下节点的互相指向</span></span><br><span class="line">	<span class="comment">//左旋操作前提，首先右子节点要存在     当前节点指p.right</span></span><br><span class="line"><span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (r = p.right) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//这句代码其实做了两件事（具体的分还不止）,首先进行链式赋值，然后判断值是否为null</span></span><br><span class="line">  <span class="comment">//如果当前节点有左孩子的话，将当前节点的左节点赋给父节点的右孩子</span></span><br><span class="line">                <span class="keyword">if</span> ((rl = p.right = r.left) != <span class="keyword">null</span>)</span><br><span class="line">                  <span class="comment">//然后让当前节点的左节点的父节点设为父节点</span></span><br><span class="line">                    rl.parent = p;</span><br><span class="line">  <span class="comment">//赋值操作：得到祖父节点，并将祖父节点置为当前节点的父节点</span></span><br><span class="line">  <span class="comment">//判断操作，判断父节点是不是根节点，如果是根节点，那么当前节点就会被置为根节点，根节点默认为black</span></span><br><span class="line">                <span class="keyword">if</span> ((pp = r.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">                    (root = r).red = <span class="keyword">false</span>;</span><br><span class="line">  <span class="comment">//新的关系连接起来，很好看懂</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p)</span><br><span class="line">                    pp.left = r;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pp.right = r;</span><br><span class="line">                r.left = p;</span><br><span class="line">                p.parent = r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="REMOVE"><a href="#REMOVE" class="headerlink" title="REMOVE"></a>REMOVE</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public V remove(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    return (e = removeNode(hash(key), key, null, false, true)) == null ?</span><br><span class="line">        null : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">          (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">          Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">  	<span class="comment">//如果是头结点（）</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">              ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">              node = p;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                  node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="keyword">do</span> &#123;</span><br><span class="line">                      <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                          ((k = e.key) == key ||</span><br><span class="line">                           (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                          node = e;</span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">                      p = e;</span><br><span class="line">                  &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                               (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">              <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                  ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                  tab[index] = node.next;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                  p.next = node.next;</span><br><span class="line">              ++modCount;</span><br><span class="line">              --size;</span><br><span class="line">              afterNodeRemoval(node);</span><br><span class="line">              <span class="keyword">return</span> node;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>红黑树的删除</p>
<p> 删除操作应该是红黑树中最难的操作了，说实话，我看了四五遍了，都不是很明白。</p>
<p>首先删除节点就分三种情况，</p>
<ul>
<li><p>无子节点，最简单，直接删除，不多逼逼</p>
<p>如果删除的节点是红色的节点，不用处理，如果是黑色节点就需要调整红黑树的结构。</p>
</li>
<li><p>一个子节点，不多逼逼，直接替代删除节点</p>
<p>如果删除的节点是红色的节点，依旧是不需要处理，但是如果删除的是黑色节点，需要调整红黑树的结构</p>
</li>
<li><p>两个子节点，瞬间爆炸，愣是好几次都没搞透彻。在学习二叉树的删除的时候，对这种情况已经说过了，要灵活思考，找到删除节点的后续节点，然后将后续节点替代删除节点，然后来删除后续节点。</p>
<p>中序后续节点是二叉树中Key大于删除节点的最小值，也就是删除节点的右子树的左子树中最左边的节点。该节点不可能存在左节点，只可能有右节点。后继节点只可能有右节点或者没有子节点，也就对应着前面说的头两种情况了，只不过当前节点从要删除的节点变成了后继节点。</p>
<p>​         当后继节点含有右节点时，</p>
<p>​    删除后续节点，将后续节点的右节点称为后续节点的父节点的左节点。</p>
<p>​    我们就来通过后继节点的子节点和父节点来分析，称后继节点的子节点为当前节点。</p>
<ul>
<li><p>如果当前节点是红色的，说明刚刚移走的后继节点是黑色的，那么不管后继节点的父节点是啥颜色，我们只要将当前节点涂黑就可以了，红-黑树的平衡性就可以恢复。</p>
</li>
<li><p>所以注意分析的情况就是当前节点是黑色的情况</p>
<ul>
<li><p>这种情况是可以直接解决红黑树调整的情况。在这种情况下，我们把兄弟节点的颜色和父节点颜色调换一下（这样一来就给当前节点那一分支添加了一个黑色节点，然后兄弟节点这一分支也并没有少黑色节点，但是还有可能出现的情况需要再考虑：原来的父节点是红色节点，那么就会造成现在的兄弟节点和兄弟节点的右节点都是红色节点，就很尴尬，会造成红色节点的子节点还是红节点的情况，那么这时我们就需要做出改变了</p>
<p>），所以我们还需要将现在的兄弟节点的右节点变为黑色，但是这样又使得兄弟节点这一分支的黑色节点多了一个，这个时候咋办呢，围绕当前的父节点来一波左旋操作，便解决了多一个黑节点的问题，同时最重要的是兄弟节点（颜色是原来的父节点的颜色，这很重要）成为了父节点，目前，父节点及其以下分支已经完成了红黑树调整，又有新的父节点的颜色和原有的父节点相同，这就是说已经完成了所有的调整操作了。</p>
<p>​</p>
</li>
<li><p>当前节点是黑色的，且兄弟节点是黑色的，且兄弟节点的两个子节点均为黑色的；</p>
<p>把兄弟节点涂成红色，这样在父节点及以下分支实现了符合红黑树，但是整体来说就使得父节点之一分支相对于其他分支少了个黑色节点，也就是说，我们这样左就把调整红黑树的任务推给了上一层节点，把问题不停的往上抛，直到根节点，也就自然的解决了问题，把问题逐层往上抛在插入的时候已经强调过实用性和重要性了，然后我们就可以把父节点设为当前节点继续调整了。</p>
</li>
<li><p>当前节点是黑色的，且兄弟节点是黑色的，且兄弟节点的左子节点是红色，右子节点时黑色的；</p>
<p>这个你做一个旋转操作，自然就变成了第一种情况啦，将兄弟节点的左子节点变为黑色，兄弟节点变为红色，以兄弟节点为中心，来一波右旋操作，就成了第一种情况啦。</p>
</li>
<li><p>当前节点是黑色的，且兄弟节点是红色的（那么父节点和兄弟节点的子节点肯定是黑色的）；</p>
<p>很显然，这种情况只要先把他转化为当前节点和兄弟节点都是黑色的情况就好啦。</p>
<p>怎么做呢，这里相关的节点都是能确定颜色的，要完成这个操作还是比较简单的。</p>
<p>先将兄弟节点和父节点的颜色调换，然后以父节点为中心左旋即可。</p>
</li>
</ul>
</li>
</ul>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>我们注意到我们分析两个子节点时，当后续节点有子节点时，我们给出了具体调整红黑树的方案</p>
<p>那我们有没有办法在其他情况下也用到这种解决方案呢，如果能用到那我们就解决了红黑树删除节点的问题了。</p>
<p>那我们再回头来分析下我们在后续节点有子节点是怎么解决的。</p>
<p>我们是将右子节点补上后继的位置，我们称这个右子节点为替代节点replacement节点，成为后继节点父节点的子节点，然后用replacement和其父节点和其兄弟节点的各种情况来分析得到解决方案。</p>
<p>那么对于其他情况下，我们能不能尝试得到replacement来构造这种解决方案呢。</p>
<p>1、我们来看之前说的当前节点只有一个子节点的情况，我们说过这种情况是将子节点代替删除节点，当删除节点为黑色节点的时候是需要看是否需要调整红黑树的。那么这种情况我们可以很容易的得到这里可以将子节点设为replacement</p>
<p>2、删除节点没有子节点</p>
<p>这种情况下当删除节点是黑色的时候是一定会出现违反红黑树定义的情况的，但是这个时候没有子节点呀，咋办呀，上哪找replacement呀，这个时候我们就把当前要删除的节点当做是replacement，就当此时这个分支当前是少一个黑节点的（为什么呢，因为这个replacement节点终于要删除的），然后使用replacement调整红黑树、</p>
<p>3.后继节点是没有子节点的</p>
<p>那这种情况那和2一样，也是抓当前要删除的节点当做replacement的，最后把这个给删了。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeTreeNode</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        <span class="comment">//为什么JDK源码要整这么多骚操作呀，这个局部变量的命名我真的了</span></span><br><span class="line">            TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl;</span><br><span class="line">            TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev;</span><br><span class="line">        <span class="comment">//去掉要删除的节点</span></span><br><span class="line">            <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">                tab[index] = first = succ;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pred.next = succ;</span><br><span class="line">            <span class="keyword">if</span> (succ != <span class="keyword">null</span>)</span><br><span class="line">                succ.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (root.parent != <span class="keyword">null</span>)</span><br><span class="line">                root = root.root();</span><br><span class="line">            <span class="keyword">if</span> (root == <span class="keyword">null</span> || root.right == <span class="keyword">null</span> ||</span><br><span class="line">                (rl = root.left) == <span class="keyword">null</span> || rl.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                tab[index] = first.untreeify(map);  <span class="comment">// too small</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>, pl = left, pr = right, replacement;</span><br><span class="line">            <span class="keyword">if</span> (pl != <span class="keyword">null</span> &amp;&amp; pr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; s = pr, sl;</span><br><span class="line">              <span class="comment">//找到后继节点</span></span><br><span class="line">                <span class="keyword">while</span> ((sl = s.left) != <span class="keyword">null</span>) <span class="comment">// find successor</span></span><br><span class="line">                    s = sl;</span><br><span class="line">              <span class="comment">//交换颜色</span></span><br><span class="line">                <span class="keyword">boolean</span> c = s.red; s.red = p.red; p.red = c; <span class="comment">// swap colors</span></span><br><span class="line">                TreeNode&lt;K,V&gt; sr = s.right;</span><br><span class="line">                TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">              <span class="comment">//如果后继节点就是当前节点的右子节点，即右子节点没有左子树</span></span><br><span class="line">                <span class="keyword">if</span> (s == pr) &#123; <span class="comment">// p was s's direct parent</span></span><br><span class="line">                  <span class="comment">//两个交换一下</span></span><br><span class="line">                    p.parent = s;</span><br><span class="line">                    s.right = p;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">//后继节点的父节点</span></span><br><span class="line">                    TreeNode&lt;K,V&gt; sp = s.parent;</span><br><span class="line">                  <span class="comment">//后继节点的父节点成为当前接的父节点</span></span><br><span class="line">                  <span class="comment">//用当前节点代替后继节点</span></span><br><span class="line">                    <span class="keyword">if</span> ((p.parent = sp) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                      <span class="comment">//如果后继节点是其父节点的左节点，则当前节点设为其父节点的左节点</span></span><br><span class="line">                        <span class="keyword">if</span> (s == sp.left)</span><br><span class="line">                            sp.left = p;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            sp.right = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="comment">//将后继节点代替当前节点的位置</span></span><br><span class="line">                    <span class="keyword">if</span> ((s.right = pr) != <span class="keyword">null</span>)</span><br><span class="line">                        pr.parent = s;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">//相当于将当前节点和后继节点互相换位置，包括颜色</span></span><br><span class="line">             <span class="comment">//因为当前节点要代替当前节点，当然p.left==null；</span></span><br><span class="line">                p.left = <span class="keyword">null</span>;</span><br><span class="line">              <span class="comment">//继续完成当前节点代替后继节点的操作</span></span><br><span class="line">                <span class="keyword">if</span> ((p.right = sr) != <span class="keyword">null</span>)</span><br><span class="line">                    sr.parent = p;</span><br><span class="line">              <span class="comment">//将后继节点代替当前节点的位置</span></span><br><span class="line">                <span class="keyword">if</span> ((s.left = pl) != <span class="keyword">null</span>)</span><br><span class="line">                    pl.parent = s;</span><br><span class="line">              <span class="comment">//如果当前节点是根节点，直接替代根节点</span></span><br><span class="line">                <span class="keyword">if</span> ((s.parent = pp) == <span class="keyword">null</span>)</span><br><span class="line">                    root = s;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                    pp.left = s;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pp.right = s;</span><br><span class="line">              <span class="comment">//前面就是完成后继节点和当前节点位置互换的操作。不难理解，但是目前没理解的是，为什么要用当前节点来替代后继节点的位置，这个位置不是要删除掉的吗</span></span><br><span class="line">              <span class="comment">//接下来的操作就需要思考了</span></span><br><span class="line">              <span class="comment">//如果后继节点的右子树存在</span></span><br><span class="line">                <span class="keyword">if</span> (sr != <span class="keyword">null</span>)</span><br><span class="line">                    replacement = sr;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    replacement = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pl != <span class="keyword">null</span>)</span><br><span class="line">                replacement = pl;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pr != <span class="keyword">null</span>)</span><br><span class="line">                replacement = pr;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                replacement = p;</span><br><span class="line">        <span class="comment">//当前节点有两个孩子</span></span><br><span class="line">        <span class="comment">//如果后继节点没有孩子节点，则replacement=p;</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">//如果有右孩子节点repalcement都不会为当前节点p而是后继节点的右孩子</span></span><br><span class="line">               <span class="comment">//如果当前节点没有孩子节点，repalcement=p;</span></span><br><span class="line">        <span class="comment">//如果有一个节点的情况 replacement=相应的孩子节点</span></span><br><span class="line">            <span class="keyword">if</span> (replacement != p) &#123;</span><br><span class="line">              <span class="comment">//虽然到这里我终于看懂了，但是为什么我觉得这个操作非常非常的多余呀</span></span><br><span class="line">                TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;</span><br><span class="line">                <span class="keyword">if</span> (pp == <span class="keyword">null</span>)</span><br><span class="line">                    root = replacement;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                    pp.left = replacement;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pp.right = replacement;</span><br><span class="line">                p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">	<span class="comment">//因为后继节点和当前节点的颜色互换了。p.red就代表后继节点的颜色，很明显，当要真正删除的后继节点是红色的时候，不会对红黑树有任何影响，不需要做任何改动，而当后继节点的颜色是黑色时，就有可能影响节点到子孙的路径中黑色节点的个数相同这一条，就需要调整红黑树</span></span><br><span class="line">        </span><br><span class="line">            TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);</span><br><span class="line"><span class="comment">//如果后继节点没有子节点或者删除节点本身就没有子节点，我们只能拿要删除的节点先去顶上，然后执行完</span></span><br><span class="line">       <span class="comment">// balanceDeletion操作之后再去删除</span></span><br><span class="line">            <span class="keyword">if</span> (replacement == p) &#123;  <span class="comment">// detach</span></span><br><span class="line">                TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">                p.parent = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (pp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                        pp.left = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.right)</span><br><span class="line">                        pp.right = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (movable)</span><br><span class="line">                moveRootToFront(tab, r);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceDeletion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpl, xpr;;)  &#123;</span><br><span class="line">            <span class="comment">//如果当前节点就是root节点，直接返回</span></span><br><span class="line">              <span class="keyword">if</span> (x == <span class="keyword">null</span> || x == root)</span><br><span class="line">                  <span class="keyword">return</span> root;</span><br><span class="line">            <span class="comment">//如果删除的就是root节点，当前节点就顶上去成为root节点，这个时候要记得颜色要置为black</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//置为  </span></span><br><span class="line">                x.red = <span class="keyword">false</span>;</span><br><span class="line">                  <span class="keyword">return</span> x;</span><br><span class="line">              &#125;</span><br><span class="line">   	<span class="comment">//如果当前节点是红色，将当前节点改为黑色就行了，因为如果当前节点是红色，我们只要把节点改为黑色既可以弥补去掉后继节点所失去的一个黑色节点。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (x.red) &#123;</span><br><span class="line">			                </span><br><span class="line">                  x.red = <span class="keyword">false</span>;</span><br><span class="line">                  <span class="keyword">return</span> root;</span><br><span class="line">              &#125;</span><br><span class="line">            <span class="comment">//两种情况，当前节点是左孩子，或当前节点是右孩子，我们只需对其中一种情况分析即可，因为这两种情况是对称的。</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> ((xpl = xp.left) == x) &#123;</span><br><span class="line">                <span class="comment">//当前节点是黑色的，，则他的兄弟节点要么是黑色要么是红色</span></span><br><span class="line">                <span class="comment">//如果是红色，那兄弟节点的孩子节点是黑色，父节点肯定是黑色。</span></span><br><span class="line">                <span class="comment">//也就是说，红色节点这种情况是唯一确定的，而兄弟节点是黑色的情况会有好几种情况</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                所以，我们就先将</span></span><br><span class="line"><span class="comment">                1.兄弟节点是红色，这种情况转化为当前节点和兄弟节点都是黑色的情况。</span></span><br><span class="line"><span class="comment">                </span></span><br><span class="line"><span class="comment">                </span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                  <span class="keyword">if</span> ((xpr = xp.right) != <span class="keyword">null</span> &amp;&amp; xpr.red) &#123;</span><br><span class="line">                      xpr.red = <span class="keyword">false</span>;</span><br><span class="line">                      xp.red = <span class="keyword">true</span>;</span><br><span class="line">                      root = rotateLeft(root, xp);</span><br><span class="line">                      xpr = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.right;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span> (xpr == <span class="keyword">null</span>)</span><br><span class="line">                      x = xp;</span><br><span class="line">                  <span class="keyword">else</span> &#123;</span><br><span class="line">                      TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right;</span><br><span class="line">                      <span class="keyword">if</span> ((sr == <span class="keyword">null</span> || !sr.red) &amp;&amp;</span><br><span class="line">                          (sl == <span class="keyword">null</span> || !sl.red)) &#123;</span><br><span class="line">                          xpr.red = <span class="keyword">true</span>;</span><br><span class="line">                          x = xp;</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="keyword">else</span> &#123;</span><br><span class="line">                          <span class="keyword">if</span> (sr == <span class="keyword">null</span> || !sr.red) &#123;</span><br><span class="line">                              <span class="keyword">if</span> (sl != <span class="keyword">null</span>)</span><br><span class="line">                                  sl.red = <span class="keyword">false</span>;</span><br><span class="line">                              xpr.red = <span class="keyword">true</span>;</span><br><span class="line">                              root = rotateRight(root, xpr);</span><br><span class="line">                              xpr = (xp = x.parent) == <span class="keyword">null</span> ?</span><br><span class="line">                                  <span class="keyword">null</span> : xp.right;</span><br><span class="line">                          &#125;</span><br><span class="line">                          <span class="keyword">if</span> (xpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                              xpr.red = (xp == <span class="keyword">null</span>) ? <span class="keyword">false</span> : xp.red;</span><br><span class="line">                              <span class="keyword">if</span> ((sr = xpr.right) != <span class="keyword">null</span>)</span><br><span class="line">                                  sr.red = <span class="keyword">false</span>;</span><br><span class="line">                          &#125;</span><br><span class="line">                          <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                              xp.red = <span class="keyword">false</span>;</span><br><span class="line">                              root = rotateLeft(root, xp);</span><br><span class="line">                          &#125;</span><br><span class="line">                          x = root;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span> &#123; <span class="comment">// symmetric</span></span><br><span class="line">                  <span class="keyword">if</span> (xpl != <span class="keyword">null</span> &amp;&amp; xpl.red) &#123;</span><br><span class="line">                      xpl.red = <span class="keyword">false</span>;</span><br><span class="line">                      xp.red = <span class="keyword">true</span>;</span><br><span class="line">                      root = rotateRight(root, xp);</span><br><span class="line">                      xpl = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.left;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span> (xpl == <span class="keyword">null</span>)</span><br><span class="line">                      x = xp;</span><br><span class="line">                  <span class="keyword">else</span> &#123;</span><br><span class="line">                      TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right;</span><br><span class="line">                      <span class="keyword">if</span> ((sl == <span class="keyword">null</span> || !sl.red) &amp;&amp;</span><br><span class="line">                          (sr == <span class="keyword">null</span> || !sr.red)) &#123;</span><br><span class="line">                          xpl.red = <span class="keyword">true</span>;</span><br><span class="line">                          x = xp;</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="keyword">else</span> &#123;</span><br><span class="line">                          <span class="keyword">if</span> (sl == <span class="keyword">null</span> || !sl.red) &#123;</span><br><span class="line">                              <span class="keyword">if</span> (sr != <span class="keyword">null</span>)</span><br><span class="line">                                  sr.red = <span class="keyword">false</span>;</span><br><span class="line">                              xpl.red = <span class="keyword">true</span>;</span><br><span class="line">                              root = rotateLeft(root, xpl);</span><br><span class="line">                              xpl = (xp = x.parent) == <span class="keyword">null</span> ?</span><br><span class="line">                                  <span class="keyword">null</span> : xp.left;</span><br><span class="line">                          &#125;</span><br><span class="line">                          <span class="keyword">if</span> (xpl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                              xpl.red = (xp == <span class="keyword">null</span>) ? <span class="keyword">false</span> : xp.red;</span><br><span class="line">                              <span class="keyword">if</span> ((sl = xpl.left) != <span class="keyword">null</span>)</span><br><span class="line">                                  sl.red = <span class="keyword">false</span>;</span><br><span class="line">                          &#125;</span><br><span class="line">                          <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                              xp.red = <span class="keyword">false</span>;</span><br><span class="line">                              root = rotateRight(root, xp);</span><br><span class="line">                          &#125;</span><br><span class="line">                          x = root;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h3 id="RESIZE"><a href="#RESIZE" class="headerlink" title="RESIZE()"></a>RESIZE()</h3><p>最后，我们再来看看resize()的改动</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">       <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">       <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">       <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">               threshold = Integer.MAX_VALUE;</span><br><span class="line">               <span class="keyword">return</span> oldTab;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">               newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">           newCap = oldThr;</span><br><span class="line">       <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">           newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">           newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">           newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">       &#125;</span><br><span class="line">       threshold = newThr;</span><br><span class="line">       <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">           Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">       table = newTab;</span><br><span class="line">       <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">               Node&lt;K,V&gt; e;</span><br><span class="line">               <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                   <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                       newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                       ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                   <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                       Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; next;</span><br><span class="line">                       <span class="keyword">do</span> &#123;</span><br><span class="line">                           next = e.next;</span><br><span class="line">                           <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                               <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                   loHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   loTail.next = e;</span><br><span class="line">                               loTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="keyword">else</span> &#123;</span><br><span class="line">                               <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                   hiHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   hiTail.next = e;</span><br><span class="line">                               hiTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                       <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                           newTab[j] = loHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                           newTab[j + oldCap] = hiHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> newTab;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>代码比较简单，就不细说了，很容易看懂，差别就在jdk7扩容的时候会让链表倒置，而jdk8不会倒置链表</p>
<p>。jdk8中用hash&amp;newcap-1的方法来确定元素位于的hash桶的位置，为0不用移位置，为1就在table[i+oldCap]上了。</p>
<p>当然resize()的时候会对TreeNode红黑树有一些改动，如果新的红黑树长度小于6，就要还原成链表。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2017/11/19/HashMap/" data-id="cjb52pqzd000ggkbzohsi58ih" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/11/22/Mybatis插件/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Mybatis插件
        
      </div>
    </a>
  
  
    <a href="/2017/11/19/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CAS/">CAS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java-WEB/">Java WEB</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaWEB/">JavaWEB</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java基础/">Java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mybatis/">Mybatis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringMVC/">SpringMVC</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js-css/">js&&css</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/02/05/CAS简单实例/">CAS简单实例</a>
          </li>
        
          <li>
            <a href="/2018/02/05/CAS/">CAS</a>
          </li>
        
          <li>
            <a href="/2018/02/05/数据库基础知识/">数据库基础知识</a>
          </li>
        
          <li>
            <a href="/2018/02/05/CAS结合openldap/">CAS结合openldap</a>
          </li>
        
          <li>
            <a href="/2018/01/31/DelegatingFilterProxy/">DelegatingFilterProxy</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>