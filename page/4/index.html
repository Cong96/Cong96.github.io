<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>迷途书童的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="厚积薄发">
<meta property="og:type" content="website">
<meta property="og:title" content="迷途书童的博客">
<meta property="og:url" content="https://cong96.github.io/page/4/index.html">
<meta property="og:site_name" content="迷途书童的博客">
<meta property="og:description" content="厚积薄发">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="迷途书童的博客">
<meta name="twitter:description" content="厚积薄发">
  
    <link rel="alternate" href="/atom.xml" title="迷途书童的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">迷途书童的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">一天进步一点</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://cong96.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-StatementHandler" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/26/StatementHandler/" class="article-date">
  <time datetime="2017-11-26T08:57:18.134Z" itemprop="datePublished">2017-11-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Mybatis/">Mybatis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/26/StatementHandler/">StatementHandler</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>我们接着看四大组件的StatementHandler。</p>
<p>首先还是来看代码</p>
<p>接上一篇末尾</p>
<p>SimpleExecutor的doQuery</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Configuration configuration = ms.getConfiguration();</span><br><span class="line">    <span class="comment">//在这里初始化了除了Excutor的其他三大组件，注意了，这行代码完成的工作很重要，而Executor对象则在初始化得到DefaultSqlSession对象的时候就已经注入到其中了。</span></span><br><span class="line">    StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">    <span class="keyword">return</span> handler.&lt;E&gt;query(stmt, resultHandler);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    closeStatement(stmt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码我们已经知道初始化StatementHandler的时机了，那么下面我们就来看看StatementHandler的构造以及具体实现吧。</p>
<h3 id="StatementHandler介绍"><a href="#StatementHandler介绍" class="headerlink" title="StatementHandler介绍"></a>StatementHandler介绍</h3><p>先看看接口的组成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StatementHandler</span> </span>&#123;</span><br><span class="line"><span class="comment">//prepare方法是用来编译SQL的</span></span><br><span class="line">  <span class="function">Statement <span class="title">prepare</span><span class="params">(Connection connection)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="comment">//设置参数化Sql ps.setParameter()</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">parameterize</span><span class="params">(Statement statement)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">batch</span><span class="params">(Statement statement)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(Statement statement)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="function">BoundSql <span class="title">getBoundSql</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">ParameterHandler <span class="title">getParameterHandler</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有几个重要的方法，prepare,parameterize和query，update，他们的作用是不一样的。</p>
<p>在MyBatis实现了statementHandler的有四个类：</p>
<p>RoutingStatementHandler，这是一个封装类，它不提供具体的实现，只是根据Executor的类型，创建不同的类型StatementHandler。</p>
<p>SimpleStatementHandler，这个类对应于JDBC的Statement对象，用于没有预编译参数的SQL的运行。</p>
<p>PreparedStatementHandler 这个用于预编译参数SQL的运行。</p>
<p>CallableStatementHandler 它将实存储过程的调度。</p>
<p>在MyBatis中，Configuration对象会采用new RoutingStatementHandler()来生成StatementHandler对象，换句话说我们真正使用的是RoutingStatementHandler对象，然后它会根据Executor的类型去创建对应具体的statementHandler对象（SimpleStatementHandler，PreparedStatementHandler和CallableStatementHandler）。</p>
<p><strong>然后利用具体statementHandler的方法完成所需要的功能。那么这个具体的statementHandler是保存在RoutingStatementHandler对象的delegate属性的，所以当我们拦截statementHandler的时候就要常常访问它了。</strong></p>
<h3 id="StatementHandler的初始化"><a href="#StatementHandler的初始化" class="headerlink" title="StatementHandler的初始化"></a>StatementHandler的初始化</h3><p>很明显从上述代码中可以看出，StatementHandler是通过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br></pre></td></tr></table></figure>
<p>初始化的。</p>
<p>那我们就来看看这行代码的具体实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StatementHandler <span class="title">newStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//生成一个StatementHandler实例，StatementHandler有多个实现类,具体调用哪个实现类，通过mappedStatement的相关信息决定，我们后面会具体分析。RoutingStatementHandler只是一个路由信息类。具体的实现类还需要看情况。</span></span><br><span class="line">  StatementHandler statementHandler = <span class="keyword">new</span> RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">  <span class="comment">//这行代码就不多讲了，之前讲Mybatis插件的时候已经讲过了</span></span><br><span class="line">  statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br><span class="line">  <span class="keyword">return</span> statementHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RoutingStatementHandler的构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RoutingStatementHandler</span><span class="params">(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//我们实际使用的StatementHandler实例对象有三种，分别对应三种原生JDBC的Statement</span></span><br><span class="line">  <span class="comment">//分别是Statement (通过查询)  PreparedStatement （预编译的Statement 执行参数化查询 数据库系统会对sql语句进行预编译处理（如果JDBC驱动支持的话），预处理语句将被预先编译好，这条预编译的sql查询语句能在将来的查询中重用）和CallableStatement (存储过程)</span></span><br><span class="line">  <span class="comment">//关于PreparedStatement Statement的区别后面会有文章来专门介绍。</span></span><br><span class="line">  	<span class="comment">//我们这里根据StatementType，调用的是  delegate = new PreparedStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">switch</span> (ms.getStatementType()) &#123;</span><br><span class="line">     <span class="keyword">case</span> STATEMENT:</span><br><span class="line">       delegate = <span class="keyword">new</span> SimpleStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> PREPARED:</span><br><span class="line">       delegate = <span class="keyword">new</span> PreparedStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> CALLABLE:</span><br><span class="line">       delegate = <span class="keyword">new</span> CallableStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">default</span>:</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Unknown statement type: "</span> + ms.getStatementType());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>我们接着看PreparedStatementHandler构造方法的具体实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PreparedStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//这里调用了PreparedStatementHandler的父类BaseStatementHandler的构造方法，上述的三个类都继承了这个类，这个类的构造方法初始化了很多东西，是非常重要的，这里的设计，很明显的使用了模板方法模式。</span></span><br><span class="line">  <span class="keyword">super</span>(executor, mappedStatement, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">BaseStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//依赖倒转</span></span><br><span class="line">    <span class="keyword">this</span>.configuration = mappedStatement.getConfiguration();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">this</span>.executor = executor;</span><br><span class="line">    <span class="keyword">this</span>.mappedStatement = mappedStatement;</span><br><span class="line">    <span class="keyword">this</span>.rowBounds = rowBounds;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.typeHandlerRegistry = configuration.getTypeHandlerRegistry();</span><br><span class="line">    <span class="keyword">this</span>.objectFactory = configuration.getObjectFactory();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (boundSql == <span class="keyword">null</span>) &#123; <span class="comment">// issue #435, get the key before calculating the statement</span></span><br><span class="line">      generateKeys(parameterObject);</span><br><span class="line">      boundSql = mappedStatement.getBoundSql(parameterObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.boundSql = boundSql;</span><br><span class="line"><span class="comment">//初始化parameterHandler和resultSetHandler，就是在这里初始化了剩下的两大组件，而这两大组件都是statementHandler的属性</span></span><br><span class="line">    <span class="keyword">this</span>.parameterHandler = configuration.newParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">    <span class="keyword">this</span>.resultSetHandler = configuration.newResultSetHandler(executor, mappedStatement, rowBounds, parameterHandler, resultHandler, boundSql);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="SimpleExecutor的prepareStatement方法"><a href="#SimpleExecutor的prepareStatement方法" class="headerlink" title="SimpleExecutor的prepareStatement方法"></a>SimpleExecutor的prepareStatement方法</h4><p>得到handler对象后，方法继续往下执行，  stmt = prepareStatement(handler, ms.getStatementLog());</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Statement <span class="title">prepareStatement</span><span class="params">(StatementHandler handler, Log statementLog)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt;</span><br><span class="line">  <span class="comment">//得到JDBC Connection</span></span><br><span class="line">    Connection connection = getConnection(statementLog);</span><br><span class="line">  <span class="comment">//这里就要到了上面说到的StatementHandler的一个重要方法perpare方法，用来预编译sql</span></span><br><span class="line">  stmt = handler.prepare(connection);</span><br><span class="line">    handler.parameterize(stmt);</span><br><span class="line">    <span class="keyword">return</span> stmt;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Statement <span class="title">prepare</span><span class="params">(Connection connection)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> delegate.prepare(connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="BaseStatementHandler的prepare"><a href="#BaseStatementHandler的prepare" class="headerlink" title="BaseStatementHandler的prepare"></a>BaseStatementHandler的prepare</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Statement <span class="title">prepare</span><span class="params">(Connection connection)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  ErrorContext.instance().sql(boundSql.getSql());</span><br><span class="line">  Statement statement = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    statement = instantiateStatement(connection);</span><br><span class="line">    setStatementTimeout(statement);</span><br><span class="line">    setFetchSize(statement);</span><br><span class="line">    <span class="keyword">return</span> statement;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    closeStatement(statement);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    closeStatement(statement);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Error preparing statement.  Cause: "</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>instantiateStatement抽象方法</p>
<p>很明显又是模板方法模式</p>
<h4 id="PreparedStatementHandler-的instantiateStatement"><a href="#PreparedStatementHandler-的instantiateStatement" class="headerlink" title="PreparedStatementHandler 的instantiateStatement"></a>PreparedStatementHandler 的instantiateStatement</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Statement <span class="title">instantiateStatement</span><span class="params">(Connection connection)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  String sql = boundSql.getSql();</span><br><span class="line">  <span class="comment">//如果需要生成相应的键值，这次Debug并没有要求键值，</span></span><br><span class="line">  <span class="keyword">if</span> (mappedStatement.getKeyGenerator() <span class="keyword">instanceof</span> Jdbc3KeyGenerator) &#123;</span><br><span class="line">    String[] keyColumnNames = mappedStatement.getKeyColumns();</span><br><span class="line">    <span class="keyword">if</span> (keyColumnNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> connection.prepareStatement(sql, PreparedStatement.RETURN_GENERATED_KEYS);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> connection.prepareStatement(sql, keyColumnNames);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">//如果在Mapper配置文件中设置了resultSetType,</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (mappedStatement.getResultSetType() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> connection.prepareStatement(sql, mappedStatement.getResultSetType().getValue(), ResultSet.CONCUR_READ_ONLY);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//这种就是我们在使用原生JDBC时最常用的方法了</span></span><br><span class="line">    <span class="keyword">return</span> connection.prepareStatement(sql);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PreparedStatement <span class="title">prepareStatement</span><span class="params">(String sql,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">int</span> resultSetType,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">int</span> resultSetConcurrency)</span></span></span><br><span class="line"><span class="function">                                   <span class="keyword">throws</span> SQLException</span></span><br></pre></td></tr></table></figure>
<p>其中两个参数的意义是：  </p>
<p>resultSetType 是设置 ResultSet 对象的类型可滚动，或者是不可滚动。取值如下：         ResultSet.TYPE_FORWARD_ONLY 只能向前滚动 </p>
<p>​   ResultSet.TYPE_SCROLL_INSENSITIVE 和 Result.TYPE_SCROLL_SENSITIVE 这两个 方法都能够实现任意的前后滚动，使用各种移动的 ResultSet 指针的方法。二者的区别在于前者对于修改不敏感，而后者对于修改敏感。  resultSetConcurency 是设置 ResultSet 对象能够修改的，取值如下：  </p>
<p>​       ResultSet.CONCUR_READ_ONLY 设置为只读类型的参数。  </p>
<p>​       ResultSet.CONCUR_UPDATABLE 设置为可修改类型的参数。  </p>
<p>所以prepare方法就是完成SQL的预编译，只是把原生JDBC预编译的过程封装了一下，比较容易理解。</p>
<p>​   </p>
<h4 id="handler-parameterize-stmt"><a href="#handler-parameterize-stmt" class="headerlink" title="handler.parameterize(stmt);"></a>handler.parameterize(stmt);</h4><p>上面我们在prepare方法里面预编译了SQL。那么我们这个时候希望设置参数。在Statement中我们是使用parameterize方法进行设置参数的。</p>
<p>RoutingStatementHandler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parameterize</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  delegate.parameterize(statement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于具体的实现要涉及到Mybatis的另一个重要组件，接下来会有专门的博客来介绍。</p>
<h4 id="handler-query-stmt-resultHandler"><a href="#handler-query-stmt-resultHandler" class="headerlink" title="handler.\query(stmt, resultHandler);"></a>handler.\<e>query(stmt, resultHandler);</e></h4><p>当Statement经过stmt = prepareStatement(handler, ms.getStatementLog());</p>
<p>处理后（使用了prepare预编译，使用了parameterize设置参数）,</p>
<p>将其传给query(stmt, resultHandler);得到我们想要的返回内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;  </span><br><span class="line">   PreparedStatement ps = (PreparedStatement) statement; </span><br><span class="line">  <span class="comment">//执行查询操作</span></span><br><span class="line">   ps.execute();</span><br><span class="line">  <span class="comment">//通过ResultSetHandler来处理结果集</span></span><br><span class="line">   <span class="keyword">return</span> resultSetHandler.&lt;E&gt; handleResultSets(ps);  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这个的具体实现以后会细说，到这里，一次完整的查询就结束了。</p>
<p>通过了四大组件的配合，才完成了这一次最简单的查询。</p>
<p>在得到DefaultSqlSession对象时初始化了Executor执行器。</p>
<p>然后在调用Executor的doQuery方法查询的时候，会初始化StatementHandler对象，</p>
<p>然后在初始化StatementHandler的过程中，会初始化ParameterHandler和ResultSetHandler对象，</p>
<p>生成的StatementHandler对象会保存这两个对象的引用。</p>
<p>直到这时，Executor的职责就差不多完成了，通过其他的三大组件来完成接下来的数据库查询工作并返回结果。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>StatementHandler是MyBatis四大对象里面最重要的对象，它的方法是十分重要的，也是我们插件的基础。</p>
<hr>
<p><strong>当我们需要改变sql的时候，显然我们要在预编译SQL(prepare方法前加入修改的逻辑)。</strong></p>
<p><strong>当我们需要修改参数的时候我们可以在调用parameterize方法前修改逻辑。或者使用ParameterHandler来改造设置参数。</strong></p>
<p><strong>我们需要控制组装结果集的时候，也可以在query方法前后加入逻辑，或者使用ResultHandler来改造组装结果。</strong></p>
<p><strong>懂的这些方法，才能理解我需要拦截什么对象，如何处理插件，这是MyBatis的核心内容。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2017/11/26/StatementHandler/" data-id="cjb52pqzk000ngkbz45d2nwo3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Executor" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/26/Executor/" class="article-date">
  <time datetime="2017-11-26T08:57:18.132Z" itemprop="datePublished">2017-11-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Mybatis/">Mybatis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/26/Executor/">Executor</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前在用到Mybatis插件的时候就有提到过要好好分析下Mybatis的四大组件，但是由于之前一直在弄公司的消息服务器集群搭建的事情，就耽搁了好一阵子。现在终于有时间了，我们就来好好看看Mybatis的源码。</p>
<h3 id="从一次查询过程说起"><a href="#从一次查询过程说起" class="headerlink" title="从一次查询过程说起"></a>从一次查询过程说起</h3><p>上一次我们我们讲述了Mapper接口以及命令模式的具体命令类MapperMethod。</p>
<p>我们接着之前的分析继续往下走这个查询过程。</p>
<p>接下来就该来到DefaultSqlSession类了。</p>
<p>SqlSession.selectList接MapperMethod</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//1.从confguration(构造DefaultSQLSession使用了建造者模式，configuration对象就是实际具体的建造者)对象中得到MappedStatement对象</span></span><br><span class="line">    MappedStatement ms = configuration.getMappedStatement(statement);</span><br><span class="line">    <span class="comment">//2.使用执行器来进行查询的工作，现在我们的重心就到了Executor执行器上了</span></span><br><span class="line">    List&lt;E&gt; result = executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error querying database.  Cause: "</span> + e, e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述分析，我们得知了，真正的查询操作是通过Executor执行器代劳的。</p>
<h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><p>在上述代码中，我们可以知道Executor对象是DefaultSqlSession类中的一个属性，那么首先，我们就得知道Executor是怎么初始化的。</p>
<p>我们从得到DefatulSqlSession的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlSession session= sessionFactory.openSession();</span><br></pre></td></tr></table></figure>
<p>这行代码为入口分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> sessionFactory.openSession();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> SqlSession <span class="title">openSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> openSessionFromDataSource(configuration.getDefaultExecutorType(), <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> SqlSession <span class="title">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">    Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> Environment environment = configuration.getEnvironment();</span><br><span class="line">      <span class="keyword">final</span> TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">      tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">      <span class="comment">//1、在这里初始化了executor</span></span><br><span class="line">      <span class="keyword">final</span> Executor executor = configuration.newExecutor(tx, execType);</span><br><span class="line">      <span class="comment">//2、并将executor作为DefaultSqlSession构造方法的实参传入，Executor和SqlSession的联系就是在这里生成的。</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      closeTransaction(tx); <span class="comment">// may have fetched a connection so lets call close()</span></span><br><span class="line">      <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error opening session.  Cause: "</span> + e, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>configuration.newExecutor(tx, execType);</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</span><br><span class="line">  executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">  executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">  Executor executor;</span><br><span class="line">  <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果没有显式的设置，则使用SimpleExecutor,一般都是使用这个Executor</span></span><br><span class="line">    executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果是缓存了的执行器，就新建缓存专用的执行器。</span></span><br><span class="line">  <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">    </span><br><span class="line">    executor = <span class="keyword">new</span> CachingExecutor(executor);</span><br><span class="line">  &#125;</span><br><span class="line">  executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">  <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法通过Mybatis相关配置文件中设置的ExecutorType来决定(如果没有显式的设置，则使用默认的Type)到底生成哪种Executor。</p>
<p>这里对几种Executor进行介绍一下，并说明用使用显式配置时该如何配置</p>
<p>SimpleExecutor – SIMPLE 就是普通的执行器。</p>
<p>ReuseExecutor -执行器会重用预处理语句（prepared statements）</p>
<p>BatchExecutor –它是批量执行器</p>
<p>这些就是mybatis的三种执行器。你可以通过配置文件的settings里面的元素defaultExecutorType，配置它，默认是采用SimpleExecutor</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"defaultExecutorType"</span> <span class="attr">value</span>=<span class="string">"SIMPLE"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果你在Spring运用它，那么你可以这么配置它：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionTemplateBatch"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionTemplate"</span>&gt;</span>       </span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">ref</span>=<span class="string">"sqlSessionFactory"</span> /&gt;</span>    </span><br><span class="line"><span class="comment">&lt;!--更新采用批量的executor --&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span> <span class="attr">value</span>=<span class="string">"BATCH"</span>/&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="继续分析查询过程"><a href="#继续分析查询过程" class="headerlink" title="继续分析查询过程"></a>继续分析查询过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//1.从confguration(构造DefaultSQLSession使用了建造者模式，configuration对象就是实际具体的建造者)对象中得到MappedStatement对象</span></span><br><span class="line">    MappedStatement ms = configuration.getMappedStatement(statement);</span><br><span class="line">    <span class="comment">//2.使用执行器来进行查询的工作，现在我们的重心就到了Executor执行器上了</span></span><br><span class="line">    List&lt;E&gt; result = executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error querying database.  Cause: "</span> + e, e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>1.warpCollection是对Method参数的又一次处理，我们看看具体做了些什么</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> Object <span class="title">wrapCollection</span><span class="params">(<span class="keyword">final</span> Object object)</span> </span>&#123;</span><br><span class="line"><span class="comment">//我们看到如果经过MapperMethod封装的参数的类型是List类型的话</span></span><br><span class="line">   <span class="keyword">if</span> (object <span class="keyword">instanceof</span> List) &#123;</span><br><span class="line">     StrictMap&lt;Object&gt; map = <span class="keyword">new</span> StrictMap&lt;Object&gt;();</span><br><span class="line">     <span class="comment">//将object作为Value存入map中，而且Key为list,StrictMap继承了HashMap，并且该HashMap的Key是String类型的，这一层封装的意义就在于限定该map的Key只能为String类型</span></span><br><span class="line">     <span class="comment">//这里更需要引起我们注意的是这里的Key为list，当你第一眼看到这个list的时候会想到什么呢，</span></span><br><span class="line">     <span class="comment">//反正我是一下就想到了在使用动态sql的foreach节点时候出现过list，所以，为了能够对Mapper配置文件中的list对应的对象群出来，这里先将list设置好，这就为什么当参数是List类型时候放入Map时的Key设为list了。</span></span><br><span class="line">      map.put(<span class="string">"list"</span>, object);</span><br><span class="line">     <span class="keyword">return</span> map;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object != <span class="keyword">null</span> &amp;&amp; object.getClass().isArray()) &#123;</span><br><span class="line">     StrictMap&lt;Object&gt; map = <span class="keyword">new</span> StrictMap&lt;Object&gt;();</span><br><span class="line">    <span class="comment">//当数组类型时，放入map中，Key为array，理由同上</span></span><br><span class="line">     map.put(<span class="string">"array"</span>, object);</span><br><span class="line">     <span class="keyword">return</span> map;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> object;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>warpCollection这个方法的作用就是：</p>
<p>将List或者Array类型转化为Map类型的，并且存入Map时一定要给限定相应的Key，至于为什么要转为Map类型的，当我们分析到后面的时候自然就会有答案了，现在不用深究。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static class StrictMap&lt;V&gt; extends HashMap&lt;String, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = -5741767162221585340L;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public V get(Object key) &#123;</span><br><span class="line">      if (!super.containsKey(key)) &#123;</span><br><span class="line">        throw new BindingException(&quot;Parameter &apos;&quot; + key + &quot;&apos; not found. Available parameters are &quot; + this.keySet());</span><br><span class="line">      &#125;</span><br><span class="line">      return super.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2.query方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">   <span class="comment">//1.  BoundSql是对sql的封装，是MappedStatement对Mapper配置文件提取后将SQL的相关信息封装后都集中了BoundSql中，具体是怎么集中封装的，下面会分析</span></span><br><span class="line">   BoundSql boundSql = ms.getBoundSql(parameterObject);</span><br><span class="line">   CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line">   <span class="keyword">return</span> query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>​    </p>
<ul>
<li>1.MappedStatement的getBoundSql</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BoundSql <span class="title">getBoundSql</span><span class="params">(Object parameterObject)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//2 DynamicSqlSource的getBoundSql</span></span><br><span class="line">    BoundSql boundSql = sqlSource.getBoundSql(parameterObject);</span><br><span class="line">    List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">  <span class="comment">//将得到的paramterMappings放入到BoundSql对象中，这点是非常重要的</span></span><br><span class="line">    <span class="keyword">if</span> (parameterMappings == <span class="keyword">null</span> || parameterMappings.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      boundSql = <span class="keyword">new</span> BoundSql(configuration, boundSql.getSql(), parameterMap.getParameterMappings(), parameterObject);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><ul>
<li>2.DynamicSqlSource的getBoundSql(因为使用了动态SQL，所以使用的DynamicSqlSource，关于各种情况具体是怎么封装sql的，也就是关于BoundSql对象以及SqlSource接口和相应的一些实现类，会有一个专门的博客介绍，对于Mybatis源码的一些关键类，都应该有单独的博客介绍，但是我们还是先有一个大体的认识)</li>
</ul>
</li>
</ul>
<p>​    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BoundSql <span class="title">getBoundSql</span><span class="params">(Object parameterObject)</span> </span>&#123;</span><br><span class="line">   DynamicContext context = <span class="keyword">new</span> DynamicContext(configuration, parameterObject);</span><br><span class="line">	<span class="comment">//3.将Mapper配置文件中的SQL组装起来，在初始化的过程中，该SQL对应的处理节点分成了两个StaticSqlNode，和一个ForEachSqlNode。</span></span><br><span class="line">  rootSqlNode.apply(context);</span><br><span class="line">   SqlSourceBuilder sqlSourceParser = <span class="keyword">new</span> SqlSourceBuilder(configuration);</span><br><span class="line">   Class&lt;?&gt; parameterType = parameterObject == <span class="keyword">null</span> ? Object.class : parameterObject.getClass();</span><br><span class="line">  <span class="comment">//4.得到SqlSource对象，最重要的是parse方法让我们得到paramtermappings,这个对象对我们执行参数化sql时非常重要</span></span><br><span class="line">   SqlSource sqlSource = sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings());</span><br><span class="line">   BoundSql boundSql = sqlSource.getBoundSql(parameterObject);</span><br><span class="line">   <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : context.getBindings().entrySet()) &#123;</span><br><span class="line">     boundSql.setAdditionalParameter(entry.getKey(), entry.getValue());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> boundSql;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><ul>
<li>3.DynamicContext的创建</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PARAMETER_OBJECT_KEY = <span class="string">"_parameter"</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DATABASE_ID_KEY = <span class="string">"_databaseId"</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DynamicContext</span><span class="params">(Configuration configuration, Object parameterObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parameterObject != <span class="keyword">null</span> &amp;&amp; !(parameterObject <span class="keyword">instanceof</span> Map)) &#123;</span><br><span class="line">      MetaObject metaObject = configuration.newMetaObject(parameterObject);</span><br><span class="line">      bindings = <span class="keyword">new</span> ContextMap(metaObject);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      bindings = <span class="keyword">new</span> ContextMap(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    bindings.put(PARAMETER_OBJECT_KEY, parameterObject);</span><br><span class="line">    bindings.put(DATABASE_ID_KEY, configuration.getDatabaseId());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里没有特别难理解的地方，就是DynamicContext中有个ContextMap类型（同样继承了HashMap）的属性bindings,这个属性是非常重要的，然后将两个元素放入这个Map中，这里需要注意的是我们会将Method封装参数放入Map中，并且对应的Key是_parameter。一看到_parameter,我们肯定就想到了在学习编写Mapper配置文件中使用过这个。</p>
<p>3.(1)MixedSqlNode</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">private</span> List&lt;SqlNode&gt; contents;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MixedSqlNode</span><span class="params">(List&lt;SqlNode&gt; contents)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.contents = contents;</span><br><span class="line">  &#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(DynamicContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (SqlNode sqlNode : contents) &#123;</span><br><span class="line">      sqlNode.apply(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里的contents就对应的两个StaticSqlNode和一个ForEachSqlNode，如何拼接ForEachSqlNode,以及如何提取ps.setParameter()所用到的信息是问题的关键。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(DynamicContext context)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; bindings = context.getBindings();</span><br><span class="line">    <span class="keyword">final</span> Iterable&lt;?&gt; iterable = evaluator.evaluateIterable(collectionExpression, bindings);</span><br><span class="line">    <span class="keyword">if</span> (!iterable.iterator().hasNext()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> first = <span class="keyword">true</span>;</span><br><span class="line">    applyOpen(context);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Object o : iterable) &#123;</span><br><span class="line">      DynamicContext oldContext = context;</span><br><span class="line">      <span class="keyword">if</span> (first) &#123;</span><br><span class="line">        context = <span class="keyword">new</span> PrefixedContext(context, <span class="string">""</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (separator != <span class="keyword">null</span>) &#123;</span><br><span class="line">          context = <span class="keyword">new</span> PrefixedContext(context, separator);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          context = <span class="keyword">new</span> PrefixedContext(context, <span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> uniqueNumber = context.getUniqueNumber();</span><br><span class="line">      <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123; <span class="comment">// Issue #709 </span></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) </span><br><span class="line">        Map.Entry&lt;Object, Object&gt; mapEntry = (Map.Entry&lt;Object, Object&gt;) o;</span><br><span class="line">        applyIndex(context, mapEntry.getKey(), uniqueNumber);</span><br><span class="line">        applyItem(context, mapEntry.getValue(), uniqueNumber);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        applyIndex(context, i, uniqueNumber);</span><br><span class="line">        applyItem(context, o, uniqueNumber);</span><br><span class="line">      &#125;</span><br><span class="line">      contents.apply(<span class="keyword">new</span> FilteredDynamicContext(configuration, context, index, item, uniqueNumber));</span><br><span class="line">      <span class="keyword">if</span> (first) first = !((PrefixedContext) context).isPrefixApplied();</span><br><span class="line">      context = oldContext;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    applyClose(context);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><ul>
<li>4.最后我们需要了解下parse方法，注意这个方法的具体实现里面得到了paramterMappings，这是非常重要的。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSource <span class="title">parse</span><span class="params">(String originalSql, Class&lt;?&gt; parameterType, Map&lt;String, Object&gt; additionalParameters)</span> </span>&#123;</span><br><span class="line">  ParameterMappingTokenHandler handler = <span class="keyword">new</span> ParameterMappingTokenHandler(configuration, parameterType, additionalParameters);</span><br><span class="line">  <span class="comment">//在这个过程中会把 #&#123;&#125; 里的信息赋给paramterMappings</span></span><br><span class="line">  GenericTokenParser parser = <span class="keyword">new</span> GenericTokenParser(<span class="string">"#&#123;"</span>, <span class="string">"&#125;"</span>, handler);</span><br><span class="line">  String sql = parser.parse(originalSql);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> StaticSqlSource(configuration, sql, handler.getParameterMappings());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2.BaseExecutor的query方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">   BoundSql boundSql = ms.getBoundSql(parameter);</span><br><span class="line">   <span class="comment">//生成一个CacheKey</span></span><br><span class="line">   CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);</span><br><span class="line">   <span class="keyword">return</span> query(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>终于分析到这个方法的最后一行代码了。</p>
<p>BaseExecutor的query方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">"executing a query"</span>).object(ms.getId());</span><br><span class="line">  <span class="keyword">if</span> (closed) <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Executor was closed."</span>);</span><br><span class="line">  <span class="keyword">if</span> (queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">    clearLocalCache();</span><br><span class="line">  &#125;</span><br><span class="line">  List&lt;E&gt; list;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    queryStack++;</span><br><span class="line">    <span class="comment">//查看是不是已经有查询过了，有的话直接在本地缓存中取出来</span></span><br><span class="line">    list = resultHandler == <span class="keyword">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//如果是存储过程，需要把输出处理一下，具体处理目前没有细看</span></span><br><span class="line">      handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//如果没有本地缓存或者使用了resultHandler，需要到数据库中去查。</span></span><br><span class="line">      list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    queryStack--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (queryStack == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (DeferredLoad deferredLoad : deferredLoads) &#123;</span><br><span class="line">      deferredLoad.load();</span><br><span class="line">    &#125;</span><br><span class="line">    deferredLoads.clear(); <span class="comment">// issue #601</span></span><br><span class="line">    <span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">      clearLocalCache(); <span class="comment">// issue #482</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>queryFromDatabase</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">queryFromDatabase</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  List&lt;E&gt; list;</span><br><span class="line">  localCache.putObject(key, EXECUTION_PLACEHOLDER);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    localCache.removeObject(key);</span><br><span class="line">  &#125;</span><br><span class="line">  localCache.putObject(key, list);</span><br><span class="line">  <span class="keyword">if</span> (ms.getStatementType() == StatementType.CALLABLE) &#123;</span><br><span class="line">    localOutputParameterCache.putObject(key, parameter);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SimpleExecutor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Configuration configuration = ms.getConfiguration();</span><br><span class="line">    <span class="comment">//在这里初始化了除了Excutor的其他三大组件，注意了，这行代码完成的工作很重要，而Executor对象则在初始化得到DefaultSqlSession对象的时候就已经注入到其中了。</span></span><br><span class="line">    StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">    <span class="keyword">return</span> handler.&lt;E&gt;query(stmt, resultHandler);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    closeStatement(stmt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法里面，我们完成了得到结果的所有流程。</p>
<p>1、我们先得到Configuration对象。</p>
<p>2、利用COnfiguration对象去生成其他三大组件对象，用三大组件对象完成查询的具体操作。</p>
<p>3、利用三大组件进行具体得到结果</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2017/11/26/Executor/" data-id="cjb52pqyr0003gkbzri2elp4q" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Mapper接口" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/26/Mapper接口/" class="article-date">
  <time datetime="2017-11-25T16:59:25.391Z" itemprop="datePublished">2017-11-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Mybatis/">Mybatis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/26/Mapper接口/">Mapper接口</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前在说到Mybatis插件的时候说以后要好好分析下Mybatis的四大组件，之前一直在为公司忙搭建RocketMQ消息集群的事情，就耽误了一段时间，最近终于有时间来分析下了，要分析四大组件，还是要从一次完整的查询过程说起，把Mybatis的核心源码都过一遍。</p>
<h3 id="从一次查询说起"><a href="#从一次查询说起" class="headerlink" title="从一次查询说起"></a>从一次查询说起</h3><p>我们做一次Mybatis的查询测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	SqlSession session = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		session = MybatisUtil.getCurrentSession();</span><br><span class="line">		UserDao userDao = session.getMapper(UserDao.class);</span><br><span class="line">		List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">		list.add(<span class="number">1</span>);</span><br><span class="line">		list.add(<span class="number">3</span>);</span><br><span class="line">		list.add(<span class="number">25</span>);</span><br><span class="line">		List&lt;User&gt; userList = userDao.queryList(list);</span><br><span class="line">		System.out.println(JSON.toJSONString(userList));</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (session != <span class="keyword">null</span>)</span><br><span class="line">			session.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的Mapper配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.wangcc.mybatis.dao.UserDao&quot;&gt;</span><br><span class="line">&lt;resultMap type=&quot;User&quot; id=&quot;UserMapper&quot;&gt;</span><br><span class="line">&lt;result property=&quot;id&quot; column=&quot;t_id&quot;/&gt;</span><br><span class="line">&lt;result property=&quot;name&quot; column=&quot;t_name&quot;/&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line">&lt;select id=&quot;queryList&quot; resultMap=&quot;UserMapper&quot;&gt;</span><br><span class="line">select * from t_user where t_id in </span><br><span class="line">&lt;foreach collection=&quot;list&quot; item=&quot;uId&quot; index=&quot;index&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;#&#123;uId&#125;&lt;/foreach&gt;</span><br><span class="line"></span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;insert id=&quot;insert&quot; parameterType=&quot;User&quot;&gt;</span><br><span class="line"></span><br><span class="line">insert into t_user (t_name,address) values(#&#123;name&#125;,#&#123;address&#125;)</span><br><span class="line">&lt;/insert&gt;</span><br><span class="line">&lt;insert id=&quot;batchInsert&quot; &gt;</span><br><span class="line">insert into t_user (t_name,address) values &lt;foreach collection=&quot;list&quot; item=&quot;user&quot; separator=&quot;,&quot;&gt;</span><br><span class="line">(#&#123;user.name&#125;,#&#123;user.address&#125;)</span><br><span class="line">&lt;/foreach&gt;</span><br><span class="line"></span><br><span class="line">&lt;/insert&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>
<p>如果你是初次使用Mybatis，那么你一定会好奇为什么这里的UserDao都是接口并不是具体的实现类。</p>
<p>而如果你熟悉JDK动态代理，那么一看到这种接口可以直接执行方法的情况，那么肯定是用了代理，那么虽然我们能够知道为什么可以直接执行，但是我们也要了解他具体是怎么实现的。我们就以</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UserDao userDao = session.getMapper(UserDao.class);</span><br></pre></td></tr></table></figure>
<p>为Debug入口。</p>
<p>进入getMapper方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> configuration.&lt;T&gt;getMapper(type, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现还是调用了构建SqlSession的最重要的对象Configuration的方法。</p>
<p>DefaultSqlSession对象中保存着Configuration对象的引用。</p>
<p>进入到Configuration中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> mapperRegistry.getMapper(type, sqlSession);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现是调用的MapperRegistry对象（Configuration保存着其引用，在初始化Mybatis的配置文件的时候，就会将所有的Mapper接口注册到MapperRegistry的Map\<class<?>, MapperProxyFactory&lt;?&gt;&gt; knownMappersz这个HashMap对象中，在注册的过程中Mapper接口会被封装为MapperProxyFactory对象）</class<?></p>
<p>我们看看MapperRegistry中的geMapper方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//在knownMappers中查找是否已经注册了，如果没有注册直接抛出异常，注册Mapper接口是在初始化Mybatis配置文件时必须就要完成的工作，不能在调用getMapper的时候再动态去注册</span></span><br><span class="line">    <span class="keyword">final</span> MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">    <span class="keyword">if</span> (mapperProxyFactory == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Type "</span> + type + <span class="string">" is not known to the MapperRegistry."</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">return</span> mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Error getting mapper instance. Cause: "</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>进入newInstance方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line"><span class="comment">//封装了一个MapperProxy对象,即组合模式，为了解耦，我们一般能不用继承就不用继续，尽量使用组合，这里MapperProxy是实现了InvocationHandler接口的类</span></span><br><span class="line">   <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy&lt;T&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">   <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p> newInstance(mapperProxy) 得到Mapper接口的代理对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到现在，如何得到Mapper接口的代理对象的流程就走完了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2017/11/26/Mapper接口/" data-id="cjb52pqz50008gkbzbjtvr88p" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-MapperMethod" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/26/MapperMethod/" class="article-date">
  <time datetime="2017-11-25T16:59:07.345Z" itemprop="datePublished">2017-11-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Mybatis/">Mybatis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/26/MapperMethod/">MapperMethod</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>我们接着上面继续分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		SqlSession session = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			session = MybatisUtil.getCurrentSession();</span><br><span class="line">			UserDao userDao = session.getMapper(UserDao.class);</span><br><span class="line">			List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">			list.add(<span class="number">1</span>);</span><br><span class="line">			list.add(<span class="number">3</span>);</span><br><span class="line">			list.add(<span class="number">25</span>);</span><br><span class="line">          </span><br><span class="line">			List&lt;User&gt; userList = userDao.queryList(list);</span><br><span class="line">			System.out.println(JSON.toJSONString(userList));</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (session != <span class="keyword">null</span>)</span><br><span class="line">				session.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>我们都这一句代码进行DEBUG</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; userList = userDao.queryList(list);</span><br></pre></td></tr></table></figure>
<p>首先，我们会进入MapperProxy这个类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">     <span class="comment">//如果方法是Object类自带的方法，比如没有被重写的equals toString, hashcode 等，还是执行原来的方法</span></span><br><span class="line">  <span class="comment">// getDeclaringClass()返回表示声明由此 Method 对象表示的方法的类或接口的 Class 对象。</span></span><br><span class="line">  <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果不是object的自带方法，先去  Map&lt;Method, MapperMethod&gt; methodCache中找是否已经存在这个method了，没有就将method封装成MapperMethod存进mehtodCache中然后返回MapperMethod。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);</span><br><span class="line">  <span class="comment">//然后执行MapprMehtod的execute方法</span></span><br><span class="line">  <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看看cachedMapperMethod</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> MapperMethod <span class="title">cachedMapperMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line"><span class="comment">//当method是第一次调用时,我们无法在methodCache中得到MapperMethod,我们就得新创建一个MapperMethod</span></span><br><span class="line">  MapperMethod mapperMethod = methodCache.get(method);</span><br><span class="line">  <span class="keyword">if</span> (mapperMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//创建一个MapperMethod,这里是关键。</span></span><br><span class="line">    mapperMethod = <span class="keyword">new</span> MapperMethod(mapperInterface, method, sqlSession.getConfiguration());</span><br><span class="line">    methodCache.put(method, mapperMethod);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mapperMethod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>终于到了我们重点要讲解的MapperMethod类了</p>
<p>我们先看MapperMethod构造方法，初始化了他的两个属性，command和method</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MapperMethod</span><span class="params">(Class&lt;?&gt; mapperInterface, Method method, Configuration config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.command = <span class="keyword">new</span> SqlCommand(config, mapperInterface, method);</span><br><span class="line">    <span class="keyword">this</span>.method = <span class="keyword">new</span> MethodSignature(config, method);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这两个属性非常的重要，要详细的介绍的话需要大量的篇幅，所以先放在一旁。</p>
<p>我们先看具体的执行方法execute</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">   Object result;</span><br><span class="line">   <span class="keyword">if</span> (SqlCommandType.INSERT == command.getType()) &#123;</span><br><span class="line">     Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">     result = rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SqlCommandType.UPDATE == command.getType()) &#123;</span><br><span class="line">     Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">     result = rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SqlCommandType.DELETE == command.getType()) &#123;</span><br><span class="line">     Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">     result = rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">   &#125; </span><br><span class="line">  <span class="comment">//很明显我们的SqlCommandType是SELECT类型</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (SqlCommandType.SELECT == command.getType()) &#123;</span><br><span class="line">    <span class="comment">//是否返回类型是void类型并且Method参数列表中包含resultHandler,具体的判断在文末分析</span></span><br><span class="line">     <span class="keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">       executeWithResultHandler(sqlSession, args);</span><br><span class="line">       result = <span class="keyword">null</span>;</span><br><span class="line">     &#125; </span><br><span class="line">    <span class="comment">//我们调用的方法的返回类型是List，会走这个分支。我们看下method.returnsMany的具体实现吧。</span></span><br><span class="line">    <span class="comment">//这里的method是MapperMethod的属性MethodSignature对象</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMany()) &#123;</span><br><span class="line">       result = executeForMany(sqlSession, args);</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMap()) &#123;</span><br><span class="line">       result = executeForMap(sqlSession, args);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">       result = sqlSession.selectOne(command.getName(), param);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Unknown execution method for: "</span> + command.getName());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (result == <span class="keyword">null</span> &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Mapper method '"</span> + command.getName() </span><br><span class="line">         + <span class="string">" attempted to return null from a method with a primitive return type ("</span> + method.getReturnType() + <span class="string">")."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>executeForMany</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">Object <span class="title">executeForMany</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">  List&lt;E&gt; result;</span><br><span class="line">  <span class="comment">//这个方法我们非常有必要分析一下,这个方法封装了我们调用的Mapper接口Method的参数列表对应实参</span></span><br><span class="line">  Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">  <span class="keyword">if</span> (method.hasRowBounds()) &#123;</span><br><span class="line">    RowBounds rowBounds = method.extractRowBounds(args);</span><br><span class="line"> <span class="comment">//终于到了我们的DefaultSqlSession的方法了</span></span><br><span class="line">    result = sqlSession.&lt;E&gt;selectList(command.getName(), param, rowBounds);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = sqlSession.&lt;E&gt;selectList(command.getName(), param);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// issue #510 Collections &amp; arrays support</span></span><br><span class="line">  <span class="keyword">if</span> (!method.getReturnType().isAssignableFrom(result.getClass())) &#123;</span><br><span class="line">    <span class="keyword">if</span> (method.getReturnType().isArray()) &#123;</span><br><span class="line">      <span class="keyword">return</span> convertToArray(result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> convertToDeclaredCollection(sqlSession.getConfiguration(), result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>convertArgsToSqlCommandParam</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">convertArgsToSqlCommandParam</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">   	</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> paramCount = params.size();</span><br><span class="line">   <span class="comment">//没有参数 </span></span><br><span class="line">   <span class="keyword">if</span> (args == <span class="keyword">null</span> || paramCount == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125; </span><br><span class="line">   <span class="comment">//有一个参数，而且不是@Param注解修饰的参数</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (!hasNamedParameters &amp;&amp; paramCount == <span class="number">1</span>) &#123;</span><br><span class="line">     <span class="comment">//直接返回形参对应的实参</span></span><br><span class="line">        <span class="keyword">return</span> args[params.keySet().iterator().next()];</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   否则</span></span><br><span class="line"><span class="comment">   多个参数或者一个参数但是使用@param注解</span></span><br><span class="line"><span class="comment">   就要按以下方法操作</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">	</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Map&lt;String, Object&gt; param = <span class="keyword">new</span> ParamMap&lt;Object&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : params.entrySet()) &#123;</span><br><span class="line">          <span class="comment">//如果是使用@param注解的，则put的Key是@param(value)里的Value,如果不是，则put的Key就是int类型的，put的Value自然都是Method形参对应的实参（args[entry.getKey()] entry.getKey() Key都是从0-i-1的int类型，代表顺序，结合getParams方法分析就明了，了解了这些，对于Mybatis中传递参数的三种方式也就理解了</span></span><br><span class="line">          http:<span class="comment">//blog.csdn.net/shasiqq/article/details/51305666</span></span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line">          param.put(entry.getValue(), args[entry.getKey()]);</span><br><span class="line">          <span class="comment">// issue #71, add param names as param1, param2...but ensure backward compatibility</span></span><br><span class="line">          <span class="comment">//但要确保向后兼容性</span></span><br><span class="line">          <span class="keyword">final</span> String genericParamName = <span class="string">"param"</span> + String.valueOf(i + <span class="number">1</span>);</span><br><span class="line">          <span class="keyword">if</span> (!param.containsKey(genericParamName)) &#123;</span><br><span class="line">            param.put(genericParamName, args[entry.getKey()]);</span><br><span class="line">          &#125;</span><br><span class="line">          i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> param;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里我们需要了解params对象到底是怎样得来的，他的具体实现是怎样的。</p>
<p>​      </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">this</span>.params = Collections.unmodifiableSortedMap(getParams(method, <span class="keyword">this</span>.hasNamedParameters));</span><br><span class="line"><span class="function"><span class="keyword">private</span> SortedMap&lt;Integer, String&gt; <span class="title">getParams</span><span class="params">(Method method, <span class="keyword">boolean</span> hasNamedParameters)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> SortedMap&lt;Integer, String&gt; params = <span class="keyword">new</span> TreeMap&lt;Integer, String&gt;();</span><br><span class="line">     <span class="keyword">final</span> Class&lt;?&gt;[] argTypes = method.getParameterTypes();</span><br><span class="line">           <span class="comment">//如果是@param修饰的，则put的Value是@param(value)中的Value</span></span><br><span class="line">         <span class="comment">//如果不是，则put的Value就是当前parms这个Map的size</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; argTypes.length; i++) &#123;</span><br><span class="line">       <span class="keyword">if</span> (!RowBounds.class.isAssignableFrom(argTypes[i]) &amp;&amp; !ResultHandler.class.isAssignableFrom(argTypes[i])) &#123;</span><br><span class="line">         String paramName = String.valueOf(params.size());</span><br><span class="line">         <span class="keyword">if</span> (hasNamedParameters) &#123;</span><br><span class="line">           paramName = getParamNameFromAnnotation(method, i, paramName);</span><br><span class="line">         &#125;</span><br><span class="line">         params.put(i, paramName);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> params;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> String <span class="title">getParamNameFromAnnotation</span><span class="params">(Method method, <span class="keyword">int</span> i, String paramName)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> Object[] paramAnnos = method.getParameterAnnotations()[i];</span><br><span class="line">     <span class="keyword">for</span> (Object paramAnno : paramAnnos) &#123;</span><br><span class="line">       <span class="keyword">if</span> (paramAnno <span class="keyword">instanceof</span> Param) &#123;</span><br><span class="line">         paramName = ((Param) paramAnno).value();</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> paramName;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>下面是分析上述方法时用到的Method和Class类中的方法介绍：</p>
<p>Method</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getParameterTypes</span><br><span class="line">public Class&lt;?&gt;[] getParameterTypes()按照声明顺序返回 Class 对象的数组，这些对象描述了此 Method 对象所表示的方法的形参类型。如果底层方法不带参数，则返回长度为 0 的数组。 </span><br><span class="line"></span><br><span class="line">返回：</span><br><span class="line">此对象所表示的方法的参数类型</span><br></pre></td></tr></table></figure>
<p>Class</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">isAssignableFrom</span><br><span class="line">public boolean isAssignableFrom(Class&lt;?&gt; cls)判定此 Class 对象所表示的类或接口与指定的 Class 参数所表示的类或接口是否相同，或是否是其超类或超接口。如果是则返回 true；否则返回 false。如果该 Class 表示一个基本类型，且指定的 Class 参数正是该 Class 对象，则该方法返回 true；否则返回 false。 </span><br><span class="line">特别地，通过身份转换或扩展引用转换，此方法能测试指定 Class 参数所表示的类型能否转换为此 Class 对象所表示的类型。有关详细信息，请参阅 Java Language Specification 的第 5.1.1 和 5.1.4 节。 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">cls - 要检查的 Class 对象 </span><br><span class="line">返回：</span><br><span class="line">表明 cls 类型的对象能否赋予此类对象的 boolean 值 </span><br><span class="line">抛出： </span><br><span class="line">NullPointerException - 如果指定的 Class 参数为 null。</span><br><span class="line">从以下版本开始： </span><br><span class="line">JDK1.1 </span><br><span class="line"></span><br><span class="line">getComponentType</span><br><span class="line">public Class&lt;?&gt; getComponentType()返回表示数组组件类型的 Class。如果此类不表示数组类，则此方法返回 null。 </span><br><span class="line"></span><br><span class="line">返回：</span><br><span class="line">如果此类是数组，则返回表示此类组件类型的 Class</span><br><span class="line">从以下版本开始： </span><br><span class="line">JDK1.1 </span><br><span class="line">另请参见：</span><br><span class="line">Array</span><br></pre></td></tr></table></figure>
<p>hasNamedParams判断Mapper接口中的指定方法中的参数列表中是否有@Param注解修饰</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasNamedParams</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> hasNamedParams = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    getParameterAnnotations() </span></span><br><span class="line"><span class="comment">        返回表示按照声明顺序对此 Method 对象所表示方法的形参进行注释的那个数组的数组。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">final</span> Object[][] paramAnnos = method.getParameterAnnotations();</span><br><span class="line">    <span class="keyword">for</span> (Object[] paramAnno : paramAnnos) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Object aParamAnno : paramAnno) &#123;</span><br><span class="line">        <span class="comment">//看是否参数有@Param注解修饰</span></span><br><span class="line">        <span class="keyword">if</span> (aParamAnno <span class="keyword">instanceof</span> Param) &#123;</span><br><span class="line">          hasNamedParams = <span class="keyword">true</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hasNamedParams;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getParameterAnnotations</span><br><span class="line">public Annotation[][] getParameterAnnotations()返回表示按照声明顺序对此 Method 对象所表示方法的形参进行注释(应该是注解把)的那个数组的数组。（如果底层方法没有参数，则返回长度为零的数组。如果该方法有一个或多个参数，则为每个不带注释的参数返回长度为零的嵌套数组。）返回数组中包含的注释对象是可序列化的。此方法的调用者可以随意修改返回的数组；这不会对其他调用者返回的数组产生任何影响。 </span><br><span class="line"></span><br><span class="line">返回：</span><br><span class="line">表示按声明顺序对此 Method 对象所表示方法的形参进行注释的那个数组的数组</span><br></pre></td></tr></table></figure>
<ul>
<li>是否Method返回类型是void类型并且Method参数列表中包含resultHandler</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//select语句，Method的返回类型如果是void而且参数列表中有参数类型是ResultHandler</span></span><br><span class="line"><span class="keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">              <span class="keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">        executeWithResultHandler(sqlSession, args);</span><br><span class="line">        result = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasResultHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (resultHandlerIndex != <span class="keyword">null</span>);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.resultHandlerIndex = getUniqueParamIndex(method, ResultHandler.class);</span><br></pre></td></tr></table></figure>
<p>getUniqueParamIndex分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原来是个很简单的方法就是判断是否参数列表中是否有参数类型为ResultHandler的，有就返回index，没有就是null</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Integer <span class="title">getUniqueParamIndex</span><span class="params">(Method method, Class&lt;?&gt; paramType)</span> </span>&#123;</span><br><span class="line">      Integer index = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">final</span> Class&lt;?&gt;[] argTypes = method.getParameterTypes();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; argTypes.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (paramType.isAssignableFrom(argTypes[i])) &#123;</span><br><span class="line">          <span class="keyword">if</span> (index == <span class="keyword">null</span>) &#123;</span><br><span class="line">            index = i;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(method.getName() + <span class="string">" cannot have multiple "</span> + paramType.getSimpleName() + <span class="string">" parameters"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>1.MapperMethod的execute方法的作用</p>
<ul>
<li><p>首先是将Method方法的实参封装成Object对象</p>
</li>
<li><p>然后调用DefaultSqlSession中的方法，将上述的Object对象以及command.getName()   （name = ms.getId();  SqlCommand对象中的name即是该Method对应XML配置文件中SQL的的唯一标示）作为参数 传入方法中,上述两个参数是必须要传递的</p>
<p>本例是使用了selectList方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = sqlSession.&lt;E&gt;selectList(command.getName(), param);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>2.Mybatis为什么要设计MapperMethod类呢？</p>
<p>其实经过这一分析，如果熟悉设计模式的人就会发现，这是使用了命令模式。</p>
<p>什么是命令模式呢，命令模式就是让请求发送者与接收者解耦</p>
<p><strong>命令模式可以将请求发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求</strong>。</p>
<pre><code>在命令模式结构图中包含如下几个角色：
   ● Command（抽象命令类）：抽象命令类一般是一个抽象类或接口，在其中声明了用于执行请求的execute()等方法，通过这些方法可以调用请求接收者的相关操作。
   ● ConcreteCommand（具体命令类）：具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中。在实现execute()方法时，将调用接收者对象的相关操作(Action)。
   ● Invoker（调用者）：调用者即请求发送者，它通过命令对象来执行请求。一个调用者并不需要在设计时确定其接收者，因此它只与抽象命令类之间存在关联关系。在程序运行时可以将一个具体命令对象注入其中，再调用具体命令对象的execute()方法，从而实现间接调用请求接收者的相关操作。
   ● Receiver（接收者）：接收者执行与请求相关的操作，它具体实现对请求的业务处理。
   命令模式的本质是对请求进行封装，一个请求对应于一个命令，将发出命令的责任和执行命令的责任分割开。每一个命令都是一个操作：请求的一方发出请求要求执行一个操作；接收的一方收到请求，并执行相应的操作。命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求如何被接收、操作是否被执行、何时被执行，以及是怎么被执行的。
   命令模式的关键在于引入了抽象命令类，请求发送者针对抽象命令类编程，只有实现了抽象命令类的具体命令才与请求接收者相关联。在最简单的抽象命令类中只包含了一个抽象的execute()方法，每个具体命令类将一个Receiver类型的对象作为一个实例变量进行存储，从而具体指定一个请求的接收者，不同的具体命令类提供了execute()方法的不同实现，并调用不同接收者的请求处理方法。
</code></pre><p>这里的调用者就是MapperProxy</p>
<p>接受者是DefaultSqlSession</p>
<p>而具体的命令类是MapperMethod</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2017/11/26/MapperMethod/" data-id="cjb52pqz30007gkbzm5uzzli2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Mybatis插件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/22/Mybatis插件/" class="article-date">
  <time datetime="2017-11-22T15:52:37.741Z" itemprop="datePublished">2017-11-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Mybatis/">Mybatis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/22/Mybatis插件/">Mybatis插件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>前言：最近项目有个需求，需要将所有产品的ID和Name组成Map传递到前台,以ID为key，以Name为Value。</p>
<p>即需要达到可以通过map.get(id)方便地获取name的值的效果。</p>
<p>然后就开始测试在Mybatis中哪种方法可行。首先看看直接使用resultType=”map”</p>
<p>Mapper文件如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">"testMap"</span> resultType=<span class="string">"map"</span>&gt;</span><br><span class="line"> select    id,name from coach </span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<p>CoachDao接口定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Map&lt;Object, Object&gt; testMap();</span><br></pre></td></tr></table></figure>
<p>测试方法如下：特意没有引入Spring，只有Mybatis方便DebugMybatis源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testMap() &#123;</span><br><span class="line">	SqlSession session = null;</span><br><span class="line">	System.out.println(&quot;Dd&quot;);</span><br><span class="line">	try &#123;</span><br><span class="line"></span><br><span class="line">		session = MybatisUtil.getCurrentSession();</span><br><span class="line">		CoachDao mapper = session.getMapper(CoachDao.class);</span><br><span class="line">		Map&lt;Object, Object&gt; map = mapper.testMap();</span><br><span class="line">		System.out.println(JSON.toJSONString(map));</span><br><span class="line"></span><br><span class="line">	&#125; catch (Exception e) &#123;</span><br><span class="line">		// TODO: handle exception</span><br><span class="line">		logger.error(&quot;testMap Error:&#123;&#125;&quot;, e);</span><br><span class="line">	&#125; finally &#123;</span><br><span class="line">		session.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们debug观察下这次sql的执行过程。</p>
<p>我们从debug到MapperMethod这个类开始看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public Object execute(SqlSession sqlSession, Object[] args) &#123;</span><br><span class="line">   Object result;</span><br><span class="line">   if (SqlCommandType.INSERT == command.getType()) &#123;</span><br><span class="line">     Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">     result = rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">   &#125; else if (SqlCommandType.UPDATE == command.getType()) &#123;</span><br><span class="line">     Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">     result = rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">   &#125; else if (SqlCommandType.DELETE == command.getType()) &#123;</span><br><span class="line">     Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">     result = rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">   &#125; else if (SqlCommandType.SELECT == command.getType()) &#123;</span><br><span class="line">     if (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">       executeWithResultHandler(sqlSession, args);</span><br><span class="line">       result = null;</span><br><span class="line">     &#125; else if (method.returnsMany()) &#123;</span><br><span class="line">       result = executeForMany(sqlSession, args);</span><br><span class="line">     &#125; else if (method.returnsMap()) &#123;</span><br><span class="line">       result = executeForMap(sqlSession, args);</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">       result = sqlSession.selectOne(command.getName(), param);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     throw new BindingException(&quot;Unknown execution method for: &quot; + command.getName());</span><br><span class="line">   &#125;</span><br><span class="line">   if (result == null &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</span><br><span class="line">     throw new BindingException(&quot;Mapper method &apos;&quot; + command.getName() </span><br><span class="line">         + &quot; attempted to return null from a method with a primitive return type (&quot; + method.getReturnType() + &quot;).&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   return result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>显然我们这里执行的是SqlCommandType.SELECT == command.getType()这一个分支的。</p>
<p>我们看看这个分支的流程，首先要判断是否参数中包含ResultHandler类型的参数，</p>
<p>然后判断是否是返回Collection容器类型或者数组类型，</p>
<p>接着判断是否Method方法参数中带有@MapKey注解且返回类型为Map,看到这里我们会想到这个是否能够实现我们想要的功能呢，这个我们接下来会测试。</p>
<p>然后终于到达我们我们要走的分支</p>
<p>执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = sqlSession.selectOne(command.getName(), param);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">selectOne</span><span class="params">(String statement, Object parameter)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Popular vote was to return null on 0 results and throw exception on too many.</span></span><br><span class="line">  List&lt;T&gt; list = <span class="keyword">this</span>.&lt;T&gt;selectList(statement, parameter);</span><br><span class="line">  <span class="keyword">if</span> (list.size() == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> TooManyResultsException(<span class="string">"Expected one result (or null) to be returned by selectOne(), but found: "</span> + list.size());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现实际上Mybatis给我们返回的是一个List，只不过当执行selectOne时，需要sql执行后返回的List集合中只有一个元素。而在这里我们知道上面的sql返回的是多行结果集，而多行结果集在没有经过插件处理的时候显然返回的List中有多个结果，这个时候就会报错。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.ibatis.exceptions.TooManyResultsException: <span class="function">Expected one <span class="title">result</span> <span class="params">(or <span class="keyword">null</span>)</span> to be returned by <span class="title">selectOne</span><span class="params">()</span>, but found: 13</span></span><br></pre></td></tr></table></figure>
<p>所以第一种方案不行。</p>
<p>那我们把方法的返回类型改一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Map&lt;Object, Object&gt;&gt; testMap();</span><br></pre></td></tr></table></figure>
<p>可以保证程序正确运行，但是是List类型返回值而且其中的每一个Map是由两个元素构成的，分别以ID和NAME为键，即（”id”:123）、(“name”:”Jack”)的形式保存在Map中的。与我们想要的Map结构也不相同，虽然可以转化为我们想要的Map，但是这种转化不是很优雅，我们得找到一个更优雅更通用的方法。</p>
<ul>
<li><p>MapKey注解</p>
<p>​    那我们接着来试试之前用到的MapKey注解看能不能达到我想要的效果呢，查阅相关资料，我们开始尝试。</p>
<p>我们更改方法,将方法带上注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MapKey</span>(<span class="string">"ID"</span>)</span><br><span class="line"><span class="keyword">public</span> Map&lt;Integer, Map&lt;String, Object&gt;&gt; testMapKey();</span><br></pre></td></tr></table></figure>
<p>@MapKey(“ID”)这个注解表示最外层Map的key为查询结果中字段名为“id”的值。</p>
<p>那此刻只要Mybatis有把Value设为查询结果中的name字段的值不就好了吗。</p>
<p>但是很遗憾的是，Mybatis并没有直接实现这个功能。</p>
<p>我们看selectMap源码，当我们在没有对查询结果使用插件的时候，我们存进Map的Value只能是我们查询结果集的指定返回类型。而我们这里resultType=“map”，也就是说返回的类型就是Map。那你说我们把resultType=“string”就可以了把，很显然，这里存在问题，因为我们的结果包含两列，不可能做到resulType=“string” 。所以使用MapKey注解也是无法达到我们想要的效果的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public &lt;K, V&gt; Map&lt;K, V&gt; selectMap(String statement, Object parameter, String mapKey, RowBounds rowBounds) &#123;</span><br><span class="line">  final List&lt;?&gt; list = selectList(statement, parameter, rowBounds);</span><br><span class="line">  final DefaultMapResultHandler&lt;K, V&gt; mapResultHandler = new DefaultMapResultHandler&lt;K, V&gt;(mapKey,</span><br><span class="line">      configuration.getObjectFactory(), configuration.getObjectWrapperFactory());</span><br><span class="line">  final DefaultResultContext context = new DefaultResultContext();</span><br><span class="line">  for (Object o : list) &#123;</span><br><span class="line">    context.nextResultObject(o);</span><br><span class="line">    mapResultHandler.handleResult(context);</span><br><span class="line">  &#125;</span><br><span class="line">  Map&lt;K, V&gt; selectedMap = mapResultHandler.getMappedResults();</span><br><span class="line">  return selectedMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看看使用MapKey注解的返回情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">==&gt;  Preparing: select id,name from coach </span><br><span class="line">==&gt; Parameters: </span><br><span class="line">&lt;==    Columns: ID, NAME</span><br><span class="line">&lt;==        Row: <span class="number">12</span>, phil jackson</span><br><span class="line">&lt;==        Row: <span class="number">17</span>, phil jackson</span><br><span class="line">&lt;==        Row: <span class="number">1</span>, jackson</span><br><span class="line">&lt;==        Row: <span class="number">14</span>, phil jackson</span><br><span class="line">&lt;==        Row: <span class="number">18</span>, phil jackson</span><br><span class="line">&lt;==        Row: <span class="number">2</span>, jackson</span><br><span class="line">&lt;==        Row: <span class="number">10</span>, jackson</span><br><span class="line">&lt;==        Row: <span class="number">13</span>, phil jackson</span><br><span class="line">&lt;==        Row: <span class="number">15</span>, phil jackson</span><br><span class="line">&lt;==        Row: <span class="number">16</span>, phil jackson1</span><br><span class="line">&lt;==        Row: <span class="number">5</span>, jackson</span><br><span class="line">&lt;==        Row: <span class="number">3</span>, jackson</span><br><span class="line">&lt;==        Row: <span class="number">11</span>, jackson</span><br><span class="line">&lt;==      Total: <span class="number">13</span></span><br><span class="line">&#123;<span class="number">1</span>:&#123;<span class="string">"ID"</span>:<span class="number">1</span>,<span class="string">"NAME"</span>:<span class="string">"jackson"</span>&#125;,<span class="number">2</span>:&#123;<span class="string">"ID"</span>:<span class="number">2</span>,<span class="string">"NAME"</span>:<span class="string">"jackson"</span>&#125;,<span class="number">3</span>:&#123;<span class="string">"ID"</span>:<span class="number">3</span>,<span class="string">"NAME"</span>:<span class="string">"jackson"</span>&#125;,<span class="number">5</span>:&#123;<span class="string">"ID"</span>:<span class="number">5</span>,<span class="string">"NAME"</span>:<span class="string">"jackson"</span>&#125;,<span class="number">10</span>:&#123;<span class="string">"ID"</span>:<span class="number">10</span>,<span class="string">"NAME"</span>:<span class="string">"jackson"</span>&#125;,<span class="number">11</span>:&#123;<span class="string">"ID"</span>:<span class="number">11</span>,<span class="string">"NAME"</span>:<span class="string">"jackson"</span>&#125;,<span class="number">12</span>:&#123;<span class="string">"ID"</span>:<span class="number">12</span>,<span class="string">"NAME"</span>:<span class="string">"phil jackson"</span>&#125;,<span class="number">13</span>:&#123;<span class="string">"ID"</span>:<span class="number">13</span>,<span class="string">"NAME"</span>:<span class="string">"phil jackson"</span>&#125;,<span class="number">14</span>:&#123;<span class="string">"ID"</span>:<span class="number">14</span>,<span class="string">"NAME"</span>:<span class="string">"phil jackson"</span>&#125;,<span class="number">15</span>:&#123;<span class="string">"ID"</span>:<span class="number">15</span>,<span class="string">"NAME"</span>:<span class="string">"phil jackson"</span>&#125;,<span class="number">16</span>:&#123;<span class="string">"ID"</span>:<span class="number">16</span>,<span class="string">"NAME"</span>:<span class="string">"phil jackson1"</span>&#125;,<span class="number">17</span>:&#123;<span class="string">"ID"</span>:<span class="number">17</span>,<span class="string">"NAME"</span>:<span class="string">"phil jackson"</span>&#125;,<span class="number">18</span>:&#123;<span class="string">"ID"</span>:<span class="number">18</span>,<span class="string">"NAME"</span>:<span class="string">"phil jackson"</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>从结果集我们可以看出，以ID作为Key，但是Value是上面一种情况的Map集合，结构仍然为（（”id”:123）、(“name”:”Jack”)）显然是不符合要求的。</p>
</li>
</ul>
<p>也就是说，很遗憾，我们的这种需求Mybatis并没有直接的支持，那我们该怎么办呢，这时候就需要用到Mybatis留给我们的重要接口Mybatis中的拦截器，通过使用提供给用户可以自定义实现特殊功能，其功能特别强大。我们可以在Mybatis最重要的四大组件中使用拦截器（通过动态代理和反射注解等技术实现,这三个技术就是框架的核心，其定义就不多说了），让我们能够自定义的对四大组件的功能进行丰富和更改等。</p>
<p>在说拦截器之前，我们需要说一下四大组件</p>
<p>这部分后续补充</p>
<h3 id="二-Mybatis中的拦截器"><a href="#二-Mybatis中的拦截器" class="headerlink" title="二.Mybatis中的拦截器"></a>二.Mybatis中的拦截器</h3><p>现在我们来看Mybatis中的拦截器，Mybatis很贴心的为我们提供了Interceptor接口，作为一个优秀的开源框架，Mybatis和Spring一样都很好的遵守了开闭原则。基本都是面向接口的编程，特别是Spring，你会发现是Spring中大量的运用了模板方法模式来设计。在Mybatis中，我们要自定义我们的拦截器只需要实现这个接口。那我们首先就来瞅瞅这个接口都定义了哪些方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Object <span class="title">plugin</span><span class="params">(Object target)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>plugin方法是拦截器用于封装目标对象的，通过该方法我们可以返回目标对象本身，也可以返回一个它的代理。当返回的是代理的时候我们可以对其中的方法进行拦截来调用intercept方法(因为intercept方法的参数Invocation封装了原对象的相关信息)，当然也可以调用其他方法。setProperties方法是用于在Mybatis配置文件中指定一些属性的。       定义自己的Interceptor最重要的是要实现plugin方法和intercept方法，在plugin方法中我们可以决定是否要进行拦截进而决定要返回一个什么样的目标对象。而intercept方法就是要进行拦截的时候要执行的方法。而对于plugin方法而言，其实Mybatis已经为我们提供了一个实现。Mybatis中有一个叫做Plugin的类，里面有一个静态方法wrap(Object target,Interceptor interceptor)，通过该方法可以决定要返回的对象是目标对象还是对应的代理。Mybatis已经尽可能的帮我们做的更多了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">public class Plugin implements InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">  private Object target;</span><br><span class="line">  private Interceptor interceptor;</span><br><span class="line">  private Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap;</span><br><span class="line"></span><br><span class="line">  private Plugin(Object target, Interceptor interceptor, Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap) &#123;</span><br><span class="line">    this.target = target;</span><br><span class="line">    this.interceptor = interceptor;</span><br><span class="line">    this.signatureMap = signatureMap;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static Object wrap(Object target, Interceptor interceptor) &#123;</span><br><span class="line">    Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor);</span><br><span class="line">    Class&lt;?&gt; type = target.getClass();</span><br><span class="line">    Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);</span><br><span class="line">    if (interfaces.length &gt; 0) &#123;</span><br><span class="line">      return Proxy.newProxyInstance(</span><br><span class="line">          type.getClassLoader(),</span><br><span class="line">          interfaces,</span><br><span class="line">          new Plugin(target, interceptor, signatureMap));</span><br><span class="line">    &#125;</span><br><span class="line">    return target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass());</span><br><span class="line">      if (methods != null &amp;&amp; methods.contains(method)) &#123;</span><br><span class="line">        return interceptor.intercept(new Invocation(target, method, args));</span><br><span class="line">      &#125;</span><br><span class="line">      return method.invoke(target, args);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      throw ExceptionUtil.unwrapThrowable(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private static Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; getSignatureMap(Interceptor interceptor) &#123;</span><br><span class="line">    Intercepts interceptsAnnotation = interceptor.getClass().getAnnotation(Intercepts.class);</span><br><span class="line">    if (interceptsAnnotation == null) &#123; // issue #251</span><br><span class="line">      throw new PluginException(&quot;No @Intercepts annotation was found in interceptor &quot; + interceptor.getClass().getName());      </span><br><span class="line">    &#125;</span><br><span class="line">    Signature[] sigs = interceptsAnnotation.value();</span><br><span class="line">    Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = new HashMap&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt;();</span><br><span class="line">    for (Signature sig : sigs) &#123;</span><br><span class="line">      Set&lt;Method&gt; methods = signatureMap.get(sig.type());</span><br><span class="line">      if (methods == null) &#123;</span><br><span class="line">        methods = new HashSet&lt;Method&gt;();</span><br><span class="line">        signatureMap.put(sig.type(), methods);</span><br><span class="line">      &#125;</span><br><span class="line">      try &#123;</span><br><span class="line">        Method method = sig.type().getMethod(sig.method(), sig.args());</span><br><span class="line">        methods.add(method);</span><br><span class="line">      &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">        throw new PluginException(&quot;Could not find method on &quot; + sig.type() + &quot; named &quot; + sig.method() + &quot;. Cause: &quot; + e, e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return signatureMap;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private static Class&lt;?&gt;[] getAllInterfaces(Class&lt;?&gt; type, Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap) &#123;</span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; interfaces = new HashSet&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">    while (type != null) &#123;</span><br><span class="line">      for (Class&lt;?&gt; c : type.getInterfaces()) &#123;</span><br><span class="line">        if (signatureMap.containsKey(c)) &#123;</span><br><span class="line">          interfaces.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      type = type.getSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">    return interfaces.toArray(new Class&lt;?&gt;[interfaces.size()]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先看一下Plugin的wrap方法，它根据当前的Interceptor上面的注解定义哪些接口需要拦截，然后判断当前目标对象是否有实现对应需要拦截的接口，如果没有则返回目标对象本身，如果有则返回一个代理对象。而这个代理对象的InvocationHandler正是一个Plugin。所以当目标对象在执行接口方法时，如果是通过代理对象执行的，则会调用对应InvocationHandler的invoke方法，也就是Plugin的invoke方法。(至于到底为什么会调用这个方法，我相信其实有不少人都不是真的明白，这个我在之前的博客中有说过，因为在调用代理对象的方法的时候实际上调用的就是InvocationHandler的invoke方法，InvocationHandler对象作为代理对象的构造器参数注入，要彻底明白</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">         type.getClassLoader(),</span><br><span class="line">         interfaces,</span><br><span class="line">         <span class="keyword">new</span> Plugin(target, interceptor, signatureMap));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这句话到底做了什么才能彻底理解JDK动态代理</p>
<p>)所以接着我们来看一下该invoke方法的内容。这里invoke方法的逻辑是：如果当前执行的方法是定义好的需要拦截的方法，则把目标对象、要执行的方法以及方法参数封装成一个Invocation对象，再把封装好的Invocation作为参数传递给当前拦截器的intercept方法。如果不需要拦截，则直接调用当前的方法。Invocation中定义了定义了一个proceed方法，其逻辑就是调用当前方法，所以如果在intercept中需要继续调用当前方法的话可以调用invocation的procced方法。</p>
<p>​       这就是Mybatis中实现Interceptor拦截的一个思想，如果用户觉得这个思想有问题或者不能完全满足你的要求的话可以通过实现自己的Plugin来决定什么时候需要代理什么时候需要拦截。以下讲解的内容都是基于Mybatis的默认实现即通过Plugin来管理Interceptor来讲解的。</p>
<p>​       对于实现自己的Interceptor而言有两个很重要的注解，一个是@Intercepts，其值是一个@Signature数组。@Intercepts用于表明当前的对象是一个Interceptor，而@Signature则表明要拦截的接口、方法以及对应的参数类型。</p>
<p>那在真正的去写自己的拦截器之前，我们必须得要知道Mybatis拦截器应该作用在什么地方。</p>
<p>而他又是怎么起作用的。之前我们说过Mybatis拦截器主要是作用在四大组件上的,那么是怎么起作用的呢。</p>
<p>我们还是看源码。</p>
<p>我们在执行一次SQL过程中进行debug，当debug到SimpleExecutor执行器时，执行了doQuery方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException &#123;</span><br><span class="line">  Statement stmt = null;</span><br><span class="line">  try &#123;</span><br><span class="line">    Configuration configuration = ms.getConfiguration();</span><br><span class="line">    StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">    return handler.&lt;E&gt;query(stmt, resultHandler);</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    closeStatement(stmt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们主要看这行代码：</p>
<p>这行代码实际上生生成了除了执行器的其他三大组件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public StatementHandler newStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) &#123;</span><br><span class="line">  StatementHandler statementHandler = new RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">  statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br><span class="line">  return statementHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先new RoutingStatementHandler();看这个类的源码，发现实际上生成了delegate属性的StatementHandler对象,而且实际上的StatementHandler这个组件的方法执行就是执行delegate的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public RoutingStatementHandler(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) &#123;</span><br><span class="line"></span><br><span class="line">   switch (ms.getStatementType()) &#123;</span><br><span class="line">     case STATEMENT:</span><br><span class="line">       delegate = new SimpleStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">       break;</span><br><span class="line">     case PREPARED:</span><br><span class="line">       delegate = new PreparedStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">       break;</span><br><span class="line">     case CALLABLE:</span><br><span class="line">       delegate = new CallableStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">       break;</span><br><span class="line">     default:</span><br><span class="line">       throw new ExecutorException(&quot;Unknown statement type: &quot; + ms.getStatementType());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>我们看构造方法总共有三个可选的StatementHandler。</p>
<p>我们发现这三个StatementHandler都继承了BaseStatementHandler,我们知道在创建一个子类实例对象是一定会先执行父类的构造方法，那我们来看看BaseStatementHandler的构造方法都做了什么工作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">protected BaseStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) &#123;</span><br><span class="line">  this.configuration = mappedStatement.getConfiguration();</span><br><span class="line">  this.executor = executor;</span><br><span class="line">  this.mappedStatement = mappedStatement;</span><br><span class="line">  this.rowBounds = rowBounds;</span><br><span class="line"></span><br><span class="line">  this.typeHandlerRegistry = configuration.getTypeHandlerRegistry();</span><br><span class="line">  this.objectFactory = configuration.getObjectFactory();</span><br><span class="line"></span><br><span class="line">  if (boundSql == null) &#123; // issue #435, get the key before calculating the statement</span><br><span class="line">    generateKeys(parameterObject);</span><br><span class="line">    boundSql = mappedStatement.getBoundSql(parameterObject);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.boundSql = boundSql;</span><br><span class="line"></span><br><span class="line">  this.parameterHandler = configuration.newParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">  this.resultSetHandler = configuration.newResultSetHandler(executor, mappedStatement, rowBounds, parameterHandler, resultHandler, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看这个类的源码，我们会发现，她包含了其他两个组件，并且在构造方法里创建了这两个组件实现类的对象。</p>
<p>我们查看具体创建组件对象的源码，我们都会调用 interceptorChain.pluginAll方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public ParameterHandler newParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql) &#123;</span><br><span class="line">    ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">    parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);</span><br><span class="line">    return parameterHandler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public ResultSetHandler newResultSetHandler(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler,</span><br><span class="line">      ResultHandler resultHandler, BoundSql boundSql) &#123;</span><br><span class="line">    ResultSetHandler resultSetHandler = new DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);</span><br><span class="line">    resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);</span><br><span class="line">    return resultSetHandler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public StatementHandler newStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) &#123;</span><br><span class="line">    StatementHandler statementHandler = new RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">    statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br><span class="line">    return statementHandler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Executor newExecutor(Transaction transaction) &#123;</span><br><span class="line">    return newExecutor(transaction, defaultExecutorType);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Executor newExecutor(Transaction transaction, ExecutorType executorType) &#123;</span><br><span class="line">    executorType = executorType == null ? defaultExecutorType : executorType;</span><br><span class="line">    executorType = executorType == null ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    if (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">      executor = new BatchExecutor(this, transaction);</span><br><span class="line">    &#125; else if (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">      executor = new ReuseExecutor(this, transaction);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      executor = new SimpleExecutor(this, transaction);</span><br><span class="line">    &#125;</span><br><span class="line">    if (cacheEnabled) &#123;</span><br><span class="line">      executor = new CachingExecutor(executor);</span><br><span class="line">    &#125;</span><br><span class="line">    executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    return executor;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>终于找到了使用拦截器的地方了。</p>
<p>我们看看InterceptorChain的源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorChain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;Interceptor&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">      target = interceptor.plugin(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptor</span><span class="params">(Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">    interceptors.add(interceptor);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Interceptor&gt; <span class="title">getInterceptors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableList(interceptors);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类是收集所有拦截器的类，那如何收集所有的拦截器呢，通过配置文件加载到Configuration对象中。</p>
<p>通过如下方式写入Mybatis配置文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">      &lt;plugins&gt;  </span><br><span class="line">        &lt;plugin interceptor=&quot;com.wangcc.ssm.mybatis.interceptor.PageInterceptor&quot;&gt;  </span><br><span class="line">           &lt;property name=&quot;databaseType&quot; value=&quot;Oracle&quot;/&gt;  </span><br><span class="line">       &lt;/plugin&gt;  </span><br><span class="line">   &lt;plugin interceptor=&quot;com.wangcc.ssm.mybatis.interceptor.ParamMapInterceptor&quot;/&gt;  </span><br><span class="line">&lt;/plugins&gt;</span><br></pre></td></tr></table></figure>
<h3 id="三-实现自己的Mybatis拦截器"><a href="#三-实现自己的Mybatis拦截器" class="headerlink" title="三.实现自己的Mybatis拦截器"></a>三.实现自己的Mybatis拦截器</h3><p>好了，回到我们要解决的需求，我们要通过Mybatis拦截器来解决问题了。</p>
<p>通过前面几种情况，我们知道了，Mybatis自带的返回类型处理不能满足我们这个需求的要求。所以我们理所当然的想到，我们使用拦截器的目标是ResultSetHandler。我们知道返回结果是由ResultSetHandler的handleResultSets方法对当前的Statement处理后的返回结果，所以我们如果要改变返回结果的话就需要使用Mybatis的拦截器对ResultSetHandler接口的handleResultSets方法进行拦截。</p>
<p>这个时候我们就确定了该拦截器的注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts</span>(<span class="meta">@Signature</span>(method = <span class="string">"handleResultSets"</span>, type = ResultSetHandler.class, args = &#123; Statement.class &#125;))</span><br></pre></td></tr></table></figure>
<p>在之前分析四大组件对象生成时，说过每一个对象都要调用interceptorChain.pluginAll方法，这里的注解中的type = ResultSetHandler.class会使该拦截器只作用在ResultSetHandler上，但是目前来会对每一个ResultSetHandler都会起作用，所以我们还得在这个拦截器中想办法再做一层过滤，对于不需要拦截的调用Invocation的proceed()方法，而需要拦截的则实现我们自己的逻辑，返回对应的结果。现在我们要想的是怎么做这一层过滤以及怎么实现改变返回结果的效果。</p>
<ul>
<li><p>首先，这个过滤该怎样来实现呢，一般来说，通过parameterObj来过滤， 通过ParameterHandler得到：parameterHandler.getParameterObject();（我们定义的Dao层方法的参数）</p>
<p>​    那这里我们需要给出一个怎样的参数呢：</p>
<p>​    首先他得满足这几个条件</p>
<ul>
<li>（1）    可以指定哪个字段为返回Map的Key；</li>
<li>（2）    可以指定哪个字段为返回Map的Value；</li>
<li>（3）    可以附带其他参数；</li>
</ul>
</li>
</ul>
<p>那我们这里就给出我定义的参数ComplexParamMap</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComplexParamMap</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ParamMap paramMap;</span><br><span class="line">	<span class="keyword">private</span> T obj;<span class="comment">// 使用实体类的属性作为查询参数</span></span><br><span class="line">	<span class="keyword">private</span> Map&lt;String, Object&gt; params = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();<span class="comment">// 其他的参数我们把它分装成一个Map对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParamMap</span> <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 作为Key的字段对应MapParam的Key</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_FIELD = <span class="string">"mapKeyField"</span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 作为Value的字段对应MapParam的Key</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String VALUE_FIELD = <span class="string">"mapValueField"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ParamMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 指定keyField和valueField</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> keyField</span></span><br><span class="line"><span class="comment">	 *            Map中key对应的字段</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> valueField</span></span><br><span class="line"><span class="comment">	 *            Map中value对应的字段</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ParamMap</span><span class="params">(String keyField, String valueField)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.put(KEY_FIELD, keyField);</span><br><span class="line">		<span class="keyword">this</span>.put(VALUE_FIELD, valueField);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用泛型，方便 使用实体类的属性作为查询参数。</p>
<p>定义一个HashMap params 方便我们加入一些独立参数来作为查询参数。</p>
<p>ParamMap paramMap; 指定对应字段为返回Map的Key和Value；</p>
<ul>
<li><p>确定了过滤条件之后,我们就可以开始处理我们的逻辑了。</p>
<p>​    </p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts</span>(<span class="meta">@Signature</span>(method = <span class="string">"handleResultSets"</span>, type = ResultSetHandler.class, args = &#123; Statement.class &#125;))</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParamMapInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(ParamMapInterceptor.class);</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		Object target = invocation.getTarget();</span><br><span class="line">			<span class="comment">//目前Mybatis只有DefaultResultSetHandler这一种ResultSetHandler实现类</span></span><br><span class="line">      <span class="keyword">if</span> (target <span class="keyword">instanceof</span> DefaultResultSetHandler) &#123;</span><br><span class="line">          </span><br><span class="line">			DefaultResultSetHandler resultSetHandler = (DefaultResultSetHandler) target;</span><br><span class="line"></span><br><span class="line">			ParameterHandler parameterHandler = ReflectUtil.getFieldValue(resultSetHandler, <span class="string">"parameterHandler"</span>);</span><br><span class="line">			Object parameterObj = parameterHandler.getParameterObject();</span><br><span class="line">			<span class="keyword">if</span> (parameterObj <span class="keyword">instanceof</span> ComplexParamMap) &#123;</span><br><span class="line">				ComplexParamMap paramMap = (ComplexParamMap) parameterObj;</span><br><span class="line">				Statement stmt = (Statement) invocation.getArgs()[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">				<span class="keyword">return</span> handleResultSet(stmt.getResultSet(), paramMap);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> invocation.proceed();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> Object <span class="title">handleResultSet</span><span class="params">(ResultSet resultSet, ComplexParamMap cmap)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (resultSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">			ParamMap paramMap = cmap.getParamMap();</span><br><span class="line">			String keyField = paramMap.get(ParamMap.KEY_FIELD);</span><br><span class="line">			String valueField = paramMap.get(ParamMap.VALUE_FIELD);</span><br><span class="line">			Map&lt;Object, Object&gt; map = <span class="keyword">new</span> HashMap&lt;Object, Object&gt;();</span><br><span class="line">			<span class="comment">// 因为原方法返回的是List&lt;Object&gt;类型，所以</span></span><br><span class="line">			List&lt;Object&gt; resultList = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">					Object key = resultSet.getObject(keyField);</span><br><span class="line">					Object value = resultSet.getObject(valueField);</span><br><span class="line">					map.put(key, value);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				logger.error(<span class="string">"ParamMapInterceptor 的Method handleResultSet 使用ResultSet时出错"</span>);</span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				closeResultSet(resultSet);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			resultList.add(map);</span><br><span class="line">			<span class="keyword">return</span> resultList;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">closeResultSet</span><span class="params">(ResultSet resultSet)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (resultSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">				resultSet.close();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			logger.error(<span class="string">"关闭ResultSet资源时出错"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到现在我们就算完成了我们的第一个Mybatis拦截器了。</p>
<p>我们将这个拦截器注册到我们的Mybatis配置文件，注意在配置文件中的顺序位置。</p>
<p>然后开始测试，看是否能达到我们的要求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">	public void test() &#123;</span><br><span class="line">		SqlSession session = null;</span><br><span class="line">		System.out.println(&quot;Dd&quot;);</span><br><span class="line">		try &#123;</span><br><span class="line"></span><br><span class="line">			session = MybatisUtil.getCurrentSession();</span><br><span class="line">			CoachDao mapper = session.getMapper(CoachDao.class);</span><br><span class="line">			// Coach coach = mapper.getCoachById(1);</span><br><span class="line">			// System.out.println(coach);</span><br><span class="line">			ComplexParamMap&lt;Coach&gt; cmap = new ComplexParamMap&lt;Coach&gt;();</span><br><span class="line">			Coach coach = new Coach();</span><br><span class="line">			coach.setName(&quot;jackson&quot;);</span><br><span class="line">			ParamMap paramMap = new ParamMap(&quot;name&quot;, &quot;age&quot;);</span><br><span class="line">			cmap.setParamMap(paramMap);</span><br><span class="line">			Map&lt;String, Object&gt; params = new HashMap&lt;String, Object&gt;();</span><br><span class="line">			params.put(&quot;name&quot;, &quot;jackson&quot;);</span><br><span class="line">			cmap.setParams(params);</span><br><span class="line">			cmap.setObj(coach);</span><br><span class="line">			Map&lt;Object, Object&gt; map = mapper.queryMap(cmap);</span><br><span class="line">			System.out.println(JSON.toJSONString(map));</span><br><span class="line">			Page&lt;Coach, ?&gt; page = new Page&lt;&gt;();</span><br><span class="line">			page.setSelf(coach);</span><br><span class="line">			page.setPageSize(4);</span><br><span class="line">			page.setPageNo(2);</span><br><span class="line">			List&lt;Coach&gt; list = mapper.querybyPage(page);</span><br><span class="line">			System.out.println(JSON.toJSONString(list));</span><br><span class="line"></span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			// TODO: handle exception</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; finally &#123;</span><br><span class="line">			session.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>Mapper配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;queryMap&quot; resultType=&quot;map&quot; parameterType=&quot;ComplexParamMap&quot;&gt;</span><br><span class="line">select id,name from coach where name=#&#123;obj.name&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<p>查看输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">==&gt; Parameters: jackson(String)</span><br><span class="line">&lt;==    Columns: ID, NAME</span><br><span class="line">&lt;==        Row: 1, jackson</span><br><span class="line">&lt;==        Row: 2, jackson</span><br><span class="line">&lt;==        Row: 10, jackson</span><br><span class="line">&lt;==        Row: 5, jackson</span><br><span class="line">&lt;==        Row: 3, jackson</span><br><span class="line">&lt;==        Row: 11, jackson</span><br><span class="line">&lt;==      Total: 6</span><br><span class="line">&#123;1:&quot;jackson&quot;,2:&quot;jackson&quot;,3:&quot;jackson&quot;,5:&quot;jackson&quot;,10:&quot;jackson&quot;,11:&quot;jackson&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>完美的结果。</p>
<p>接下来我们再看下在Mybatis中使用广泛的分页插件拦截器。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2017/11/22/Mybatis插件/" data-id="cjbkujwuj0001ocbz8q6bt4rn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-HashMap" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/19/HashMap/" class="article-date">
  <time datetime="2017-11-19T10:15:42.019Z" itemprop="datePublished">2017-11-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java基础/">Java基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/19/HashMap/">HashMap</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="JDK7"><a href="#JDK7" class="headerlink" title="JDK7"></a>JDK7</h3><p>之前用JDK7的源码分析过一次HashMap,但是分析的并不完善，只分析了put方法和get方法，有一个很重要的方法 resize()方法并没有分析。</p>
<p>扩容方法resize()方法是一个很重要的方法，当我们调用put方法的时候，如果Hash数组的实际大小已经大于加载因子*容量的时候，我们就需要进行扩容操作，防止Hash冲突堆积太多，影响效率。 </p>
<p>jdk version:jdk1.7.0.0_76</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">           inflateTable(threshold);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">       <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">       <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">       <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">           Object k;</span><br><span class="line">           <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">               V oldValue = e.value;</span><br><span class="line">               e.value = value;</span><br><span class="line">               e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       modCount++;</span><br><span class="line">       addEntry(hash, key, value, i);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">    <span class="comment">//为什么不要移位操作&lt;&lt;</span></span><br><span class="line">    resize(<span class="number">2</span> * table.length);</span><br><span class="line">           hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">           bucketIndex = indexFor(hash, table.length);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       createEntry(hash, key, value, bucketIndex);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>我们看下这个方法的具体实现，然后看看在JDK8中是如何进行改进的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">       Entry[] oldTable = table;</span><br><span class="line">       <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="comment">//如果原来的容量已经是最大容量了,就只能任由他进行HASH碰撞</span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">           threshold = Integer.MAX_VALUE;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">       transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">       table = newTable;</span><br><span class="line">       threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line"><span class="comment">//对Hash数组进行遍历，所有元素遍历</span></span><br><span class="line">     <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">       <span class="comment">//对Hash数组每个元素后面带着的链表进行遍历，采用头插法将元素插入到新的Hash表中。    </span></span><br><span class="line">       <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">         <span class="comment">//先将e的下一个节点保存起来</span></span><br><span class="line">               Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">               <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                   e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">               &#125;</span><br><span class="line">         <span class="comment">//得到节点对应的hash数组的位置</span></span><br><span class="line">               <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">               <span class="comment">//开始头插</span></span><br><span class="line">         <span class="comment">//当前节点的next节点指向原头节点</span></span><br><span class="line">         </span><br><span class="line">         		e.next = newTable[i];</span><br><span class="line">         <span class="comment">//将当前节点置为头结点      </span></span><br><span class="line">         newTable[i] = e;</span><br><span class="line">         	<span class="comment">//将之前保存起来的next节点赋给e，开始下一个重复步骤进行头插</span></span><br><span class="line">               e = next;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>我们看到在JDK7中使用的resize()方法是对一个每个元素都进行重新找到在新的Hash数组的位置，采用的是头插法，也就是说将所有的元素都倒置了。</p>
<h3 id="JDK8"><a href="#JDK8" class="headerlink" title="JDK8"></a>JDK8</h3><p>HashMap和ConcurrentHashMap在JDK8中都进行了巨大的改变。</p>
<p>在HashMap中，为了增加插入删除等操作的效率，我们的HashMap在JDK8中的底层数据结构中增加了红黑树数据结构，当Hash数组的某个元素的链表长度大于8且数组大小大于。。。时，链表会变成红黑树，当链表长度大于8但长度没有超过。。。时会先执行扩容操作，而当扩容的时候，如果发现某个红黑树结构的元素个数小于6时，红黑树又会变成链表，这个具体实现，我们后面再说。</p>
<p>那么为什么我们要选用红黑树这种比较复杂的数据结构呢？</p>
<p>至于树形数据结构对于数组或者链表的优点，我们可以很简单的得出。</p>
<p>但是为什么是选择了红黑树而不是AVL（二叉平衡树）呢。这个就需要我们好好想想了。</p>
<p>红黑树的查询性能略逊色于AVL树，因为他比AVL树会稍微不平衡，也就是说红黑树的查询性能只比相同内容的avl树最多多一次比较，但是，红黑树在插入和删除上完爆avl树，avl树每次插入删除会进行大量的</p>
<p>平衡度计算，而红黑树为了维持红黑性质所做的红黑变换和旋转的开销，相较于avl树为了维持平衡的开销要小得多。</p>
<p>当然，红黑树并不适应所有应用树的领域。如果数据基本上是静态的，那么让他们待在他们能够插入，并且不影响平衡的地方会具有更好的性能。如果数据完全是静态的，例如，做一个哈希表，性能可能会更好一些。</p>
<p>在实际的系统中，例如，需要使用动态规则的防火墙系统，使用红黑树而不是散列表被实践证明具有更好的伸缩性。</p>
<p>简单说，如果你的应用中，搜索的次数远远大于插入和删除，那么选择AVL，如果搜索，插入删除次数几乎差不多，应该选择RB。</p>
<p><strong>红黑树是牺牲了严格的高度平衡的优越条件</strong>为 代价红黑树能够以O(log2 n)的时间复杂度进行搜索、插入、删除操作。此外，由于它的设计，任何不平衡都会在三次旋转之内解决。当然，还有一些更好的，但实现起来更复杂的数据结构 能够做到一步旋转之内达到平衡，但红黑树能够给我们一个比较“便宜”的解决方案。红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更高. </p>
<ul>
<li><p>Node内部类</p>
<p>我们先来看看HashMap的Hash数组的元素的数据结构是怎样的，在JDK7以及以前的版本中，都是使用的Entry作为元素，但是在JDK8中是使用Node,当然他肯定还是得实现Map.Entry\<k,v>这个接口</k,v></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h3><p>我们先关注put方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line">       <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">         <span class="comment">//先看table有没有初始化，没有的话初始化一个Hash数组</span></span><br><span class="line">       <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">           n = (tab = resize()).length;</span><br><span class="line">         <span class="comment">//如果数组元素没有被占用，则该节点赋给该数组元素，即为该数组元素后面的链表的头结点</span></span><br><span class="line">       <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">           tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           Node&lt;K,V&gt; e; K k;</span><br><span class="line">         <span class="comment">//如果链表头结点（Hash数组元素）的key与我们要插入的key相同，可以直接替换value</span></span><br><span class="line">           <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">               ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">               e = p;</span><br><span class="line">         <span class="comment">//如果不是头节点key相同，而且是红黑树类型节点,调用红黑树类型的插入方式</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">               e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">//如果不是直接替换头结点，那么开始进行咔咔的遍历</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                 <span class="comment">//当遍历完了之后还是没找着</span></span><br><span class="line">                   <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="comment">//新建一个node节点指向原最后一个节点的next节点</span></span><br><span class="line">                       p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                     <span class="comment">//如果遍历玩还没找到而且元素大于7了，厉害了，开始变身TreeNode，变成红黑树结构</span></span><br><span class="line">                       <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                           treeifyBin(tab, hash);</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                 <span class="comment">//如果遍历的过程中找到了key相同的，跳出循环</span></span><br><span class="line">                   <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                       ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   p = e;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">         <span class="comment">//然后在这里进行替换原值的操作</span></span><br><span class="line">           <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">               V oldValue = e.value;</span><br><span class="line">               <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                   e.value = value;</span><br><span class="line">               afterNodeAccess(e);</span><br><span class="line">      	<span class="comment">//当e!=null的时候直接返回了，之前我再这里纠结了一下为什么没有++modCount呀</span></span><br><span class="line">             <span class="comment">//fail-fast机制不要遵循了吗</span></span><br><span class="line">             <span class="comment">//仔细一看，扑街，只有当是替换Value的时候，而没有新增的Node节点的时候才会直接返回</span></span><br><span class="line">             <span class="comment">//当是处理TreeNode红黑树节点的时候，方法返回的是null，也就是e==null</span></span><br><span class="line">             <span class="comment">//当需要从链表转化为红黑树的时候，也是新增节点，e指向null的时候才执行。</span></span><br><span class="line">             <span class="comment">//也就是这个方法中所有返回e==null的分支对应的都是新增节点，会在下面的代码中执行++modCount;</span></span><br><span class="line">             <span class="comment">//所有不返回null的分支都对应着修改Value值。</span></span><br><span class="line">             <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        </span><br><span class="line">       ++modCount;</span><br><span class="line">       <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">           resize();</span><br><span class="line">       afterNodeInsertion(evict);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>具体代码就不再次分析了。</p>
<p>put方法的流程：</p>
<p>先确定Key位于哪个Hash桶，如果对应Hash数组中没有元素，直接将这个Node赋给Hash数组中该元素（table[i]=node）,如果找到了对应的Hash桶，如果对应的还是之前的链表结构，则遍历Node链表，如果发现Key已经存在，替换Value,返回，如果没找到，这个时候就需要新增节点了，直接用尾插法插到链表的尾部（这一点和JDK7以及之前插入方法不同，之前的插入方法是头插法）如果链表的长度已经不小于7了，链表的结构要变成红黑树的结构。如果这个hash桶的结构在插入新节点前已经变成了红黑树，则遍历TreeNode组成的红黑树结构，看是否Key已经存在，如果存在则替换，如果没有，则将新节点插入红黑树结构。这个流程我们能够狠轻松的整理出来，但是，如何用代码实现，如何用最少的代码实现，却并没有那么简单。如何用最少的代码，也就是如何找到规律，万物皆有形可测，编写程序就是要找到一些事情的规律，化繁为简。</p>
<ul>
<li>将链表结构改为红黑树结构</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">  <span class="comment">//如果还没有初始化表或者表的长度小于64，那么不急着将链表结构改为红黑树结构，先进行扩容操作。</span></span><br><span class="line">      <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">          resize();</span><br><span class="line">  <span class="comment">//开始转化，转化之前确认这个链表是有元素的</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">          TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//将Node节点转化为TreeNode节点</span></span><br><span class="line">              TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">              <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                  hd = p;</span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//prev是TreeNode的属性</span></span><br><span class="line">                  p.prev = tl;</span><br><span class="line">                <span class="comment">//注意next还是Node的属性</span></span><br><span class="line">                  tl.next = p;</span><br><span class="line">              &#125;</span><br><span class="line">              tl = p;</span><br><span class="line">          &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line"> <span class="comment">//让桶的第一个元素指向新建的红黑树头结点，以后这个桶里的元素就是红黑树而不是链表了</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">              hd.treeify(tab);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">          TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">              next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">              x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">              <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  x.parent = <span class="keyword">null</span>;</span><br><span class="line">                  x.red = <span class="keyword">false</span>;</span><br><span class="line">                  root = x;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                  K k = x.key;</span><br><span class="line">                  <span class="keyword">int</span> h = x.hash;</span><br><span class="line">                  Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">                  <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                      <span class="keyword">int</span> dir, ph;</span><br><span class="line">                      K pk = p.key;</span><br><span class="line">                      <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                          dir = -<span class="number">1</span>;</span><br><span class="line">                      <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                          dir = <span class="number">1</span>;</span><br><span class="line">                      <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                               (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                          dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">                      TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                      <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                          x.parent = xp;</span><br><span class="line">                          <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                              xp.left = x;</span><br><span class="line">                          <span class="keyword">else</span></span><br><span class="line">                              xp.right = x;</span><br><span class="line">                          root = balanceInsertion(root, x);</span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">  <span class="comment">//确保你返回的是root节点</span></span><br><span class="line">          moveRootToFront(tab, root);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>插入红黑树节点</p>
<p>putTreeVal是TreeNode的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">           Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">           TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">           <span class="comment">//这是一个无限循环，我们得看看他的退出条件</span></span><br><span class="line">           <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">             <span class="comment">//dir应该是左子树或右子树的一个判断</span></span><br><span class="line">               <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">             <span class="comment">//如果Node的hash值小于当前节点的值</span></span><br><span class="line">               <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                 <span class="comment">//右子树</span></span><br><span class="line">                   dir = -<span class="number">1</span>;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                 <span class="comment">//左子树</span></span><br><span class="line">                   dir = <span class="number">1</span>;</span><br><span class="line">             <span class="comment">//如果key相等hash值相等，即我们找到了这个节点返回</span></span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                   <span class="keyword">return</span> p;</span><br><span class="line">             <span class="comment">//</span></span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                         <span class="comment">// /**</span></span><br><span class="line">    * Returns x<span class="string">'s Class if it is of the form "class C implements</span></span><br><span class="line"><span class="string">    * Comparable&lt;C&gt;", else null.</span></span><br><span class="line"><span class="string">    */</span></span><br><span class="line"><span class="string">                         (kc = comparableClassFor(k)) == null) ||</span></span><br><span class="line"><span class="string">                        //</span></span><br><span class="line"><span class="string">   /**</span></span><br><span class="line"><span class="string">    * Returns k.compareTo(x) if x matches kc (k'</span>s screened comparable</span><br><span class="line">    * <span class="class"><span class="keyword">class</span>), <span class="title">else</span> 0.</span></span><br><span class="line"><span class="class">    */</span></span><br><span class="line"><span class="class">                        (<span class="title">dir</span> </span>= compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">                                 <span class="comment">//如果当前节点和要添加的节点哈希值相等，但是两个节点的键不是一个类，只好去挨个对比左右孩子 </span></span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                       TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                       searched = <span class="keyword">true</span>;</span><br><span class="line">                       <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                            (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                           ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                            (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                           <span class="keyword">return</span> q;</span><br><span class="line">                   &#125;</span><br><span class="line">                 <span class="comment">//                //哈希值相等，但键无法比较，只好通过特殊的方法给个结果</span></span><br><span class="line"><span class="comment">//这个方法用于 a 和 b 哈希值相同但是无法比较时，直接根据两个引用的地址进行比较</span></span><br><span class="line">   <span class="comment">//这里源码注释也说了，这个树里不要求完全有序，只要插入时使用相同的规则保持平衡即可</span></span><br><span class="line">                   dir = tieBreakOrder(k, pk);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">               <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">                   TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">                   <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                       xp.left = x;</span><br><span class="line">                   <span class="keyword">else</span></span><br><span class="line">                       xp.right = x;</span><br><span class="line">                   xp.next = x;</span><br><span class="line">                   x.parent = x.prev = xp;</span><br><span class="line">                   <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">                       ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">                   moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>红黑树的插入</p>
<p>首先，我们知道，当插入节点的父节点的是黑色时，不用执行任何操作。</p>
<p>所以，要调整的是当插入节点的父节点是红色时，而插入的节点是红色的时候，是不会改变 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点这一条的，主要要注意的就是红色节点的子节点一定是黑节点这一条。</p>
<p>关于它的特性，需要注意的是：</p>
<p>分析之前，我们要牢记一点，插入之前这棵树是从局部到整体都符合红黑树的定义的。</p>
<p>而且我们调整的思路，永远都是先让底层局部符合定义，再逐级往上调整。</p>
<p>再强调一次，下列穷举的情况都是建立在这棵树符合红黑树的定义的情况下。</p>
<ul>
<li><p>当父节点和叔叔节点都是红色</p>
<p>这个时候我们插入一个红色节点，很显然违反了红色节点的子节点是黑色节点这个规定。</p>
<p>这个我们就像某些时刻处理异常一样，先给他把问题抛给上层。将叔叔节点和父节点都变成黑色，祖父节点变成红色。这样做至少保证了从祖父节点开始是局部符合红黑树的定义的（除了根节点是黑色节点不能确定以外），刚开始，我以为这种情况就大功告成了，后来才发现要考虑一种情况，那就是我们能确定这种情况下祖父节点是黑色，那么这种情况下祖父的父节点是红色还是黑色，我们是无法知道的，倘若是红色，那么当祖父变成红色后，就违反了原则了。所以我们要将祖父节点看成是新的当前节点，继续进行调整（因为已经保证祖父节点以下的都满足了）</p>
</li>
<li><p>当父节点是红色 叔叔节点是黑色且插入节点是父节点的左节点</p>
<p>首先，我们说过插入一个新节点的操作是不会影响 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点这一条的，因为默认插入的是红色，但是会影响红色的子节点必须是黑色这一条。</p>
<p>在这种情况下，祖父是黑色，叔叔是黑色，父节点是红色，我们还是秉守我们的一大原则，把问题尽可能往上层抛，我们从祖父节点开始看，设从祖父节点到左边（父节点）某一个叶子节点的路径包含的黑节点为n（父节点以下的黑节点）+1（祖父节点本身），到右边（叔叔节点）某一个叶子节点的路径包含的黑色节点为n-1(叔叔节点以下的黑节点)+1（叔叔节点）+1（祖父节点本身），都为n+1个黑节点。我们将父节点设为黑色，祖父节点设为红色，就解决了红色的子节点是黑色这一条不遵守的问题，但是这样做会带来新的问题， 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点这一条不符合了。相当于祖父节点到父节点这一分支（n+1）多了一个黑节点而到叔叔那一分支(n 少了原祖父节点这一黑节点)少了一个黑节点，这显然违反了我们的原则，那怎么样去调整呢，这个时候我们以父节点为中心开始右旋。使父节点变成祖父节点，那么现在从祖父节点到左边（原父节点）这一分支还是n+1,右边，由于新的祖父节点是祖父节点是黑色节点，所以黑节点+1为n+1,所以从祖父节点开始，都符合红黑树，此时，祖父节点又成为了黑节点，无需再进行改动。</p>
</li>
<li><p>当父节点是红色 叔叔节点是黑色且插入节点是父节点的右节点</p>
<p>很明显当情况为第二种情况的时候，已经调整好了，所以我们只需要将这种情况调整为第二种情况即可。如何做到第二种情况，以父节点为中心，进行左旋操作即可。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//先将插入的节点设为红色，为什么设为红色，设为红色不会违背，每个节点都其子孙节点的路径经过的黑色节点都一样多这条原则，我们调整红黑树的原则是让他尽可能的少违背红黑树的五大原则，然后就是尽可能的先做到局部符合原则。但是设为红色可能会违反红色节点的子节点一定是黑色这条原则，那么我们就来穷举下违背原则时可能出现的所有情况，有时候你别看着穷举好像很笨的样子，但是有时候大道至简才是真理，最直观的去分析可能会更快的得出结论。</span></span><br><span class="line"> 暴力穷举 </span><br><span class="line"> <span class="number">1</span>.父节点是红色节点，叔叔节点是红色节点</span><br><span class="line">   将父节点和叔叔节点都涂黑，将祖父节点涂红，此时，从祖父节点开始局部符合原则，然后把问题往上抛，将祖父节点设为当前节点。</span><br><span class="line"> <span class="number">2</span>.父节点是红色节点，叔叔节点是黑色节点</span><br><span class="line">    I.父节点是红色节点，叔叔节点是黑色节点，且当前节点是父节点的左子节点</span><br><span class="line">   	很显然，违反的是红色节点的子节点是黑色节点这一条，那么我们就把父节点涂黑，祖父节点（黑色）涂红，然后以祖父节点右旋一波，perfect，强行稳住了。符合原则。</span><br><span class="line">    II.父节点是红色节点，叔叔节点是黑色节点，且当前节点是父节点的右子节点</span><br><span class="line">    x.red = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">      <span class="comment">//如果是根节点，不多逼逼，直接将其涂黑，搞定</span></span><br><span class="line">        <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//如果父节点不是红色或者祖父节点是空的，即父节点是根节点，这里根节点必须是黑节点呀，为什么还要加一个祖父节点为空的判断呀</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">      <span class="comment">//如果父节点是祖父节点的左节点</span></span><br><span class="line">        <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">          <span class="comment">//如果叔叔节点是红色</span></span><br><span class="line">            <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123;</span><br><span class="line">              <span class="comment">//      将父节点和叔叔节点都涂黑，将祖父节点涂红，此时，从祖父节点开始局部符合原则，然后把问题往上抛，将祖父节点设为当前节点。</span></span><br><span class="line">              xppr.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//叔叔节点是黑色</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//如果当前节点是父节店的右子节点，情况2的I</span></span><br><span class="line">                <span class="keyword">if</span> (x == xp.right) &#123;</span><br><span class="line">                  <span class="comment">//以父节点为中心强行来一波左旋操作，使得父节点变为当前节点的左子节点，然后将父节点置为当前节点</span></span><br><span class="line">                  <span class="comment">//也就是变为当前节点是父节点左子节点的情况</span></span><br><span class="line">                    root = rotateLeft(root, x = xp);</span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">//现在就是到了情况2的II了</span></span><br><span class="line">              <span class="comment">//如果父节点不为空</span></span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="comment">//父节点置为黑色</span></span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                      <span class="comment">//祖父节点置为红色</span></span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                      <span class="comment">//右旋</span></span><br><span class="line">                        root = rotateRight(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (xppl != <span class="keyword">null</span> &amp;&amp; xppl.red) &#123;</span><br><span class="line">                xppl.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == xp.left) &#123;</span><br><span class="line">                    root = rotateRight(root, x = xp);</span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateLeft(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个左旋的代码，看着其实很烦呀，虽然一眼看过去很简洁，但是太多骚操作了，在之前代码简洁之道的学习中，我们多次强调过千万不要在平时编程中写只有自己看的懂代码，千万不要喜欢用三元表达式，最好做到一句话只做一件事，写代码，让机器看得懂是最简单的事，如何让人看懂才是问题的关键所在。当然编写JDK源码的人都是大神，追求简单高效无可厚非，我们这些平凡人还是不要秀骚操作比较好。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateLeft</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class="line">	<span class="comment">//左旋操作，实际就是更改下节点的互相指向</span></span><br><span class="line">	<span class="comment">//左旋操作前提，首先右子节点要存在     当前节点指p.right</span></span><br><span class="line"><span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (r = p.right) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//这句代码其实做了两件事（具体的分还不止）,首先进行链式赋值，然后判断值是否为null</span></span><br><span class="line">  <span class="comment">//如果当前节点有左孩子的话，将当前节点的左节点赋给父节点的右孩子</span></span><br><span class="line">                <span class="keyword">if</span> ((rl = p.right = r.left) != <span class="keyword">null</span>)</span><br><span class="line">                  <span class="comment">//然后让当前节点的左节点的父节点设为父节点</span></span><br><span class="line">                    rl.parent = p;</span><br><span class="line">  <span class="comment">//赋值操作：得到祖父节点，并将祖父节点置为当前节点的父节点</span></span><br><span class="line">  <span class="comment">//判断操作，判断父节点是不是根节点，如果是根节点，那么当前节点就会被置为根节点，根节点默认为black</span></span><br><span class="line">                <span class="keyword">if</span> ((pp = r.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">                    (root = r).red = <span class="keyword">false</span>;</span><br><span class="line">  <span class="comment">//新的关系连接起来，很好看懂</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p)</span><br><span class="line">                    pp.left = r;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pp.right = r;</span><br><span class="line">                r.left = p;</span><br><span class="line">                p.parent = r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="REMOVE"><a href="#REMOVE" class="headerlink" title="REMOVE"></a>REMOVE</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public V remove(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    return (e = removeNode(hash(key), key, null, false, true)) == null ?</span><br><span class="line">        null : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">          (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">          Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">  	<span class="comment">//如果是头结点（）</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">              ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">              node = p;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                  node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="keyword">do</span> &#123;</span><br><span class="line">                      <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                          ((k = e.key) == key ||</span><br><span class="line">                           (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                          node = e;</span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">                      p = e;</span><br><span class="line">                  &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                               (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">              <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                  ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                  tab[index] = node.next;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                  p.next = node.next;</span><br><span class="line">              ++modCount;</span><br><span class="line">              --size;</span><br><span class="line">              afterNodeRemoval(node);</span><br><span class="line">              <span class="keyword">return</span> node;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>红黑树的删除</p>
<p> 删除操作应该是红黑树中最难的操作了，说实话，我看了四五遍了，都不是很明白。</p>
<p>首先删除节点就分三种情况，</p>
<ul>
<li><p>无子节点，最简单，直接删除，不多逼逼</p>
<p>如果删除的节点是红色的节点，不用处理，如果是黑色节点就需要调整红黑树的结构。</p>
</li>
<li><p>一个子节点，不多逼逼，直接替代删除节点</p>
<p>如果删除的节点是红色的节点，依旧是不需要处理，但是如果删除的是黑色节点，需要调整红黑树的结构</p>
</li>
<li><p>两个子节点，瞬间爆炸，愣是好几次都没搞透彻。在学习二叉树的删除的时候，对这种情况已经说过了，要灵活思考，找到删除节点的后续节点，然后将后续节点替代删除节点，然后来删除后续节点。</p>
<p>中序后续节点是二叉树中Key大于删除节点的最小值，也就是删除节点的右子树的左子树中最左边的节点。该节点不可能存在左节点，只可能有右节点。后继节点只可能有右节点或者没有子节点，也就对应着前面说的头两种情况了，只不过当前节点从要删除的节点变成了后继节点。</p>
<p>​         当后继节点含有右节点时，</p>
<p>​    删除后续节点，将后续节点的右节点称为后续节点的父节点的左节点。</p>
<p>​    我们就来通过后继节点的子节点和父节点来分析，称后继节点的子节点为当前节点。</p>
<ul>
<li><p>如果当前节点是红色的，说明刚刚移走的后继节点是黑色的，那么不管后继节点的父节点是啥颜色，我们只要将当前节点涂黑就可以了，红-黑树的平衡性就可以恢复。</p>
</li>
<li><p>所以注意分析的情况就是当前节点是黑色的情况</p>
<ul>
<li><p>这种情况是可以直接解决红黑树调整的情况。在这种情况下，我们把兄弟节点的颜色和父节点颜色调换一下（这样一来就给当前节点那一分支添加了一个黑色节点，然后兄弟节点这一分支也并没有少黑色节点，但是还有可能出现的情况需要再考虑：原来的父节点是红色节点，那么就会造成现在的兄弟节点和兄弟节点的右节点都是红色节点，就很尴尬，会造成红色节点的子节点还是红节点的情况，那么这时我们就需要做出改变了</p>
<p>），所以我们还需要将现在的兄弟节点的右节点变为黑色，但是这样又使得兄弟节点这一分支的黑色节点多了一个，这个时候咋办呢，围绕当前的父节点来一波左旋操作，便解决了多一个黑节点的问题，同时最重要的是兄弟节点（颜色是原来的父节点的颜色，这很重要）成为了父节点，目前，父节点及其以下分支已经完成了红黑树调整，又有新的父节点的颜色和原有的父节点相同，这就是说已经完成了所有的调整操作了。</p>
<p>​</p>
</li>
<li><p>当前节点是黑色的，且兄弟节点是黑色的，且兄弟节点的两个子节点均为黑色的；</p>
<p>把兄弟节点涂成红色，这样在父节点及以下分支实现了符合红黑树，但是整体来说就使得父节点之一分支相对于其他分支少了个黑色节点，也就是说，我们这样左就把调整红黑树的任务推给了上一层节点，把问题不停的往上抛，直到根节点，也就自然的解决了问题，把问题逐层往上抛在插入的时候已经强调过实用性和重要性了，然后我们就可以把父节点设为当前节点继续调整了。</p>
</li>
<li><p>当前节点是黑色的，且兄弟节点是黑色的，且兄弟节点的左子节点是红色，右子节点时黑色的；</p>
<p>这个你做一个旋转操作，自然就变成了第一种情况啦，将兄弟节点的左子节点变为黑色，兄弟节点变为红色，以兄弟节点为中心，来一波右旋操作，就成了第一种情况啦。</p>
</li>
<li><p>当前节点是黑色的，且兄弟节点是红色的（那么父节点和兄弟节点的子节点肯定是黑色的）；</p>
<p>很显然，这种情况只要先把他转化为当前节点和兄弟节点都是黑色的情况就好啦。</p>
<p>怎么做呢，这里相关的节点都是能确定颜色的，要完成这个操作还是比较简单的。</p>
<p>先将兄弟节点和父节点的颜色调换，然后以父节点为中心左旋即可。</p>
</li>
</ul>
</li>
</ul>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>我们注意到我们分析两个子节点时，当后续节点有子节点时，我们给出了具体调整红黑树的方案</p>
<p>那我们有没有办法在其他情况下也用到这种解决方案呢，如果能用到那我们就解决了红黑树删除节点的问题了。</p>
<p>那我们再回头来分析下我们在后续节点有子节点是怎么解决的。</p>
<p>我们是将右子节点补上后继的位置，我们称这个右子节点为替代节点replacement节点，成为后继节点父节点的子节点，然后用replacement和其父节点和其兄弟节点的各种情况来分析得到解决方案。</p>
<p>那么对于其他情况下，我们能不能尝试得到replacement来构造这种解决方案呢。</p>
<p>1、我们来看之前说的当前节点只有一个子节点的情况，我们说过这种情况是将子节点代替删除节点，当删除节点为黑色节点的时候是需要看是否需要调整红黑树的。那么这种情况我们可以很容易的得到这里可以将子节点设为replacement</p>
<p>2、删除节点没有子节点</p>
<p>这种情况下当删除节点是黑色的时候是一定会出现违反红黑树定义的情况的，但是这个时候没有子节点呀，咋办呀，上哪找replacement呀，这个时候我们就把当前要删除的节点当做是replacement，就当此时这个分支当前是少一个黑节点的（为什么呢，因为这个replacement节点终于要删除的），然后使用replacement调整红黑树、</p>
<p>3.后继节点是没有子节点的</p>
<p>那这种情况那和2一样，也是抓当前要删除的节点当做replacement的，最后把这个给删了。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeTreeNode</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        <span class="comment">//为什么JDK源码要整这么多骚操作呀，这个局部变量的命名我真的了</span></span><br><span class="line">            TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl;</span><br><span class="line">            TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev;</span><br><span class="line">        <span class="comment">//去掉要删除的节点</span></span><br><span class="line">            <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">                tab[index] = first = succ;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pred.next = succ;</span><br><span class="line">            <span class="keyword">if</span> (succ != <span class="keyword">null</span>)</span><br><span class="line">                succ.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (root.parent != <span class="keyword">null</span>)</span><br><span class="line">                root = root.root();</span><br><span class="line">            <span class="keyword">if</span> (root == <span class="keyword">null</span> || root.right == <span class="keyword">null</span> ||</span><br><span class="line">                (rl = root.left) == <span class="keyword">null</span> || rl.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                tab[index] = first.untreeify(map);  <span class="comment">// too small</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>, pl = left, pr = right, replacement;</span><br><span class="line">            <span class="keyword">if</span> (pl != <span class="keyword">null</span> &amp;&amp; pr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; s = pr, sl;</span><br><span class="line">              <span class="comment">//找到后继节点</span></span><br><span class="line">                <span class="keyword">while</span> ((sl = s.left) != <span class="keyword">null</span>) <span class="comment">// find successor</span></span><br><span class="line">                    s = sl;</span><br><span class="line">              <span class="comment">//交换颜色</span></span><br><span class="line">                <span class="keyword">boolean</span> c = s.red; s.red = p.red; p.red = c; <span class="comment">// swap colors</span></span><br><span class="line">                TreeNode&lt;K,V&gt; sr = s.right;</span><br><span class="line">                TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">              <span class="comment">//如果后继节点就是当前节点的右子节点，即右子节点没有左子树</span></span><br><span class="line">                <span class="keyword">if</span> (s == pr) &#123; <span class="comment">// p was s's direct parent</span></span><br><span class="line">                  <span class="comment">//两个交换一下</span></span><br><span class="line">                    p.parent = s;</span><br><span class="line">                    s.right = p;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">//后继节点的父节点</span></span><br><span class="line">                    TreeNode&lt;K,V&gt; sp = s.parent;</span><br><span class="line">                  <span class="comment">//后继节点的父节点成为当前接的父节点</span></span><br><span class="line">                  <span class="comment">//用当前节点代替后继节点</span></span><br><span class="line">                    <span class="keyword">if</span> ((p.parent = sp) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                      <span class="comment">//如果后继节点是其父节点的左节点，则当前节点设为其父节点的左节点</span></span><br><span class="line">                        <span class="keyword">if</span> (s == sp.left)</span><br><span class="line">                            sp.left = p;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            sp.right = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="comment">//将后继节点代替当前节点的位置</span></span><br><span class="line">                    <span class="keyword">if</span> ((s.right = pr) != <span class="keyword">null</span>)</span><br><span class="line">                        pr.parent = s;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">//相当于将当前节点和后继节点互相换位置，包括颜色</span></span><br><span class="line">             <span class="comment">//因为当前节点要代替当前节点，当然p.left==null；</span></span><br><span class="line">                p.left = <span class="keyword">null</span>;</span><br><span class="line">              <span class="comment">//继续完成当前节点代替后继节点的操作</span></span><br><span class="line">                <span class="keyword">if</span> ((p.right = sr) != <span class="keyword">null</span>)</span><br><span class="line">                    sr.parent = p;</span><br><span class="line">              <span class="comment">//将后继节点代替当前节点的位置</span></span><br><span class="line">                <span class="keyword">if</span> ((s.left = pl) != <span class="keyword">null</span>)</span><br><span class="line">                    pl.parent = s;</span><br><span class="line">              <span class="comment">//如果当前节点是根节点，直接替代根节点</span></span><br><span class="line">                <span class="keyword">if</span> ((s.parent = pp) == <span class="keyword">null</span>)</span><br><span class="line">                    root = s;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                    pp.left = s;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pp.right = s;</span><br><span class="line">              <span class="comment">//前面就是完成后继节点和当前节点位置互换的操作。不难理解，但是目前没理解的是，为什么要用当前节点来替代后继节点的位置，这个位置不是要删除掉的吗</span></span><br><span class="line">              <span class="comment">//接下来的操作就需要思考了</span></span><br><span class="line">              <span class="comment">//如果后继节点的右子树存在</span></span><br><span class="line">                <span class="keyword">if</span> (sr != <span class="keyword">null</span>)</span><br><span class="line">                    replacement = sr;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    replacement = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pl != <span class="keyword">null</span>)</span><br><span class="line">                replacement = pl;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pr != <span class="keyword">null</span>)</span><br><span class="line">                replacement = pr;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                replacement = p;</span><br><span class="line">        <span class="comment">//当前节点有两个孩子</span></span><br><span class="line">        <span class="comment">//如果后继节点没有孩子节点，则replacement=p;</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">//如果有右孩子节点repalcement都不会为当前节点p而是后继节点的右孩子</span></span><br><span class="line">               <span class="comment">//如果当前节点没有孩子节点，repalcement=p;</span></span><br><span class="line">        <span class="comment">//如果有一个节点的情况 replacement=相应的孩子节点</span></span><br><span class="line">            <span class="keyword">if</span> (replacement != p) &#123;</span><br><span class="line">              <span class="comment">//虽然到这里我终于看懂了，但是为什么我觉得这个操作非常非常的多余呀</span></span><br><span class="line">                TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;</span><br><span class="line">                <span class="keyword">if</span> (pp == <span class="keyword">null</span>)</span><br><span class="line">                    root = replacement;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                    pp.left = replacement;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pp.right = replacement;</span><br><span class="line">                p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">	<span class="comment">//因为后继节点和当前节点的颜色互换了。p.red就代表后继节点的颜色，很明显，当要真正删除的后继节点是红色的时候，不会对红黑树有任何影响，不需要做任何改动，而当后继节点的颜色是黑色时，就有可能影响节点到子孙的路径中黑色节点的个数相同这一条，就需要调整红黑树</span></span><br><span class="line">        </span><br><span class="line">            TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);</span><br><span class="line"><span class="comment">//如果后继节点没有子节点或者删除节点本身就没有子节点，我们只能拿要删除的节点先去顶上，然后执行完</span></span><br><span class="line">       <span class="comment">// balanceDeletion操作之后再去删除</span></span><br><span class="line">            <span class="keyword">if</span> (replacement == p) &#123;  <span class="comment">// detach</span></span><br><span class="line">                TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">                p.parent = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (pp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                        pp.left = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.right)</span><br><span class="line">                        pp.right = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (movable)</span><br><span class="line">                moveRootToFront(tab, r);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceDeletion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpl, xpr;;)  &#123;</span><br><span class="line">            <span class="comment">//如果当前节点就是root节点，直接返回</span></span><br><span class="line">              <span class="keyword">if</span> (x == <span class="keyword">null</span> || x == root)</span><br><span class="line">                  <span class="keyword">return</span> root;</span><br><span class="line">            <span class="comment">//如果删除的就是root节点，当前节点就顶上去成为root节点，这个时候要记得颜色要置为black</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//置为  </span></span><br><span class="line">                x.red = <span class="keyword">false</span>;</span><br><span class="line">                  <span class="keyword">return</span> x;</span><br><span class="line">              &#125;</span><br><span class="line">   	<span class="comment">//如果当前节点是红色，将当前节点改为黑色就行了，因为如果当前节点是红色，我们只要把节点改为黑色既可以弥补去掉后继节点所失去的一个黑色节点。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (x.red) &#123;</span><br><span class="line">			                </span><br><span class="line">                  x.red = <span class="keyword">false</span>;</span><br><span class="line">                  <span class="keyword">return</span> root;</span><br><span class="line">              &#125;</span><br><span class="line">            <span class="comment">//两种情况，当前节点是左孩子，或当前节点是右孩子，我们只需对其中一种情况分析即可，因为这两种情况是对称的。</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> ((xpl = xp.left) == x) &#123;</span><br><span class="line">                <span class="comment">//当前节点是黑色的，，则他的兄弟节点要么是黑色要么是红色</span></span><br><span class="line">                <span class="comment">//如果是红色，那兄弟节点的孩子节点是黑色，父节点肯定是黑色。</span></span><br><span class="line">                <span class="comment">//也就是说，红色节点这种情况是唯一确定的，而兄弟节点是黑色的情况会有好几种情况</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                所以，我们就先将</span></span><br><span class="line"><span class="comment">                1.兄弟节点是红色，这种情况转化为当前节点和兄弟节点都是黑色的情况。</span></span><br><span class="line"><span class="comment">                </span></span><br><span class="line"><span class="comment">                </span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                  <span class="keyword">if</span> ((xpr = xp.right) != <span class="keyword">null</span> &amp;&amp; xpr.red) &#123;</span><br><span class="line">                      xpr.red = <span class="keyword">false</span>;</span><br><span class="line">                      xp.red = <span class="keyword">true</span>;</span><br><span class="line">                      root = rotateLeft(root, xp);</span><br><span class="line">                      xpr = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.right;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span> (xpr == <span class="keyword">null</span>)</span><br><span class="line">                      x = xp;</span><br><span class="line">                  <span class="keyword">else</span> &#123;</span><br><span class="line">                      TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right;</span><br><span class="line">                      <span class="keyword">if</span> ((sr == <span class="keyword">null</span> || !sr.red) &amp;&amp;</span><br><span class="line">                          (sl == <span class="keyword">null</span> || !sl.red)) &#123;</span><br><span class="line">                          xpr.red = <span class="keyword">true</span>;</span><br><span class="line">                          x = xp;</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="keyword">else</span> &#123;</span><br><span class="line">                          <span class="keyword">if</span> (sr == <span class="keyword">null</span> || !sr.red) &#123;</span><br><span class="line">                              <span class="keyword">if</span> (sl != <span class="keyword">null</span>)</span><br><span class="line">                                  sl.red = <span class="keyword">false</span>;</span><br><span class="line">                              xpr.red = <span class="keyword">true</span>;</span><br><span class="line">                              root = rotateRight(root, xpr);</span><br><span class="line">                              xpr = (xp = x.parent) == <span class="keyword">null</span> ?</span><br><span class="line">                                  <span class="keyword">null</span> : xp.right;</span><br><span class="line">                          &#125;</span><br><span class="line">                          <span class="keyword">if</span> (xpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                              xpr.red = (xp == <span class="keyword">null</span>) ? <span class="keyword">false</span> : xp.red;</span><br><span class="line">                              <span class="keyword">if</span> ((sr = xpr.right) != <span class="keyword">null</span>)</span><br><span class="line">                                  sr.red = <span class="keyword">false</span>;</span><br><span class="line">                          &#125;</span><br><span class="line">                          <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                              xp.red = <span class="keyword">false</span>;</span><br><span class="line">                              root = rotateLeft(root, xp);</span><br><span class="line">                          &#125;</span><br><span class="line">                          x = root;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span> &#123; <span class="comment">// symmetric</span></span><br><span class="line">                  <span class="keyword">if</span> (xpl != <span class="keyword">null</span> &amp;&amp; xpl.red) &#123;</span><br><span class="line">                      xpl.red = <span class="keyword">false</span>;</span><br><span class="line">                      xp.red = <span class="keyword">true</span>;</span><br><span class="line">                      root = rotateRight(root, xp);</span><br><span class="line">                      xpl = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.left;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span> (xpl == <span class="keyword">null</span>)</span><br><span class="line">                      x = xp;</span><br><span class="line">                  <span class="keyword">else</span> &#123;</span><br><span class="line">                      TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right;</span><br><span class="line">                      <span class="keyword">if</span> ((sl == <span class="keyword">null</span> || !sl.red) &amp;&amp;</span><br><span class="line">                          (sr == <span class="keyword">null</span> || !sr.red)) &#123;</span><br><span class="line">                          xpl.red = <span class="keyword">true</span>;</span><br><span class="line">                          x = xp;</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="keyword">else</span> &#123;</span><br><span class="line">                          <span class="keyword">if</span> (sl == <span class="keyword">null</span> || !sl.red) &#123;</span><br><span class="line">                              <span class="keyword">if</span> (sr != <span class="keyword">null</span>)</span><br><span class="line">                                  sr.red = <span class="keyword">false</span>;</span><br><span class="line">                              xpl.red = <span class="keyword">true</span>;</span><br><span class="line">                              root = rotateLeft(root, xpl);</span><br><span class="line">                              xpl = (xp = x.parent) == <span class="keyword">null</span> ?</span><br><span class="line">                                  <span class="keyword">null</span> : xp.left;</span><br><span class="line">                          &#125;</span><br><span class="line">                          <span class="keyword">if</span> (xpl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                              xpl.red = (xp == <span class="keyword">null</span>) ? <span class="keyword">false</span> : xp.red;</span><br><span class="line">                              <span class="keyword">if</span> ((sl = xpl.left) != <span class="keyword">null</span>)</span><br><span class="line">                                  sl.red = <span class="keyword">false</span>;</span><br><span class="line">                          &#125;</span><br><span class="line">                          <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                              xp.red = <span class="keyword">false</span>;</span><br><span class="line">                              root = rotateRight(root, xp);</span><br><span class="line">                          &#125;</span><br><span class="line">                          x = root;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h3 id="RESIZE"><a href="#RESIZE" class="headerlink" title="RESIZE()"></a>RESIZE()</h3><p>最后，我们再来看看resize()的改动</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">       <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">       <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">       <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">               threshold = Integer.MAX_VALUE;</span><br><span class="line">               <span class="keyword">return</span> oldTab;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">               newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">           newCap = oldThr;</span><br><span class="line">       <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">           newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">           newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">           newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">       &#125;</span><br><span class="line">       threshold = newThr;</span><br><span class="line">       <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">           Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">       table = newTab;</span><br><span class="line">       <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">               Node&lt;K,V&gt; e;</span><br><span class="line">               <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                   <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                       newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                       ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                   <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                       Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; next;</span><br><span class="line">                       <span class="keyword">do</span> &#123;</span><br><span class="line">                           next = e.next;</span><br><span class="line">                           <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                               <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                   loHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   loTail.next = e;</span><br><span class="line">                               loTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="keyword">else</span> &#123;</span><br><span class="line">                               <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                   hiHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   hiTail.next = e;</span><br><span class="line">                               hiTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                       <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                           newTab[j] = loHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                           newTab[j + oldCap] = hiHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> newTab;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>代码比较简单，就不细说了，很容易看懂，差别就在jdk7扩容的时候会让链表倒置，而jdk8不会倒置链表</p>
<p>。jdk8中用hash&amp;newcap-1的方法来确定元素位于的hash桶的位置，为0不用移位置，为1就在table[i+oldCap]上了。</p>
<p>当然resize()的时候会对TreeNode红黑树有一些改动，如果新的红黑树长度小于6，就要还原成链表。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2017/11/19/HashMap/" data-id="cjb52pqzd000ggkbzohsi58ih" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/19/hello-world/" class="article-date">
  <time datetime="2017-11-19T09:55:11.801Z" itemprop="datePublished">2017-11-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/19/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2017/11/19/hello-world/" data-id="cjb52pr05000tgkbzii76vd65" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java-WEB/">Java WEB</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaWEB/">JavaWEB</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java基础/">Java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mybatis/">Mybatis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringMVC/">SpringMVC</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/01/21/--Spring源码之AOP/">Spring源码之AOP</a>
          </li>
        
          <li>
            <a href="/2018/01/17/session/">Cookie和Session</a>
          </li>
        
          <li>
            <a href="/2018/01/14/对classpath的理解/">对classpath的理解</a>
          </li>
        
          <li>
            <a href="/2018/01/11/Spring配置文件解析(一)/">Spring之BeanFactoryPostProcessor</a>
          </li>
        
          <li>
            <a href="/2018/01/08/--SpringMVC请求处理之对方法参数的处理/">SpringMVC请求处理之对方法参数的处理</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>