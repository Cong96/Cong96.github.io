<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>迷途书童的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="厚积薄发">
<meta property="og:type" content="website">
<meta property="og:title" content="迷途书童的博客">
<meta property="og:url" content="https://cong96.github.io/page/5/index.html">
<meta property="og:site_name" content="迷途书童的博客">
<meta property="og:description" content="厚积薄发">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="迷途书童的博客">
<meta name="twitter:description" content="厚积薄发">
  
    <link rel="alternate" href="/atom.xml" title="迷途书童的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">迷途书童的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">一天进步一点</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://cong96.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Mybatis插件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/22/Mybatis插件/" class="article-date">
  <time datetime="2017-11-22T15:52:37.741Z" itemprop="datePublished">2017-11-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Mybatis/">Mybatis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/22/Mybatis插件/">Mybatis插件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>前言：最近项目有个需求，需要将所有产品的ID和Name组成Map传递到前台,以ID为key，以Name为Value。</p>
<p>即需要达到可以通过map.get(id)方便地获取name的值的效果。</p>
<p>然后就开始测试在Mybatis中哪种方法可行。首先看看直接使用resultType=”map”</p>
<p>Mapper文件如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">"testMap"</span> resultType=<span class="string">"map"</span>&gt;</span><br><span class="line"> select    id,name from coach </span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<p>CoachDao接口定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Map&lt;Object, Object&gt; testMap();</span><br></pre></td></tr></table></figure>
<p>测试方法如下：特意没有引入Spring，只有Mybatis方便DebugMybatis源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testMap() &#123;</span><br><span class="line">	SqlSession session = null;</span><br><span class="line">	System.out.println(&quot;Dd&quot;);</span><br><span class="line">	try &#123;</span><br><span class="line"></span><br><span class="line">		session = MybatisUtil.getCurrentSession();</span><br><span class="line">		CoachDao mapper = session.getMapper(CoachDao.class);</span><br><span class="line">		Map&lt;Object, Object&gt; map = mapper.testMap();</span><br><span class="line">		System.out.println(JSON.toJSONString(map));</span><br><span class="line"></span><br><span class="line">	&#125; catch (Exception e) &#123;</span><br><span class="line">		// TODO: handle exception</span><br><span class="line">		logger.error(&quot;testMap Error:&#123;&#125;&quot;, e);</span><br><span class="line">	&#125; finally &#123;</span><br><span class="line">		session.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们debug观察下这次sql的执行过程。</p>
<p>我们从debug到MapperMethod这个类开始看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public Object execute(SqlSession sqlSession, Object[] args) &#123;</span><br><span class="line">   Object result;</span><br><span class="line">   if (SqlCommandType.INSERT == command.getType()) &#123;</span><br><span class="line">     Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">     result = rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">   &#125; else if (SqlCommandType.UPDATE == command.getType()) &#123;</span><br><span class="line">     Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">     result = rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">   &#125; else if (SqlCommandType.DELETE == command.getType()) &#123;</span><br><span class="line">     Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">     result = rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">   &#125; else if (SqlCommandType.SELECT == command.getType()) &#123;</span><br><span class="line">     if (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">       executeWithResultHandler(sqlSession, args);</span><br><span class="line">       result = null;</span><br><span class="line">     &#125; else if (method.returnsMany()) &#123;</span><br><span class="line">       result = executeForMany(sqlSession, args);</span><br><span class="line">     &#125; else if (method.returnsMap()) &#123;</span><br><span class="line">       result = executeForMap(sqlSession, args);</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">       result = sqlSession.selectOne(command.getName(), param);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     throw new BindingException(&quot;Unknown execution method for: &quot; + command.getName());</span><br><span class="line">   &#125;</span><br><span class="line">   if (result == null &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</span><br><span class="line">     throw new BindingException(&quot;Mapper method &apos;&quot; + command.getName() </span><br><span class="line">         + &quot; attempted to return null from a method with a primitive return type (&quot; + method.getReturnType() + &quot;).&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   return result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>显然我们这里执行的是SqlCommandType.SELECT == command.getType()这一个分支的。</p>
<p>我们看看这个分支的流程，首先要判断是否参数中包含ResultHandler类型的参数，</p>
<p>然后判断是否是返回Collection容器类型或者数组类型，</p>
<p>接着判断是否Method方法参数中带有@MapKey注解且返回类型为Map,看到这里我们会想到这个是否能够实现我们想要的功能呢，这个我们接下来会测试。</p>
<p>然后终于到达我们我们要走的分支</p>
<p>执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = sqlSession.selectOne(command.getName(), param);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">selectOne</span><span class="params">(String statement, Object parameter)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Popular vote was to return null on 0 results and throw exception on too many.</span></span><br><span class="line">  List&lt;T&gt; list = <span class="keyword">this</span>.&lt;T&gt;selectList(statement, parameter);</span><br><span class="line">  <span class="keyword">if</span> (list.size() == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> TooManyResultsException(<span class="string">"Expected one result (or null) to be returned by selectOne(), but found: "</span> + list.size());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现实际上Mybatis给我们返回的是一个List，只不过当执行selectOne时，需要sql执行后返回的List集合中只有一个元素。而在这里我们知道上面的sql返回的是多行结果集，而多行结果集在没有经过插件处理的时候显然返回的List中有多个结果，这个时候就会报错。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.ibatis.exceptions.TooManyResultsException: <span class="function">Expected one <span class="title">result</span> <span class="params">(or <span class="keyword">null</span>)</span> to be returned by <span class="title">selectOne</span><span class="params">()</span>, but found: 13</span></span><br></pre></td></tr></table></figure>
<p>所以第一种方案不行。</p>
<p>那我们把方法的返回类型改一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Map&lt;Object, Object&gt;&gt; testMap();</span><br></pre></td></tr></table></figure>
<p>可以保证程序正确运行，但是是List类型返回值而且其中的每一个Map是由两个元素构成的，分别以ID和NAME为键，即（”id”:123）、(“name”:”Jack”)的形式保存在Map中的。与我们想要的Map结构也不相同，虽然可以转化为我们想要的Map，但是这种转化不是很优雅，我们得找到一个更优雅更通用的方法。</p>
<ul>
<li><p>MapKey注解</p>
<p>​    那我们接着来试试之前用到的MapKey注解看能不能达到我想要的效果呢，查阅相关资料，我们开始尝试。</p>
<p>我们更改方法,将方法带上注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MapKey</span>(<span class="string">"ID"</span>)</span><br><span class="line"><span class="keyword">public</span> Map&lt;Integer, Map&lt;String, Object&gt;&gt; testMapKey();</span><br></pre></td></tr></table></figure>
<p>@MapKey(“ID”)这个注解表示最外层Map的key为查询结果中字段名为“id”的值。</p>
<p>那此刻只要Mybatis有把Value设为查询结果中的name字段的值不就好了吗。</p>
<p>但是很遗憾的是，Mybatis并没有直接实现这个功能。</p>
<p>我们看selectMap源码，当我们在没有对查询结果使用插件的时候，我们存进Map的Value只能是我们查询结果集的指定返回类型。而我们这里resultType=“map”，也就是说返回的类型就是Map。那你说我们把resultType=“string”就可以了把，很显然，这里存在问题，因为我们的结果包含两列，不可能做到resulType=“string” 。所以使用MapKey注解也是无法达到我们想要的效果的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public &lt;K, V&gt; Map&lt;K, V&gt; selectMap(String statement, Object parameter, String mapKey, RowBounds rowBounds) &#123;</span><br><span class="line">  final List&lt;?&gt; list = selectList(statement, parameter, rowBounds);</span><br><span class="line">  final DefaultMapResultHandler&lt;K, V&gt; mapResultHandler = new DefaultMapResultHandler&lt;K, V&gt;(mapKey,</span><br><span class="line">      configuration.getObjectFactory(), configuration.getObjectWrapperFactory());</span><br><span class="line">  final DefaultResultContext context = new DefaultResultContext();</span><br><span class="line">  for (Object o : list) &#123;</span><br><span class="line">    context.nextResultObject(o);</span><br><span class="line">    mapResultHandler.handleResult(context);</span><br><span class="line">  &#125;</span><br><span class="line">  Map&lt;K, V&gt; selectedMap = mapResultHandler.getMappedResults();</span><br><span class="line">  return selectedMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看看使用MapKey注解的返回情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">==&gt;  Preparing: select id,name from coach </span><br><span class="line">==&gt; Parameters: </span><br><span class="line">&lt;==    Columns: ID, NAME</span><br><span class="line">&lt;==        Row: <span class="number">12</span>, phil jackson</span><br><span class="line">&lt;==        Row: <span class="number">17</span>, phil jackson</span><br><span class="line">&lt;==        Row: <span class="number">1</span>, jackson</span><br><span class="line">&lt;==        Row: <span class="number">14</span>, phil jackson</span><br><span class="line">&lt;==        Row: <span class="number">18</span>, phil jackson</span><br><span class="line">&lt;==        Row: <span class="number">2</span>, jackson</span><br><span class="line">&lt;==        Row: <span class="number">10</span>, jackson</span><br><span class="line">&lt;==        Row: <span class="number">13</span>, phil jackson</span><br><span class="line">&lt;==        Row: <span class="number">15</span>, phil jackson</span><br><span class="line">&lt;==        Row: <span class="number">16</span>, phil jackson1</span><br><span class="line">&lt;==        Row: <span class="number">5</span>, jackson</span><br><span class="line">&lt;==        Row: <span class="number">3</span>, jackson</span><br><span class="line">&lt;==        Row: <span class="number">11</span>, jackson</span><br><span class="line">&lt;==      Total: <span class="number">13</span></span><br><span class="line">&#123;<span class="number">1</span>:&#123;<span class="string">"ID"</span>:<span class="number">1</span>,<span class="string">"NAME"</span>:<span class="string">"jackson"</span>&#125;,<span class="number">2</span>:&#123;<span class="string">"ID"</span>:<span class="number">2</span>,<span class="string">"NAME"</span>:<span class="string">"jackson"</span>&#125;,<span class="number">3</span>:&#123;<span class="string">"ID"</span>:<span class="number">3</span>,<span class="string">"NAME"</span>:<span class="string">"jackson"</span>&#125;,<span class="number">5</span>:&#123;<span class="string">"ID"</span>:<span class="number">5</span>,<span class="string">"NAME"</span>:<span class="string">"jackson"</span>&#125;,<span class="number">10</span>:&#123;<span class="string">"ID"</span>:<span class="number">10</span>,<span class="string">"NAME"</span>:<span class="string">"jackson"</span>&#125;,<span class="number">11</span>:&#123;<span class="string">"ID"</span>:<span class="number">11</span>,<span class="string">"NAME"</span>:<span class="string">"jackson"</span>&#125;,<span class="number">12</span>:&#123;<span class="string">"ID"</span>:<span class="number">12</span>,<span class="string">"NAME"</span>:<span class="string">"phil jackson"</span>&#125;,<span class="number">13</span>:&#123;<span class="string">"ID"</span>:<span class="number">13</span>,<span class="string">"NAME"</span>:<span class="string">"phil jackson"</span>&#125;,<span class="number">14</span>:&#123;<span class="string">"ID"</span>:<span class="number">14</span>,<span class="string">"NAME"</span>:<span class="string">"phil jackson"</span>&#125;,<span class="number">15</span>:&#123;<span class="string">"ID"</span>:<span class="number">15</span>,<span class="string">"NAME"</span>:<span class="string">"phil jackson"</span>&#125;,<span class="number">16</span>:&#123;<span class="string">"ID"</span>:<span class="number">16</span>,<span class="string">"NAME"</span>:<span class="string">"phil jackson1"</span>&#125;,<span class="number">17</span>:&#123;<span class="string">"ID"</span>:<span class="number">17</span>,<span class="string">"NAME"</span>:<span class="string">"phil jackson"</span>&#125;,<span class="number">18</span>:&#123;<span class="string">"ID"</span>:<span class="number">18</span>,<span class="string">"NAME"</span>:<span class="string">"phil jackson"</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>从结果集我们可以看出，以ID作为Key，但是Value是上面一种情况的Map集合，结构仍然为（（”id”:123）、(“name”:”Jack”)）显然是不符合要求的。</p>
</li>
</ul>
<p>也就是说，很遗憾，我们的这种需求Mybatis并没有直接的支持，那我们该怎么办呢，这时候就需要用到Mybatis留给我们的重要接口Mybatis中的拦截器，通过使用提供给用户可以自定义实现特殊功能，其功能特别强大。我们可以在Mybatis最重要的四大组件中使用拦截器（通过动态代理和反射注解等技术实现,这三个技术就是框架的核心，其定义就不多说了），让我们能够自定义的对四大组件的功能进行丰富和更改等。</p>
<p>在说拦截器之前，我们需要说一下四大组件</p>
<p>这部分后续补充</p>
<h3 id="二-Mybatis中的拦截器"><a href="#二-Mybatis中的拦截器" class="headerlink" title="二.Mybatis中的拦截器"></a>二.Mybatis中的拦截器</h3><p>现在我们来看Mybatis中的拦截器，Mybatis很贴心的为我们提供了Interceptor接口，作为一个优秀的开源框架，Mybatis和Spring一样都很好的遵守了开闭原则。基本都是面向接口的编程，特别是Spring，你会发现是Spring中大量的运用了模板方法模式来设计。在Mybatis中，我们要自定义我们的拦截器只需要实现这个接口。那我们首先就来瞅瞅这个接口都定义了哪些方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Object <span class="title">plugin</span><span class="params">(Object target)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>plugin方法是拦截器用于封装目标对象的，通过该方法我们可以返回目标对象本身，也可以返回一个它的代理。当返回的是代理的时候我们可以对其中的方法进行拦截来调用intercept方法(因为intercept方法的参数Invocation封装了原对象的相关信息)，当然也可以调用其他方法。setProperties方法是用于在Mybatis配置文件中指定一些属性的。       定义自己的Interceptor最重要的是要实现plugin方法和intercept方法，在plugin方法中我们可以决定是否要进行拦截进而决定要返回一个什么样的目标对象。而intercept方法就是要进行拦截的时候要执行的方法。而对于plugin方法而言，其实Mybatis已经为我们提供了一个实现。Mybatis中有一个叫做Plugin的类，里面有一个静态方法wrap(Object target,Interceptor interceptor)，通过该方法可以决定要返回的对象是目标对象还是对应的代理。Mybatis已经尽可能的帮我们做的更多了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">public class Plugin implements InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">  private Object target;</span><br><span class="line">  private Interceptor interceptor;</span><br><span class="line">  private Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap;</span><br><span class="line"></span><br><span class="line">  private Plugin(Object target, Interceptor interceptor, Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap) &#123;</span><br><span class="line">    this.target = target;</span><br><span class="line">    this.interceptor = interceptor;</span><br><span class="line">    this.signatureMap = signatureMap;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static Object wrap(Object target, Interceptor interceptor) &#123;</span><br><span class="line">    Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor);</span><br><span class="line">    Class&lt;?&gt; type = target.getClass();</span><br><span class="line">    Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);</span><br><span class="line">    if (interfaces.length &gt; 0) &#123;</span><br><span class="line">      return Proxy.newProxyInstance(</span><br><span class="line">          type.getClassLoader(),</span><br><span class="line">          interfaces,</span><br><span class="line">          new Plugin(target, interceptor, signatureMap));</span><br><span class="line">    &#125;</span><br><span class="line">    return target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass());</span><br><span class="line">      if (methods != null &amp;&amp; methods.contains(method)) &#123;</span><br><span class="line">        return interceptor.intercept(new Invocation(target, method, args));</span><br><span class="line">      &#125;</span><br><span class="line">      return method.invoke(target, args);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      throw ExceptionUtil.unwrapThrowable(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private static Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; getSignatureMap(Interceptor interceptor) &#123;</span><br><span class="line">    Intercepts interceptsAnnotation = interceptor.getClass().getAnnotation(Intercepts.class);</span><br><span class="line">    if (interceptsAnnotation == null) &#123; // issue #251</span><br><span class="line">      throw new PluginException(&quot;No @Intercepts annotation was found in interceptor &quot; + interceptor.getClass().getName());      </span><br><span class="line">    &#125;</span><br><span class="line">    Signature[] sigs = interceptsAnnotation.value();</span><br><span class="line">    Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = new HashMap&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt;();</span><br><span class="line">    for (Signature sig : sigs) &#123;</span><br><span class="line">      Set&lt;Method&gt; methods = signatureMap.get(sig.type());</span><br><span class="line">      if (methods == null) &#123;</span><br><span class="line">        methods = new HashSet&lt;Method&gt;();</span><br><span class="line">        signatureMap.put(sig.type(), methods);</span><br><span class="line">      &#125;</span><br><span class="line">      try &#123;</span><br><span class="line">        Method method = sig.type().getMethod(sig.method(), sig.args());</span><br><span class="line">        methods.add(method);</span><br><span class="line">      &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">        throw new PluginException(&quot;Could not find method on &quot; + sig.type() + &quot; named &quot; + sig.method() + &quot;. Cause: &quot; + e, e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return signatureMap;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private static Class&lt;?&gt;[] getAllInterfaces(Class&lt;?&gt; type, Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap) &#123;</span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; interfaces = new HashSet&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">    while (type != null) &#123;</span><br><span class="line">      for (Class&lt;?&gt; c : type.getInterfaces()) &#123;</span><br><span class="line">        if (signatureMap.containsKey(c)) &#123;</span><br><span class="line">          interfaces.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      type = type.getSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">    return interfaces.toArray(new Class&lt;?&gt;[interfaces.size()]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先看一下Plugin的wrap方法，它根据当前的Interceptor上面的注解定义哪些接口需要拦截，然后判断当前目标对象是否有实现对应需要拦截的接口，如果没有则返回目标对象本身，如果有则返回一个代理对象。而这个代理对象的InvocationHandler正是一个Plugin。所以当目标对象在执行接口方法时，如果是通过代理对象执行的，则会调用对应InvocationHandler的invoke方法，也就是Plugin的invoke方法。(至于到底为什么会调用这个方法，我相信其实有不少人都不是真的明白，这个我在之前的博客中有说过，因为在调用代理对象的方法的时候实际上调用的就是InvocationHandler的invoke方法，InvocationHandler对象作为代理对象的构造器参数注入，要彻底明白</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">         type.getClassLoader(),</span><br><span class="line">         interfaces,</span><br><span class="line">         <span class="keyword">new</span> Plugin(target, interceptor, signatureMap));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这句话到底做了什么才能彻底理解JDK动态代理</p>
<p>)所以接着我们来看一下该invoke方法的内容。这里invoke方法的逻辑是：如果当前执行的方法是定义好的需要拦截的方法，则把目标对象、要执行的方法以及方法参数封装成一个Invocation对象，再把封装好的Invocation作为参数传递给当前拦截器的intercept方法。如果不需要拦截，则直接调用当前的方法。Invocation中定义了定义了一个proceed方法，其逻辑就是调用当前方法，所以如果在intercept中需要继续调用当前方法的话可以调用invocation的procced方法。</p>
<p>​       这就是Mybatis中实现Interceptor拦截的一个思想，如果用户觉得这个思想有问题或者不能完全满足你的要求的话可以通过实现自己的Plugin来决定什么时候需要代理什么时候需要拦截。以下讲解的内容都是基于Mybatis的默认实现即通过Plugin来管理Interceptor来讲解的。</p>
<p>​       对于实现自己的Interceptor而言有两个很重要的注解，一个是@Intercepts，其值是一个@Signature数组。@Intercepts用于表明当前的对象是一个Interceptor，而@Signature则表明要拦截的接口、方法以及对应的参数类型。</p>
<p>那在真正的去写自己的拦截器之前，我们必须得要知道Mybatis拦截器应该作用在什么地方。</p>
<p>而他又是怎么起作用的。之前我们说过Mybatis拦截器主要是作用在四大组件上的,那么是怎么起作用的呢。</p>
<p>我们还是看源码。</p>
<p>我们在执行一次SQL过程中进行debug，当debug到SimpleExecutor执行器时，执行了doQuery方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException &#123;</span><br><span class="line">  Statement stmt = null;</span><br><span class="line">  try &#123;</span><br><span class="line">    Configuration configuration = ms.getConfiguration();</span><br><span class="line">    StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">    return handler.&lt;E&gt;query(stmt, resultHandler);</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    closeStatement(stmt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们主要看这行代码：</p>
<p>这行代码实际上生生成了除了执行器的其他三大组件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public StatementHandler newStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) &#123;</span><br><span class="line">  StatementHandler statementHandler = new RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">  statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br><span class="line">  return statementHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先new RoutingStatementHandler();看这个类的源码，发现实际上生成了delegate属性的StatementHandler对象,而且实际上的StatementHandler这个组件的方法执行就是执行delegate的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public RoutingStatementHandler(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) &#123;</span><br><span class="line"></span><br><span class="line">   switch (ms.getStatementType()) &#123;</span><br><span class="line">     case STATEMENT:</span><br><span class="line">       delegate = new SimpleStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">       break;</span><br><span class="line">     case PREPARED:</span><br><span class="line">       delegate = new PreparedStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">       break;</span><br><span class="line">     case CALLABLE:</span><br><span class="line">       delegate = new CallableStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">       break;</span><br><span class="line">     default:</span><br><span class="line">       throw new ExecutorException(&quot;Unknown statement type: &quot; + ms.getStatementType());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>我们看构造方法总共有三个可选的StatementHandler。</p>
<p>我们发现这三个StatementHandler都继承了BaseStatementHandler,我们知道在创建一个子类实例对象是一定会先执行父类的构造方法，那我们来看看BaseStatementHandler的构造方法都做了什么工作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">protected BaseStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) &#123;</span><br><span class="line">  this.configuration = mappedStatement.getConfiguration();</span><br><span class="line">  this.executor = executor;</span><br><span class="line">  this.mappedStatement = mappedStatement;</span><br><span class="line">  this.rowBounds = rowBounds;</span><br><span class="line"></span><br><span class="line">  this.typeHandlerRegistry = configuration.getTypeHandlerRegistry();</span><br><span class="line">  this.objectFactory = configuration.getObjectFactory();</span><br><span class="line"></span><br><span class="line">  if (boundSql == null) &#123; // issue #435, get the key before calculating the statement</span><br><span class="line">    generateKeys(parameterObject);</span><br><span class="line">    boundSql = mappedStatement.getBoundSql(parameterObject);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.boundSql = boundSql;</span><br><span class="line"></span><br><span class="line">  this.parameterHandler = configuration.newParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">  this.resultSetHandler = configuration.newResultSetHandler(executor, mappedStatement, rowBounds, parameterHandler, resultHandler, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看这个类的源码，我们会发现，她包含了其他两个组件，并且在构造方法里创建了这两个组件实现类的对象。</p>
<p>我们查看具体创建组件对象的源码，我们都会调用 interceptorChain.pluginAll方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public ParameterHandler newParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql) &#123;</span><br><span class="line">    ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">    parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);</span><br><span class="line">    return parameterHandler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public ResultSetHandler newResultSetHandler(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler,</span><br><span class="line">      ResultHandler resultHandler, BoundSql boundSql) &#123;</span><br><span class="line">    ResultSetHandler resultSetHandler = new DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);</span><br><span class="line">    resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);</span><br><span class="line">    return resultSetHandler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public StatementHandler newStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) &#123;</span><br><span class="line">    StatementHandler statementHandler = new RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">    statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br><span class="line">    return statementHandler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Executor newExecutor(Transaction transaction) &#123;</span><br><span class="line">    return newExecutor(transaction, defaultExecutorType);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Executor newExecutor(Transaction transaction, ExecutorType executorType) &#123;</span><br><span class="line">    executorType = executorType == null ? defaultExecutorType : executorType;</span><br><span class="line">    executorType = executorType == null ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    if (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">      executor = new BatchExecutor(this, transaction);</span><br><span class="line">    &#125; else if (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">      executor = new ReuseExecutor(this, transaction);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      executor = new SimpleExecutor(this, transaction);</span><br><span class="line">    &#125;</span><br><span class="line">    if (cacheEnabled) &#123;</span><br><span class="line">      executor = new CachingExecutor(executor);</span><br><span class="line">    &#125;</span><br><span class="line">    executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    return executor;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>终于找到了使用拦截器的地方了。</p>
<p>我们看看InterceptorChain的源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorChain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;Interceptor&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">      target = interceptor.plugin(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptor</span><span class="params">(Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">    interceptors.add(interceptor);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Interceptor&gt; <span class="title">getInterceptors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableList(interceptors);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类是收集所有拦截器的类，那如何收集所有的拦截器呢，通过配置文件加载到Configuration对象中。</p>
<p>通过如下方式写入Mybatis配置文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">      &lt;plugins&gt;  </span><br><span class="line">        &lt;plugin interceptor=&quot;com.wangcc.ssm.mybatis.interceptor.PageInterceptor&quot;&gt;  </span><br><span class="line">           &lt;property name=&quot;databaseType&quot; value=&quot;Oracle&quot;/&gt;  </span><br><span class="line">       &lt;/plugin&gt;  </span><br><span class="line">   &lt;plugin interceptor=&quot;com.wangcc.ssm.mybatis.interceptor.ParamMapInterceptor&quot;/&gt;  </span><br><span class="line">&lt;/plugins&gt;</span><br></pre></td></tr></table></figure>
<h3 id="三-实现自己的Mybatis拦截器"><a href="#三-实现自己的Mybatis拦截器" class="headerlink" title="三.实现自己的Mybatis拦截器"></a>三.实现自己的Mybatis拦截器</h3><p>好了，回到我们要解决的需求，我们要通过Mybatis拦截器来解决问题了。</p>
<p>通过前面几种情况，我们知道了，Mybatis自带的返回类型处理不能满足我们这个需求的要求。所以我们理所当然的想到，我们使用拦截器的目标是ResultSetHandler。我们知道返回结果是由ResultSetHandler的handleResultSets方法对当前的Statement处理后的返回结果，所以我们如果要改变返回结果的话就需要使用Mybatis的拦截器对ResultSetHandler接口的handleResultSets方法进行拦截。</p>
<p>这个时候我们就确定了该拦截器的注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts</span>(<span class="meta">@Signature</span>(method = <span class="string">"handleResultSets"</span>, type = ResultSetHandler.class, args = &#123; Statement.class &#125;))</span><br></pre></td></tr></table></figure>
<p>在之前分析四大组件对象生成时，说过每一个对象都要调用interceptorChain.pluginAll方法，这里的注解中的type = ResultSetHandler.class会使该拦截器只作用在ResultSetHandler上，但是目前来会对每一个ResultSetHandler都会起作用，所以我们还得在这个拦截器中想办法再做一层过滤，对于不需要拦截的调用Invocation的proceed()方法，而需要拦截的则实现我们自己的逻辑，返回对应的结果。现在我们要想的是怎么做这一层过滤以及怎么实现改变返回结果的效果。</p>
<ul>
<li><p>首先，这个过滤该怎样来实现呢，一般来说，通过parameterObj来过滤， 通过ParameterHandler得到：parameterHandler.getParameterObject();（我们定义的Dao层方法的参数）</p>
<p>​    那这里我们需要给出一个怎样的参数呢：</p>
<p>​    首先他得满足这几个条件</p>
<ul>
<li>（1）    可以指定哪个字段为返回Map的Key；</li>
<li>（2）    可以指定哪个字段为返回Map的Value；</li>
<li>（3）    可以附带其他参数；</li>
</ul>
</li>
</ul>
<p>那我们这里就给出我定义的参数ComplexParamMap</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComplexParamMap</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ParamMap paramMap;</span><br><span class="line">	<span class="keyword">private</span> T obj;<span class="comment">// 使用实体类的属性作为查询参数</span></span><br><span class="line">	<span class="keyword">private</span> Map&lt;String, Object&gt; params = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();<span class="comment">// 其他的参数我们把它分装成一个Map对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParamMap</span> <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 作为Key的字段对应MapParam的Key</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_FIELD = <span class="string">"mapKeyField"</span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 作为Value的字段对应MapParam的Key</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String VALUE_FIELD = <span class="string">"mapValueField"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ParamMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 指定keyField和valueField</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> keyField</span></span><br><span class="line"><span class="comment">	 *            Map中key对应的字段</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> valueField</span></span><br><span class="line"><span class="comment">	 *            Map中value对应的字段</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ParamMap</span><span class="params">(String keyField, String valueField)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.put(KEY_FIELD, keyField);</span><br><span class="line">		<span class="keyword">this</span>.put(VALUE_FIELD, valueField);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用泛型，方便 使用实体类的属性作为查询参数。</p>
<p>定义一个HashMap params 方便我们加入一些独立参数来作为查询参数。</p>
<p>ParamMap paramMap; 指定对应字段为返回Map的Key和Value；</p>
<ul>
<li><p>确定了过滤条件之后,我们就可以开始处理我们的逻辑了。</p>
<p>​    </p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts</span>(<span class="meta">@Signature</span>(method = <span class="string">"handleResultSets"</span>, type = ResultSetHandler.class, args = &#123; Statement.class &#125;))</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParamMapInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(ParamMapInterceptor.class);</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		Object target = invocation.getTarget();</span><br><span class="line">			<span class="comment">//目前Mybatis只有DefaultResultSetHandler这一种ResultSetHandler实现类</span></span><br><span class="line">      <span class="keyword">if</span> (target <span class="keyword">instanceof</span> DefaultResultSetHandler) &#123;</span><br><span class="line">          </span><br><span class="line">			DefaultResultSetHandler resultSetHandler = (DefaultResultSetHandler) target;</span><br><span class="line"></span><br><span class="line">			ParameterHandler parameterHandler = ReflectUtil.getFieldValue(resultSetHandler, <span class="string">"parameterHandler"</span>);</span><br><span class="line">			Object parameterObj = parameterHandler.getParameterObject();</span><br><span class="line">			<span class="keyword">if</span> (parameterObj <span class="keyword">instanceof</span> ComplexParamMap) &#123;</span><br><span class="line">				ComplexParamMap paramMap = (ComplexParamMap) parameterObj;</span><br><span class="line">				Statement stmt = (Statement) invocation.getArgs()[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">				<span class="keyword">return</span> handleResultSet(stmt.getResultSet(), paramMap);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> invocation.proceed();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> Object <span class="title">handleResultSet</span><span class="params">(ResultSet resultSet, ComplexParamMap cmap)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (resultSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">			ParamMap paramMap = cmap.getParamMap();</span><br><span class="line">			String keyField = paramMap.get(ParamMap.KEY_FIELD);</span><br><span class="line">			String valueField = paramMap.get(ParamMap.VALUE_FIELD);</span><br><span class="line">			Map&lt;Object, Object&gt; map = <span class="keyword">new</span> HashMap&lt;Object, Object&gt;();</span><br><span class="line">			<span class="comment">// 因为原方法返回的是List&lt;Object&gt;类型，所以</span></span><br><span class="line">			List&lt;Object&gt; resultList = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">					Object key = resultSet.getObject(keyField);</span><br><span class="line">					Object value = resultSet.getObject(valueField);</span><br><span class="line">					map.put(key, value);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				logger.error(<span class="string">"ParamMapInterceptor 的Method handleResultSet 使用ResultSet时出错"</span>);</span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				closeResultSet(resultSet);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			resultList.add(map);</span><br><span class="line">			<span class="keyword">return</span> resultList;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">closeResultSet</span><span class="params">(ResultSet resultSet)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (resultSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">				resultSet.close();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			logger.error(<span class="string">"关闭ResultSet资源时出错"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到现在我们就算完成了我们的第一个Mybatis拦截器了。</p>
<p>我们将这个拦截器注册到我们的Mybatis配置文件，注意在配置文件中的顺序位置。</p>
<p>然后开始测试，看是否能达到我们的要求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">	public void test() &#123;</span><br><span class="line">		SqlSession session = null;</span><br><span class="line">		System.out.println(&quot;Dd&quot;);</span><br><span class="line">		try &#123;</span><br><span class="line"></span><br><span class="line">			session = MybatisUtil.getCurrentSession();</span><br><span class="line">			CoachDao mapper = session.getMapper(CoachDao.class);</span><br><span class="line">			// Coach coach = mapper.getCoachById(1);</span><br><span class="line">			// System.out.println(coach);</span><br><span class="line">			ComplexParamMap&lt;Coach&gt; cmap = new ComplexParamMap&lt;Coach&gt;();</span><br><span class="line">			Coach coach = new Coach();</span><br><span class="line">			coach.setName(&quot;jackson&quot;);</span><br><span class="line">			ParamMap paramMap = new ParamMap(&quot;name&quot;, &quot;age&quot;);</span><br><span class="line">			cmap.setParamMap(paramMap);</span><br><span class="line">			Map&lt;String, Object&gt; params = new HashMap&lt;String, Object&gt;();</span><br><span class="line">			params.put(&quot;name&quot;, &quot;jackson&quot;);</span><br><span class="line">			cmap.setParams(params);</span><br><span class="line">			cmap.setObj(coach);</span><br><span class="line">			Map&lt;Object, Object&gt; map = mapper.queryMap(cmap);</span><br><span class="line">			System.out.println(JSON.toJSONString(map));</span><br><span class="line">			Page&lt;Coach, ?&gt; page = new Page&lt;&gt;();</span><br><span class="line">			page.setSelf(coach);</span><br><span class="line">			page.setPageSize(4);</span><br><span class="line">			page.setPageNo(2);</span><br><span class="line">			List&lt;Coach&gt; list = mapper.querybyPage(page);</span><br><span class="line">			System.out.println(JSON.toJSONString(list));</span><br><span class="line"></span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			// TODO: handle exception</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; finally &#123;</span><br><span class="line">			session.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>Mapper配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;queryMap&quot; resultType=&quot;map&quot; parameterType=&quot;ComplexParamMap&quot;&gt;</span><br><span class="line">select id,name from coach where name=#&#123;obj.name&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<p>查看输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">==&gt; Parameters: jackson(String)</span><br><span class="line">&lt;==    Columns: ID, NAME</span><br><span class="line">&lt;==        Row: 1, jackson</span><br><span class="line">&lt;==        Row: 2, jackson</span><br><span class="line">&lt;==        Row: 10, jackson</span><br><span class="line">&lt;==        Row: 5, jackson</span><br><span class="line">&lt;==        Row: 3, jackson</span><br><span class="line">&lt;==        Row: 11, jackson</span><br><span class="line">&lt;==      Total: 6</span><br><span class="line">&#123;1:&quot;jackson&quot;,2:&quot;jackson&quot;,3:&quot;jackson&quot;,5:&quot;jackson&quot;,10:&quot;jackson&quot;,11:&quot;jackson&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>完美的结果。</p>
<p>接下来我们再看下在Mybatis中使用广泛的分页插件拦截器。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2017/11/22/Mybatis插件/" data-id="cjbkujwuj0001ocbz8q6bt4rn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-HashMap" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/19/HashMap/" class="article-date">
  <time datetime="2017-11-19T10:15:42.019Z" itemprop="datePublished">2017-11-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java基础/">Java基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/19/HashMap/">HashMap</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="JDK7"><a href="#JDK7" class="headerlink" title="JDK7"></a>JDK7</h3><p>之前用JDK7的源码分析过一次HashMap,但是分析的并不完善，只分析了put方法和get方法，有一个很重要的方法 resize()方法并没有分析。</p>
<p>扩容方法resize()方法是一个很重要的方法，当我们调用put方法的时候，如果Hash数组的实际大小已经大于加载因子*容量的时候，我们就需要进行扩容操作，防止Hash冲突堆积太多，影响效率。 </p>
<p>jdk version:jdk1.7.0.0_76</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">           inflateTable(threshold);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">       <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">       <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">       <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">           Object k;</span><br><span class="line">           <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">               V oldValue = e.value;</span><br><span class="line">               e.value = value;</span><br><span class="line">               e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       modCount++;</span><br><span class="line">       addEntry(hash, key, value, i);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">    <span class="comment">//为什么不要移位操作&lt;&lt;</span></span><br><span class="line">    resize(<span class="number">2</span> * table.length);</span><br><span class="line">           hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">           bucketIndex = indexFor(hash, table.length);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       createEntry(hash, key, value, bucketIndex);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>我们看下这个方法的具体实现，然后看看在JDK8中是如何进行改进的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">       Entry[] oldTable = table;</span><br><span class="line">       <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="comment">//如果原来的容量已经是最大容量了,就只能任由他进行HASH碰撞</span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">           threshold = Integer.MAX_VALUE;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">       transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">       table = newTable;</span><br><span class="line">       threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line"><span class="comment">//对Hash数组进行遍历，所有元素遍历</span></span><br><span class="line">     <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">       <span class="comment">//对Hash数组每个元素后面带着的链表进行遍历，采用头插法将元素插入到新的Hash表中。    </span></span><br><span class="line">       <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">         <span class="comment">//先将e的下一个节点保存起来</span></span><br><span class="line">               Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">               <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                   e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">               &#125;</span><br><span class="line">         <span class="comment">//得到节点对应的hash数组的位置</span></span><br><span class="line">               <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">               <span class="comment">//开始头插</span></span><br><span class="line">         <span class="comment">//当前节点的next节点指向原头节点</span></span><br><span class="line">         </span><br><span class="line">         		e.next = newTable[i];</span><br><span class="line">         <span class="comment">//将当前节点置为头结点      </span></span><br><span class="line">         newTable[i] = e;</span><br><span class="line">         	<span class="comment">//将之前保存起来的next节点赋给e，开始下一个重复步骤进行头插</span></span><br><span class="line">               e = next;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>我们看到在JDK7中使用的resize()方法是对一个每个元素都进行重新找到在新的Hash数组的位置，采用的是头插法，也就是说将所有的元素都倒置了。</p>
<h3 id="JDK8"><a href="#JDK8" class="headerlink" title="JDK8"></a>JDK8</h3><p>HashMap和ConcurrentHashMap在JDK8中都进行了巨大的改变。</p>
<p>在HashMap中，为了增加插入删除等操作的效率，我们的HashMap在JDK8中的底层数据结构中增加了红黑树数据结构，当Hash数组的某个元素的链表长度大于8且数组大小大于。。。时，链表会变成红黑树，当链表长度大于8但长度没有超过。。。时会先执行扩容操作，而当扩容的时候，如果发现某个红黑树结构的元素个数小于6时，红黑树又会变成链表，这个具体实现，我们后面再说。</p>
<p>那么为什么我们要选用红黑树这种比较复杂的数据结构呢？</p>
<p>至于树形数据结构对于数组或者链表的优点，我们可以很简单的得出。</p>
<p>但是为什么是选择了红黑树而不是AVL（二叉平衡树）呢。这个就需要我们好好想想了。</p>
<p>红黑树的查询性能略逊色于AVL树，因为他比AVL树会稍微不平衡，也就是说红黑树的查询性能只比相同内容的avl树最多多一次比较，但是，红黑树在插入和删除上完爆avl树，avl树每次插入删除会进行大量的</p>
<p>平衡度计算，而红黑树为了维持红黑性质所做的红黑变换和旋转的开销，相较于avl树为了维持平衡的开销要小得多。</p>
<p>当然，红黑树并不适应所有应用树的领域。如果数据基本上是静态的，那么让他们待在他们能够插入，并且不影响平衡的地方会具有更好的性能。如果数据完全是静态的，例如，做一个哈希表，性能可能会更好一些。</p>
<p>在实际的系统中，例如，需要使用动态规则的防火墙系统，使用红黑树而不是散列表被实践证明具有更好的伸缩性。</p>
<p>简单说，如果你的应用中，搜索的次数远远大于插入和删除，那么选择AVL，如果搜索，插入删除次数几乎差不多，应该选择RB。</p>
<p><strong>红黑树是牺牲了严格的高度平衡的优越条件</strong>为 代价红黑树能够以O(log2 n)的时间复杂度进行搜索、插入、删除操作。此外，由于它的设计，任何不平衡都会在三次旋转之内解决。当然，还有一些更好的，但实现起来更复杂的数据结构 能够做到一步旋转之内达到平衡，但红黑树能够给我们一个比较“便宜”的解决方案。红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更高. </p>
<ul>
<li><p>Node内部类</p>
<p>我们先来看看HashMap的Hash数组的元素的数据结构是怎样的，在JDK7以及以前的版本中，都是使用的Entry作为元素，但是在JDK8中是使用Node,当然他肯定还是得实现Map.Entry\<k,v>这个接口</k,v></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h3><p>我们先关注put方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line">       <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">         <span class="comment">//先看table有没有初始化，没有的话初始化一个Hash数组</span></span><br><span class="line">       <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">           n = (tab = resize()).length;</span><br><span class="line">         <span class="comment">//如果数组元素没有被占用，则该节点赋给该数组元素，即为该数组元素后面的链表的头结点</span></span><br><span class="line">       <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">           tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           Node&lt;K,V&gt; e; K k;</span><br><span class="line">         <span class="comment">//如果链表头结点（Hash数组元素）的key与我们要插入的key相同，可以直接替换value</span></span><br><span class="line">           <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">               ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">               e = p;</span><br><span class="line">         <span class="comment">//如果不是头节点key相同，而且是红黑树类型节点,调用红黑树类型的插入方式</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">               e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">//如果不是直接替换头结点，那么开始进行咔咔的遍历</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                 <span class="comment">//当遍历完了之后还是没找着</span></span><br><span class="line">                   <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="comment">//新建一个node节点指向原最后一个节点的next节点</span></span><br><span class="line">                       p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                     <span class="comment">//如果遍历玩还没找到而且元素大于7了，厉害了，开始变身TreeNode，变成红黑树结构</span></span><br><span class="line">                       <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                           treeifyBin(tab, hash);</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                 <span class="comment">//如果遍历的过程中找到了key相同的，跳出循环</span></span><br><span class="line">                   <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                       ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   p = e;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">         <span class="comment">//然后在这里进行替换原值的操作</span></span><br><span class="line">           <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">               V oldValue = e.value;</span><br><span class="line">               <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                   e.value = value;</span><br><span class="line">               afterNodeAccess(e);</span><br><span class="line">      	<span class="comment">//当e!=null的时候直接返回了，之前我再这里纠结了一下为什么没有++modCount呀</span></span><br><span class="line">             <span class="comment">//fail-fast机制不要遵循了吗</span></span><br><span class="line">             <span class="comment">//仔细一看，扑街，只有当是替换Value的时候，而没有新增的Node节点的时候才会直接返回</span></span><br><span class="line">             <span class="comment">//当是处理TreeNode红黑树节点的时候，方法返回的是null，也就是e==null</span></span><br><span class="line">             <span class="comment">//当需要从链表转化为红黑树的时候，也是新增节点，e指向null的时候才执行。</span></span><br><span class="line">             <span class="comment">//也就是这个方法中所有返回e==null的分支对应的都是新增节点，会在下面的代码中执行++modCount;</span></span><br><span class="line">             <span class="comment">//所有不返回null的分支都对应着修改Value值。</span></span><br><span class="line">             <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        </span><br><span class="line">       ++modCount;</span><br><span class="line">       <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">           resize();</span><br><span class="line">       afterNodeInsertion(evict);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>具体代码就不再次分析了。</p>
<p>put方法的流程：</p>
<p>先确定Key位于哪个Hash桶，如果对应Hash数组中没有元素，直接将这个Node赋给Hash数组中该元素（table[i]=node）,如果找到了对应的Hash桶，如果对应的还是之前的链表结构，则遍历Node链表，如果发现Key已经存在，替换Value,返回，如果没找到，这个时候就需要新增节点了，直接用尾插法插到链表的尾部（这一点和JDK7以及之前插入方法不同，之前的插入方法是头插法）如果链表的长度已经不小于7了，链表的结构要变成红黑树的结构。如果这个hash桶的结构在插入新节点前已经变成了红黑树，则遍历TreeNode组成的红黑树结构，看是否Key已经存在，如果存在则替换，如果没有，则将新节点插入红黑树结构。这个流程我们能够狠轻松的整理出来，但是，如何用代码实现，如何用最少的代码实现，却并没有那么简单。如何用最少的代码，也就是如何找到规律，万物皆有形可测，编写程序就是要找到一些事情的规律，化繁为简。</p>
<ul>
<li>将链表结构改为红黑树结构</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">  <span class="comment">//如果还没有初始化表或者表的长度小于64，那么不急着将链表结构改为红黑树结构，先进行扩容操作。</span></span><br><span class="line">      <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">          resize();</span><br><span class="line">  <span class="comment">//开始转化，转化之前确认这个链表是有元素的</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">          TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//将Node节点转化为TreeNode节点</span></span><br><span class="line">              TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">              <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                  hd = p;</span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//prev是TreeNode的属性</span></span><br><span class="line">                  p.prev = tl;</span><br><span class="line">                <span class="comment">//注意next还是Node的属性</span></span><br><span class="line">                  tl.next = p;</span><br><span class="line">              &#125;</span><br><span class="line">              tl = p;</span><br><span class="line">          &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line"> <span class="comment">//让桶的第一个元素指向新建的红黑树头结点，以后这个桶里的元素就是红黑树而不是链表了</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">              hd.treeify(tab);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">          TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">              next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">              x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">              <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  x.parent = <span class="keyword">null</span>;</span><br><span class="line">                  x.red = <span class="keyword">false</span>;</span><br><span class="line">                  root = x;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                  K k = x.key;</span><br><span class="line">                  <span class="keyword">int</span> h = x.hash;</span><br><span class="line">                  Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">                  <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                      <span class="keyword">int</span> dir, ph;</span><br><span class="line">                      K pk = p.key;</span><br><span class="line">                      <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                          dir = -<span class="number">1</span>;</span><br><span class="line">                      <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                          dir = <span class="number">1</span>;</span><br><span class="line">                      <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                               (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                          dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">                      TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                      <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                          x.parent = xp;</span><br><span class="line">                          <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                              xp.left = x;</span><br><span class="line">                          <span class="keyword">else</span></span><br><span class="line">                              xp.right = x;</span><br><span class="line">                          root = balanceInsertion(root, x);</span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">  <span class="comment">//确保你返回的是root节点</span></span><br><span class="line">          moveRootToFront(tab, root);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>插入红黑树节点</p>
<p>putTreeVal是TreeNode的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">           Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">           TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">           <span class="comment">//这是一个无限循环，我们得看看他的退出条件</span></span><br><span class="line">           <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">             <span class="comment">//dir应该是左子树或右子树的一个判断</span></span><br><span class="line">               <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">             <span class="comment">//如果Node的hash值小于当前节点的值</span></span><br><span class="line">               <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                 <span class="comment">//右子树</span></span><br><span class="line">                   dir = -<span class="number">1</span>;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                 <span class="comment">//左子树</span></span><br><span class="line">                   dir = <span class="number">1</span>;</span><br><span class="line">             <span class="comment">//如果key相等hash值相等，即我们找到了这个节点返回</span></span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                   <span class="keyword">return</span> p;</span><br><span class="line">             <span class="comment">//</span></span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                         <span class="comment">// /**</span></span><br><span class="line">    * Returns x<span class="string">'s Class if it is of the form "class C implements</span></span><br><span class="line"><span class="string">    * Comparable&lt;C&gt;", else null.</span></span><br><span class="line"><span class="string">    */</span></span><br><span class="line"><span class="string">                         (kc = comparableClassFor(k)) == null) ||</span></span><br><span class="line"><span class="string">                        //</span></span><br><span class="line"><span class="string">   /**</span></span><br><span class="line"><span class="string">    * Returns k.compareTo(x) if x matches kc (k'</span>s screened comparable</span><br><span class="line">    * <span class="class"><span class="keyword">class</span>), <span class="title">else</span> 0.</span></span><br><span class="line"><span class="class">    */</span></span><br><span class="line"><span class="class">                        (<span class="title">dir</span> </span>= compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">                                 <span class="comment">//如果当前节点和要添加的节点哈希值相等，但是两个节点的键不是一个类，只好去挨个对比左右孩子 </span></span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                       TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                       searched = <span class="keyword">true</span>;</span><br><span class="line">                       <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                            (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                           ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                            (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                           <span class="keyword">return</span> q;</span><br><span class="line">                   &#125;</span><br><span class="line">                 <span class="comment">//                //哈希值相等，但键无法比较，只好通过特殊的方法给个结果</span></span><br><span class="line"><span class="comment">//这个方法用于 a 和 b 哈希值相同但是无法比较时，直接根据两个引用的地址进行比较</span></span><br><span class="line">   <span class="comment">//这里源码注释也说了，这个树里不要求完全有序，只要插入时使用相同的规则保持平衡即可</span></span><br><span class="line">                   dir = tieBreakOrder(k, pk);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">               <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">                   TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">                   <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                       xp.left = x;</span><br><span class="line">                   <span class="keyword">else</span></span><br><span class="line">                       xp.right = x;</span><br><span class="line">                   xp.next = x;</span><br><span class="line">                   x.parent = x.prev = xp;</span><br><span class="line">                   <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">                       ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">                   moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>红黑树的插入</p>
<p>首先，我们知道，当插入节点的父节点的是黑色时，不用执行任何操作。</p>
<p>所以，要调整的是当插入节点的父节点是红色时，而插入的节点是红色的时候，是不会改变 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点这一条的，主要要注意的就是红色节点的子节点一定是黑节点这一条。</p>
<p>关于它的特性，需要注意的是：</p>
<p>分析之前，我们要牢记一点，插入之前这棵树是从局部到整体都符合红黑树的定义的。</p>
<p>而且我们调整的思路，永远都是先让底层局部符合定义，再逐级往上调整。</p>
<p>再强调一次，下列穷举的情况都是建立在这棵树符合红黑树的定义的情况下。</p>
<ul>
<li><p>当父节点和叔叔节点都是红色</p>
<p>这个时候我们插入一个红色节点，很显然违反了红色节点的子节点是黑色节点这个规定。</p>
<p>这个我们就像某些时刻处理异常一样，先给他把问题抛给上层。将叔叔节点和父节点都变成黑色，祖父节点变成红色。这样做至少保证了从祖父节点开始是局部符合红黑树的定义的（除了根节点是黑色节点不能确定以外），刚开始，我以为这种情况就大功告成了，后来才发现要考虑一种情况，那就是我们能确定这种情况下祖父节点是黑色，那么这种情况下祖父的父节点是红色还是黑色，我们是无法知道的，倘若是红色，那么当祖父变成红色后，就违反了原则了。所以我们要将祖父节点看成是新的当前节点，继续进行调整（因为已经保证祖父节点以下的都满足了）</p>
</li>
<li><p>当父节点是红色 叔叔节点是黑色且插入节点是父节点的左节点</p>
<p>首先，我们说过插入一个新节点的操作是不会影响 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点这一条的，因为默认插入的是红色，但是会影响红色的子节点必须是黑色这一条。</p>
<p>在这种情况下，祖父是黑色，叔叔是黑色，父节点是红色，我们还是秉守我们的一大原则，把问题尽可能往上层抛，我们从祖父节点开始看，设从祖父节点到左边（父节点）某一个叶子节点的路径包含的黑节点为n（父节点以下的黑节点）+1（祖父节点本身），到右边（叔叔节点）某一个叶子节点的路径包含的黑色节点为n-1(叔叔节点以下的黑节点)+1（叔叔节点）+1（祖父节点本身），都为n+1个黑节点。我们将父节点设为黑色，祖父节点设为红色，就解决了红色的子节点是黑色这一条不遵守的问题，但是这样做会带来新的问题， 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点这一条不符合了。相当于祖父节点到父节点这一分支（n+1）多了一个黑节点而到叔叔那一分支(n 少了原祖父节点这一黑节点)少了一个黑节点，这显然违反了我们的原则，那怎么样去调整呢，这个时候我们以父节点为中心开始右旋。使父节点变成祖父节点，那么现在从祖父节点到左边（原父节点）这一分支还是n+1,右边，由于新的祖父节点是祖父节点是黑色节点，所以黑节点+1为n+1,所以从祖父节点开始，都符合红黑树，此时，祖父节点又成为了黑节点，无需再进行改动。</p>
</li>
<li><p>当父节点是红色 叔叔节点是黑色且插入节点是父节点的右节点</p>
<p>很明显当情况为第二种情况的时候，已经调整好了，所以我们只需要将这种情况调整为第二种情况即可。如何做到第二种情况，以父节点为中心，进行左旋操作即可。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//先将插入的节点设为红色，为什么设为红色，设为红色不会违背，每个节点都其子孙节点的路径经过的黑色节点都一样多这条原则，我们调整红黑树的原则是让他尽可能的少违背红黑树的五大原则，然后就是尽可能的先做到局部符合原则。但是设为红色可能会违反红色节点的子节点一定是黑色这条原则，那么我们就来穷举下违背原则时可能出现的所有情况，有时候你别看着穷举好像很笨的样子，但是有时候大道至简才是真理，最直观的去分析可能会更快的得出结论。</span></span><br><span class="line"> 暴力穷举 </span><br><span class="line"> <span class="number">1</span>.父节点是红色节点，叔叔节点是红色节点</span><br><span class="line">   将父节点和叔叔节点都涂黑，将祖父节点涂红，此时，从祖父节点开始局部符合原则，然后把问题往上抛，将祖父节点设为当前节点。</span><br><span class="line"> <span class="number">2</span>.父节点是红色节点，叔叔节点是黑色节点</span><br><span class="line">    I.父节点是红色节点，叔叔节点是黑色节点，且当前节点是父节点的左子节点</span><br><span class="line">   	很显然，违反的是红色节点的子节点是黑色节点这一条，那么我们就把父节点涂黑，祖父节点（黑色）涂红，然后以祖父节点右旋一波，perfect，强行稳住了。符合原则。</span><br><span class="line">    II.父节点是红色节点，叔叔节点是黑色节点，且当前节点是父节点的右子节点</span><br><span class="line">    x.red = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">      <span class="comment">//如果是根节点，不多逼逼，直接将其涂黑，搞定</span></span><br><span class="line">        <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//如果父节点不是红色或者祖父节点是空的，即父节点是根节点，这里根节点必须是黑节点呀，为什么还要加一个祖父节点为空的判断呀</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">      <span class="comment">//如果父节点是祖父节点的左节点</span></span><br><span class="line">        <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">          <span class="comment">//如果叔叔节点是红色</span></span><br><span class="line">            <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123;</span><br><span class="line">              <span class="comment">//      将父节点和叔叔节点都涂黑，将祖父节点涂红，此时，从祖父节点开始局部符合原则，然后把问题往上抛，将祖父节点设为当前节点。</span></span><br><span class="line">              xppr.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//叔叔节点是黑色</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//如果当前节点是父节店的右子节点，情况2的I</span></span><br><span class="line">                <span class="keyword">if</span> (x == xp.right) &#123;</span><br><span class="line">                  <span class="comment">//以父节点为中心强行来一波左旋操作，使得父节点变为当前节点的左子节点，然后将父节点置为当前节点</span></span><br><span class="line">                  <span class="comment">//也就是变为当前节点是父节点左子节点的情况</span></span><br><span class="line">                    root = rotateLeft(root, x = xp);</span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">//现在就是到了情况2的II了</span></span><br><span class="line">              <span class="comment">//如果父节点不为空</span></span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="comment">//父节点置为黑色</span></span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                      <span class="comment">//祖父节点置为红色</span></span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                      <span class="comment">//右旋</span></span><br><span class="line">                        root = rotateRight(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (xppl != <span class="keyword">null</span> &amp;&amp; xppl.red) &#123;</span><br><span class="line">                xppl.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == xp.left) &#123;</span><br><span class="line">                    root = rotateRight(root, x = xp);</span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateLeft(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个左旋的代码，看着其实很烦呀，虽然一眼看过去很简洁，但是太多骚操作了，在之前代码简洁之道的学习中，我们多次强调过千万不要在平时编程中写只有自己看的懂代码，千万不要喜欢用三元表达式，最好做到一句话只做一件事，写代码，让机器看得懂是最简单的事，如何让人看懂才是问题的关键所在。当然编写JDK源码的人都是大神，追求简单高效无可厚非，我们这些平凡人还是不要秀骚操作比较好。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateLeft</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class="line">	<span class="comment">//左旋操作，实际就是更改下节点的互相指向</span></span><br><span class="line">	<span class="comment">//左旋操作前提，首先右子节点要存在     当前节点指p.right</span></span><br><span class="line"><span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (r = p.right) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//这句代码其实做了两件事（具体的分还不止）,首先进行链式赋值，然后判断值是否为null</span></span><br><span class="line">  <span class="comment">//如果当前节点有左孩子的话，将当前节点的左节点赋给父节点的右孩子</span></span><br><span class="line">                <span class="keyword">if</span> ((rl = p.right = r.left) != <span class="keyword">null</span>)</span><br><span class="line">                  <span class="comment">//然后让当前节点的左节点的父节点设为父节点</span></span><br><span class="line">                    rl.parent = p;</span><br><span class="line">  <span class="comment">//赋值操作：得到祖父节点，并将祖父节点置为当前节点的父节点</span></span><br><span class="line">  <span class="comment">//判断操作，判断父节点是不是根节点，如果是根节点，那么当前节点就会被置为根节点，根节点默认为black</span></span><br><span class="line">                <span class="keyword">if</span> ((pp = r.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">                    (root = r).red = <span class="keyword">false</span>;</span><br><span class="line">  <span class="comment">//新的关系连接起来，很好看懂</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p)</span><br><span class="line">                    pp.left = r;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pp.right = r;</span><br><span class="line">                r.left = p;</span><br><span class="line">                p.parent = r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="REMOVE"><a href="#REMOVE" class="headerlink" title="REMOVE"></a>REMOVE</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public V remove(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    return (e = removeNode(hash(key), key, null, false, true)) == null ?</span><br><span class="line">        null : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">          (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">          Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">  	<span class="comment">//如果是头结点（）</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">              ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">              node = p;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                  node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="keyword">do</span> &#123;</span><br><span class="line">                      <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                          ((k = e.key) == key ||</span><br><span class="line">                           (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                          node = e;</span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">                      p = e;</span><br><span class="line">                  &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                               (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">              <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                  ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                  tab[index] = node.next;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                  p.next = node.next;</span><br><span class="line">              ++modCount;</span><br><span class="line">              --size;</span><br><span class="line">              afterNodeRemoval(node);</span><br><span class="line">              <span class="keyword">return</span> node;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>红黑树的删除</p>
<p> 删除操作应该是红黑树中最难的操作了，说实话，我看了四五遍了，都不是很明白。</p>
<p>首先删除节点就分三种情况，</p>
<ul>
<li><p>无子节点，最简单，直接删除，不多逼逼</p>
<p>如果删除的节点是红色的节点，不用处理，如果是黑色节点就需要调整红黑树的结构。</p>
</li>
<li><p>一个子节点，不多逼逼，直接替代删除节点</p>
<p>如果删除的节点是红色的节点，依旧是不需要处理，但是如果删除的是黑色节点，需要调整红黑树的结构</p>
</li>
<li><p>两个子节点，瞬间爆炸，愣是好几次都没搞透彻。在学习二叉树的删除的时候，对这种情况已经说过了，要灵活思考，找到删除节点的后续节点，然后将后续节点替代删除节点，然后来删除后续节点。</p>
<p>中序后续节点是二叉树中Key大于删除节点的最小值，也就是删除节点的右子树的左子树中最左边的节点。该节点不可能存在左节点，只可能有右节点。后继节点只可能有右节点或者没有子节点，也就对应着前面说的头两种情况了，只不过当前节点从要删除的节点变成了后继节点。</p>
<p>​         当后继节点含有右节点时，</p>
<p>​    删除后续节点，将后续节点的右节点称为后续节点的父节点的左节点。</p>
<p>​    我们就来通过后继节点的子节点和父节点来分析，称后继节点的子节点为当前节点。</p>
<ul>
<li><p>如果当前节点是红色的，说明刚刚移走的后继节点是黑色的，那么不管后继节点的父节点是啥颜色，我们只要将当前节点涂黑就可以了，红-黑树的平衡性就可以恢复。</p>
</li>
<li><p>所以注意分析的情况就是当前节点是黑色的情况</p>
<ul>
<li><p>这种情况是可以直接解决红黑树调整的情况。在这种情况下，我们把兄弟节点的颜色和父节点颜色调换一下（这样一来就给当前节点那一分支添加了一个黑色节点，然后兄弟节点这一分支也并没有少黑色节点，但是还有可能出现的情况需要再考虑：原来的父节点是红色节点，那么就会造成现在的兄弟节点和兄弟节点的右节点都是红色节点，就很尴尬，会造成红色节点的子节点还是红节点的情况，那么这时我们就需要做出改变了</p>
<p>），所以我们还需要将现在的兄弟节点的右节点变为黑色，但是这样又使得兄弟节点这一分支的黑色节点多了一个，这个时候咋办呢，围绕当前的父节点来一波左旋操作，便解决了多一个黑节点的问题，同时最重要的是兄弟节点（颜色是原来的父节点的颜色，这很重要）成为了父节点，目前，父节点及其以下分支已经完成了红黑树调整，又有新的父节点的颜色和原有的父节点相同，这就是说已经完成了所有的调整操作了。</p>
<p>​</p>
</li>
<li><p>当前节点是黑色的，且兄弟节点是黑色的，且兄弟节点的两个子节点均为黑色的；</p>
<p>把兄弟节点涂成红色，这样在父节点及以下分支实现了符合红黑树，但是整体来说就使得父节点之一分支相对于其他分支少了个黑色节点，也就是说，我们这样左就把调整红黑树的任务推给了上一层节点，把问题不停的往上抛，直到根节点，也就自然的解决了问题，把问题逐层往上抛在插入的时候已经强调过实用性和重要性了，然后我们就可以把父节点设为当前节点继续调整了。</p>
</li>
<li><p>当前节点是黑色的，且兄弟节点是黑色的，且兄弟节点的左子节点是红色，右子节点时黑色的；</p>
<p>这个你做一个旋转操作，自然就变成了第一种情况啦，将兄弟节点的左子节点变为黑色，兄弟节点变为红色，以兄弟节点为中心，来一波右旋操作，就成了第一种情况啦。</p>
</li>
<li><p>当前节点是黑色的，且兄弟节点是红色的（那么父节点和兄弟节点的子节点肯定是黑色的）；</p>
<p>很显然，这种情况只要先把他转化为当前节点和兄弟节点都是黑色的情况就好啦。</p>
<p>怎么做呢，这里相关的节点都是能确定颜色的，要完成这个操作还是比较简单的。</p>
<p>先将兄弟节点和父节点的颜色调换，然后以父节点为中心左旋即可。</p>
</li>
</ul>
</li>
</ul>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>我们注意到我们分析两个子节点时，当后续节点有子节点时，我们给出了具体调整红黑树的方案</p>
<p>那我们有没有办法在其他情况下也用到这种解决方案呢，如果能用到那我们就解决了红黑树删除节点的问题了。</p>
<p>那我们再回头来分析下我们在后续节点有子节点是怎么解决的。</p>
<p>我们是将右子节点补上后继的位置，我们称这个右子节点为替代节点replacement节点，成为后继节点父节点的子节点，然后用replacement和其父节点和其兄弟节点的各种情况来分析得到解决方案。</p>
<p>那么对于其他情况下，我们能不能尝试得到replacement来构造这种解决方案呢。</p>
<p>1、我们来看之前说的当前节点只有一个子节点的情况，我们说过这种情况是将子节点代替删除节点，当删除节点为黑色节点的时候是需要看是否需要调整红黑树的。那么这种情况我们可以很容易的得到这里可以将子节点设为replacement</p>
<p>2、删除节点没有子节点</p>
<p>这种情况下当删除节点是黑色的时候是一定会出现违反红黑树定义的情况的，但是这个时候没有子节点呀，咋办呀，上哪找replacement呀，这个时候我们就把当前要删除的节点当做是replacement，就当此时这个分支当前是少一个黑节点的（为什么呢，因为这个replacement节点终于要删除的），然后使用replacement调整红黑树、</p>
<p>3.后继节点是没有子节点的</p>
<p>那这种情况那和2一样，也是抓当前要删除的节点当做replacement的，最后把这个给删了。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeTreeNode</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        <span class="comment">//为什么JDK源码要整这么多骚操作呀，这个局部变量的命名我真的了</span></span><br><span class="line">            TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl;</span><br><span class="line">            TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev;</span><br><span class="line">        <span class="comment">//去掉要删除的节点</span></span><br><span class="line">            <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">                tab[index] = first = succ;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pred.next = succ;</span><br><span class="line">            <span class="keyword">if</span> (succ != <span class="keyword">null</span>)</span><br><span class="line">                succ.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (root.parent != <span class="keyword">null</span>)</span><br><span class="line">                root = root.root();</span><br><span class="line">            <span class="keyword">if</span> (root == <span class="keyword">null</span> || root.right == <span class="keyword">null</span> ||</span><br><span class="line">                (rl = root.left) == <span class="keyword">null</span> || rl.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                tab[index] = first.untreeify(map);  <span class="comment">// too small</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>, pl = left, pr = right, replacement;</span><br><span class="line">            <span class="keyword">if</span> (pl != <span class="keyword">null</span> &amp;&amp; pr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; s = pr, sl;</span><br><span class="line">              <span class="comment">//找到后继节点</span></span><br><span class="line">                <span class="keyword">while</span> ((sl = s.left) != <span class="keyword">null</span>) <span class="comment">// find successor</span></span><br><span class="line">                    s = sl;</span><br><span class="line">              <span class="comment">//交换颜色</span></span><br><span class="line">                <span class="keyword">boolean</span> c = s.red; s.red = p.red; p.red = c; <span class="comment">// swap colors</span></span><br><span class="line">                TreeNode&lt;K,V&gt; sr = s.right;</span><br><span class="line">                TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">              <span class="comment">//如果后继节点就是当前节点的右子节点，即右子节点没有左子树</span></span><br><span class="line">                <span class="keyword">if</span> (s == pr) &#123; <span class="comment">// p was s's direct parent</span></span><br><span class="line">                  <span class="comment">//两个交换一下</span></span><br><span class="line">                    p.parent = s;</span><br><span class="line">                    s.right = p;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">//后继节点的父节点</span></span><br><span class="line">                    TreeNode&lt;K,V&gt; sp = s.parent;</span><br><span class="line">                  <span class="comment">//后继节点的父节点成为当前接的父节点</span></span><br><span class="line">                  <span class="comment">//用当前节点代替后继节点</span></span><br><span class="line">                    <span class="keyword">if</span> ((p.parent = sp) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                      <span class="comment">//如果后继节点是其父节点的左节点，则当前节点设为其父节点的左节点</span></span><br><span class="line">                        <span class="keyword">if</span> (s == sp.left)</span><br><span class="line">                            sp.left = p;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            sp.right = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="comment">//将后继节点代替当前节点的位置</span></span><br><span class="line">                    <span class="keyword">if</span> ((s.right = pr) != <span class="keyword">null</span>)</span><br><span class="line">                        pr.parent = s;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">//相当于将当前节点和后继节点互相换位置，包括颜色</span></span><br><span class="line">             <span class="comment">//因为当前节点要代替当前节点，当然p.left==null；</span></span><br><span class="line">                p.left = <span class="keyword">null</span>;</span><br><span class="line">              <span class="comment">//继续完成当前节点代替后继节点的操作</span></span><br><span class="line">                <span class="keyword">if</span> ((p.right = sr) != <span class="keyword">null</span>)</span><br><span class="line">                    sr.parent = p;</span><br><span class="line">              <span class="comment">//将后继节点代替当前节点的位置</span></span><br><span class="line">                <span class="keyword">if</span> ((s.left = pl) != <span class="keyword">null</span>)</span><br><span class="line">                    pl.parent = s;</span><br><span class="line">              <span class="comment">//如果当前节点是根节点，直接替代根节点</span></span><br><span class="line">                <span class="keyword">if</span> ((s.parent = pp) == <span class="keyword">null</span>)</span><br><span class="line">                    root = s;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                    pp.left = s;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pp.right = s;</span><br><span class="line">              <span class="comment">//前面就是完成后继节点和当前节点位置互换的操作。不难理解，但是目前没理解的是，为什么要用当前节点来替代后继节点的位置，这个位置不是要删除掉的吗</span></span><br><span class="line">              <span class="comment">//接下来的操作就需要思考了</span></span><br><span class="line">              <span class="comment">//如果后继节点的右子树存在</span></span><br><span class="line">                <span class="keyword">if</span> (sr != <span class="keyword">null</span>)</span><br><span class="line">                    replacement = sr;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    replacement = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pl != <span class="keyword">null</span>)</span><br><span class="line">                replacement = pl;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pr != <span class="keyword">null</span>)</span><br><span class="line">                replacement = pr;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                replacement = p;</span><br><span class="line">        <span class="comment">//当前节点有两个孩子</span></span><br><span class="line">        <span class="comment">//如果后继节点没有孩子节点，则replacement=p;</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">//如果有右孩子节点repalcement都不会为当前节点p而是后继节点的右孩子</span></span><br><span class="line">               <span class="comment">//如果当前节点没有孩子节点，repalcement=p;</span></span><br><span class="line">        <span class="comment">//如果有一个节点的情况 replacement=相应的孩子节点</span></span><br><span class="line">            <span class="keyword">if</span> (replacement != p) &#123;</span><br><span class="line">              <span class="comment">//虽然到这里我终于看懂了，但是为什么我觉得这个操作非常非常的多余呀</span></span><br><span class="line">                TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;</span><br><span class="line">                <span class="keyword">if</span> (pp == <span class="keyword">null</span>)</span><br><span class="line">                    root = replacement;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                    pp.left = replacement;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pp.right = replacement;</span><br><span class="line">                p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">	<span class="comment">//因为后继节点和当前节点的颜色互换了。p.red就代表后继节点的颜色，很明显，当要真正删除的后继节点是红色的时候，不会对红黑树有任何影响，不需要做任何改动，而当后继节点的颜色是黑色时，就有可能影响节点到子孙的路径中黑色节点的个数相同这一条，就需要调整红黑树</span></span><br><span class="line">        </span><br><span class="line">            TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);</span><br><span class="line"><span class="comment">//如果后继节点没有子节点或者删除节点本身就没有子节点，我们只能拿要删除的节点先去顶上，然后执行完</span></span><br><span class="line">       <span class="comment">// balanceDeletion操作之后再去删除</span></span><br><span class="line">            <span class="keyword">if</span> (replacement == p) &#123;  <span class="comment">// detach</span></span><br><span class="line">                TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">                p.parent = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (pp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                        pp.left = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.right)</span><br><span class="line">                        pp.right = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (movable)</span><br><span class="line">                moveRootToFront(tab, r);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceDeletion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpl, xpr;;)  &#123;</span><br><span class="line">            <span class="comment">//如果当前节点就是root节点，直接返回</span></span><br><span class="line">              <span class="keyword">if</span> (x == <span class="keyword">null</span> || x == root)</span><br><span class="line">                  <span class="keyword">return</span> root;</span><br><span class="line">            <span class="comment">//如果删除的就是root节点，当前节点就顶上去成为root节点，这个时候要记得颜色要置为black</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//置为  </span></span><br><span class="line">                x.red = <span class="keyword">false</span>;</span><br><span class="line">                  <span class="keyword">return</span> x;</span><br><span class="line">              &#125;</span><br><span class="line">   	<span class="comment">//如果当前节点是红色，将当前节点改为黑色就行了，因为如果当前节点是红色，我们只要把节点改为黑色既可以弥补去掉后继节点所失去的一个黑色节点。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (x.red) &#123;</span><br><span class="line">			                </span><br><span class="line">                  x.red = <span class="keyword">false</span>;</span><br><span class="line">                  <span class="keyword">return</span> root;</span><br><span class="line">              &#125;</span><br><span class="line">            <span class="comment">//两种情况，当前节点是左孩子，或当前节点是右孩子，我们只需对其中一种情况分析即可，因为这两种情况是对称的。</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> ((xpl = xp.left) == x) &#123;</span><br><span class="line">                <span class="comment">//当前节点是黑色的，，则他的兄弟节点要么是黑色要么是红色</span></span><br><span class="line">                <span class="comment">//如果是红色，那兄弟节点的孩子节点是黑色，父节点肯定是黑色。</span></span><br><span class="line">                <span class="comment">//也就是说，红色节点这种情况是唯一确定的，而兄弟节点是黑色的情况会有好几种情况</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                所以，我们就先将</span></span><br><span class="line"><span class="comment">                1.兄弟节点是红色，这种情况转化为当前节点和兄弟节点都是黑色的情况。</span></span><br><span class="line"><span class="comment">                </span></span><br><span class="line"><span class="comment">                </span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                  <span class="keyword">if</span> ((xpr = xp.right) != <span class="keyword">null</span> &amp;&amp; xpr.red) &#123;</span><br><span class="line">                      xpr.red = <span class="keyword">false</span>;</span><br><span class="line">                      xp.red = <span class="keyword">true</span>;</span><br><span class="line">                      root = rotateLeft(root, xp);</span><br><span class="line">                      xpr = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.right;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span> (xpr == <span class="keyword">null</span>)</span><br><span class="line">                      x = xp;</span><br><span class="line">                  <span class="keyword">else</span> &#123;</span><br><span class="line">                      TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right;</span><br><span class="line">                      <span class="keyword">if</span> ((sr == <span class="keyword">null</span> || !sr.red) &amp;&amp;</span><br><span class="line">                          (sl == <span class="keyword">null</span> || !sl.red)) &#123;</span><br><span class="line">                          xpr.red = <span class="keyword">true</span>;</span><br><span class="line">                          x = xp;</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="keyword">else</span> &#123;</span><br><span class="line">                          <span class="keyword">if</span> (sr == <span class="keyword">null</span> || !sr.red) &#123;</span><br><span class="line">                              <span class="keyword">if</span> (sl != <span class="keyword">null</span>)</span><br><span class="line">                                  sl.red = <span class="keyword">false</span>;</span><br><span class="line">                              xpr.red = <span class="keyword">true</span>;</span><br><span class="line">                              root = rotateRight(root, xpr);</span><br><span class="line">                              xpr = (xp = x.parent) == <span class="keyword">null</span> ?</span><br><span class="line">                                  <span class="keyword">null</span> : xp.right;</span><br><span class="line">                          &#125;</span><br><span class="line">                          <span class="keyword">if</span> (xpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                              xpr.red = (xp == <span class="keyword">null</span>) ? <span class="keyword">false</span> : xp.red;</span><br><span class="line">                              <span class="keyword">if</span> ((sr = xpr.right) != <span class="keyword">null</span>)</span><br><span class="line">                                  sr.red = <span class="keyword">false</span>;</span><br><span class="line">                          &#125;</span><br><span class="line">                          <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                              xp.red = <span class="keyword">false</span>;</span><br><span class="line">                              root = rotateLeft(root, xp);</span><br><span class="line">                          &#125;</span><br><span class="line">                          x = root;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span> &#123; <span class="comment">// symmetric</span></span><br><span class="line">                  <span class="keyword">if</span> (xpl != <span class="keyword">null</span> &amp;&amp; xpl.red) &#123;</span><br><span class="line">                      xpl.red = <span class="keyword">false</span>;</span><br><span class="line">                      xp.red = <span class="keyword">true</span>;</span><br><span class="line">                      root = rotateRight(root, xp);</span><br><span class="line">                      xpl = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.left;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span> (xpl == <span class="keyword">null</span>)</span><br><span class="line">                      x = xp;</span><br><span class="line">                  <span class="keyword">else</span> &#123;</span><br><span class="line">                      TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right;</span><br><span class="line">                      <span class="keyword">if</span> ((sl == <span class="keyword">null</span> || !sl.red) &amp;&amp;</span><br><span class="line">                          (sr == <span class="keyword">null</span> || !sr.red)) &#123;</span><br><span class="line">                          xpl.red = <span class="keyword">true</span>;</span><br><span class="line">                          x = xp;</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="keyword">else</span> &#123;</span><br><span class="line">                          <span class="keyword">if</span> (sl == <span class="keyword">null</span> || !sl.red) &#123;</span><br><span class="line">                              <span class="keyword">if</span> (sr != <span class="keyword">null</span>)</span><br><span class="line">                                  sr.red = <span class="keyword">false</span>;</span><br><span class="line">                              xpl.red = <span class="keyword">true</span>;</span><br><span class="line">                              root = rotateLeft(root, xpl);</span><br><span class="line">                              xpl = (xp = x.parent) == <span class="keyword">null</span> ?</span><br><span class="line">                                  <span class="keyword">null</span> : xp.left;</span><br><span class="line">                          &#125;</span><br><span class="line">                          <span class="keyword">if</span> (xpl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                              xpl.red = (xp == <span class="keyword">null</span>) ? <span class="keyword">false</span> : xp.red;</span><br><span class="line">                              <span class="keyword">if</span> ((sl = xpl.left) != <span class="keyword">null</span>)</span><br><span class="line">                                  sl.red = <span class="keyword">false</span>;</span><br><span class="line">                          &#125;</span><br><span class="line">                          <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                              xp.red = <span class="keyword">false</span>;</span><br><span class="line">                              root = rotateRight(root, xp);</span><br><span class="line">                          &#125;</span><br><span class="line">                          x = root;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h3 id="RESIZE"><a href="#RESIZE" class="headerlink" title="RESIZE()"></a>RESIZE()</h3><p>最后，我们再来看看resize()的改动</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">       <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">       <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">       <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">               threshold = Integer.MAX_VALUE;</span><br><span class="line">               <span class="keyword">return</span> oldTab;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">               newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">           newCap = oldThr;</span><br><span class="line">       <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">           newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">           newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">           newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">       &#125;</span><br><span class="line">       threshold = newThr;</span><br><span class="line">       <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">           Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">       table = newTab;</span><br><span class="line">       <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">               Node&lt;K,V&gt; e;</span><br><span class="line">               <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                   <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                       newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                       ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                   <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                       Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; next;</span><br><span class="line">                       <span class="keyword">do</span> &#123;</span><br><span class="line">                           next = e.next;</span><br><span class="line">                           <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                               <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                   loHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   loTail.next = e;</span><br><span class="line">                               loTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="keyword">else</span> &#123;</span><br><span class="line">                               <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                   hiHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   hiTail.next = e;</span><br><span class="line">                               hiTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                       <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                           newTab[j] = loHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                           newTab[j + oldCap] = hiHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> newTab;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>代码比较简单，就不细说了，很容易看懂，差别就在jdk7扩容的时候会让链表倒置，而jdk8不会倒置链表</p>
<p>。jdk8中用hash&amp;newcap-1的方法来确定元素位于的hash桶的位置，为0不用移位置，为1就在table[i+oldCap]上了。</p>
<p>当然resize()的时候会对TreeNode红黑树有一些改动，如果新的红黑树长度小于6，就要还原成链表。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2017/11/19/HashMap/" data-id="cjb52pqzd000ggkbzohsi58ih" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/19/hello-world/" class="article-date">
  <time datetime="2017-11-19T09:55:11.801Z" itemprop="datePublished">2017-11-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/19/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2017/11/19/hello-world/" data-id="cjb52pr05000tgkbzii76vd65" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/4/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java-WEB/">Java WEB</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaWEB/">JavaWEB</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java基础/">Java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mybatis/">Mybatis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringMVC/">SpringMVC</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js-css/">js&&css</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/01/31/DelegatingFilterProxy/">DelegatingFilterProxy</a>
          </li>
        
          <li>
            <a href="/2018/01/31/--Java中的引用传递/">Java中的引用传递</a>
          </li>
        
          <li>
            <a href="/2018/01/31/--装饰者模式/">装饰者模式(一)</a>
          </li>
        
          <li>
            <a href="/2018/01/24/--CSS笔记（一）/">CSS笔记（一）</a>
          </li>
        
          <li>
            <a href="/2018/01/24/--JDK1.8中接口的新特性/">JDK1.8中接口的新特性</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>