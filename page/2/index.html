<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>迷途书童的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="厚积薄发">
<meta property="og:type" content="website">
<meta property="og:title" content="迷途书童的博客">
<meta property="og:url" content="https://cong96.github.io/page/2/index.html">
<meta property="og:site_name" content="迷途书童的博客">
<meta property="og:description" content="厚积薄发">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="迷途书童的博客">
<meta name="twitter:description" content="厚积薄发">
  
    <link rel="alternate" href="/atom.xml" title="迷途书童的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">迷途书童的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">一天进步一点</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://cong96.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post---JDK1.8中接口的新特性" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/24/--JDK1.8中接口的新特性/" class="article-date">
  <time datetime="2018-01-24T14:54:35.265Z" itemprop="datePublished">2018-01-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java基础/">Java基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/24/--JDK1.8中接口的新特性/">JDK1.8中接口的新特性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>昨天在牛客网做题，有一道题叫做在JDK8的环境下，接口能不能有具体的方法实现还是只能有抽象方法。</p>
<p>当然原题是个选择题，问法也不是这样问的。如果是这样问的，大家肯定都会想着是不是JDK8有更改了，接口里不只是可以有抽象方法了，也可以有具体的实现了，是的，确实是这样。我们今天就来看看下JDK8中接口的新特性。</p>
<h3 id="JDK8中接口的新特性"><a href="#JDK8中接口的新特性" class="headerlink" title="JDK8中接口的新特性"></a>JDK8中接口的新特性</h3><p>在JDK8环境中，接口中的方法不再是只能有抽象方法，他可以有静态方法和default方法。</p>
<p>我们来看一个例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wangcc.MyJavaSE.jdk8interface;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NewInterface</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"staticMethod"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">defaultMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"defaultMethod"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给出一个接口，在JDK8的环境下，他可以拥有静态方法和default方法，所谓default方法既是使用default关键字来修饰的方法。一个接口可以有多个静态方法和default方法，没有个数限制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wangcc.MyJavaSE.jdk8interface;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleImpl</span> <span class="keyword">implements</span> <span class="title">NewInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"INFO"</span>);</span><br><span class="line">		defaultMethod();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现类只需要实现它的抽象方法即可，JDK8中的接口愈发的像抽象类靠拢的感觉。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wangcc.MyJavaSE.jdk8interface;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewInterfaceTest</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		NewInterface.staticMethod();</span><br><span class="line">		<span class="keyword">new</span> SimpleImpl().defaultMethod();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于静态方法和default方法的调用。</p>
<p>对于静态方法，并没有特殊的地方，在接口中直接由接口名调用，不需要由接口实现类对象来调用。</p>
<p>而对于default方法，很明显是需要实力对象来调用的。而且有一点需要特别注意。</p>
<p>我们知道在Java中是单继承的，但是是可以实现多个接口的，所以，当一个类实现了多个接口之后，如果多个接口有着相同的default方法，即方法名和参数列表相同。那么此时就会出现问题，无法识别到底是调用的哪个接口的方法，这个时候就必须要在实现类里面显式重写default的方法，而关于default的方法的重写,我们在实现类中不需要继续出现default关键字也不能出现default关键字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wangcc.MyJavaSE.jdk8interface;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleImpl</span> <span class="keyword">implements</span> <span class="title">NewInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"INFO"</span>);</span><br><span class="line">		defaultMethod();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">defaultMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Impl default Method"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重写的default方法必须的访问权限必须是public，因为default方法除了没有显式的访问修饰符外，只能用public访问限定符来修饰，而我们知道在Java中，要重写一个方法，访问限定符一定要大于父类或者接口指定的访问限定符范围，而且方法声明处抛出的异常也要大于后者。所以访问权限必须是public。</p>
<p>最后，当default方法和实现类继承的父类的方法同名时，优先调用父类的方法。</p>
<h3 id="strictfp关键字"><a href="#strictfp关键字" class="headerlink" title="strictfp关键字"></a>strictfp关键字</h3><p>今天在看default关键字的时候无意中发现了还有一个名为strictfp的关键字，这个关键字可是之前从来都没有看过额。那今天碰到了就记录一下吧，目前的场景还没有用到过。</p>
<p>自Java2以来，Java语言增加了一个关键字strictfp</p>
<p>strictfp 的意思是FP-strict，也就是说精确浮点的意思。在Java虚拟机进行浮点运算时，如果没有指定strictfp关键字时，Java的编译器以及运 行环境在对浮点运算的表达式是采取一种近似于我行我素的行为来完成这些操作，以致于得到的结果往往无法令你满意。而一旦使用了strictfp来声明一个 类、接口或者方法时，那么所声明的范围内Java的编译器以及运行环境会完全依照浮点规范IEEE-754来执行。因此如果你想让你的浮点运算更加精确， 而且不会因为不同的硬件平台所执行的结果不一致的话，那就请用关键字strictfp。</p>
<p>你可以将一个类、接口以及方法声明为strictfp，但是不允许对接口中的方法以及构造函数声明strictfp关键字。现在这句话就需要更改了，是不允许对接口中的抽象方法使用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2018/01/24/--JDK1.8中接口的新特性/" data-id="cjct6yxxe000044bzpl8htft7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Spring AOP源码​" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/21/Spring AOP源码​/" class="article-date">
  <time datetime="2018-01-21T14:07:52.843Z" itemprop="datePublished">2018-01-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/21/Spring AOP源码​/">Spring AOP源码（一）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>上一篇我们讲解了Spring对aop配置的处理，但是还没有讲Spring中是怎么运用这些配置的。今天我们就俩看下Spring是怎么让这些东西起作用的。</p>
<h3 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h3><p>在讲解之前，我们需要先认识一下BeanPostProcessor接口。</p>
<p>我们回到AbstractApplicationContext的refresh方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">			<span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">			prepareRefresh();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">			prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">				postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">				invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">				registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Initialize message source for this context.</span></span><br><span class="line">				initMessageSource();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">				initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">				onRefresh();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">				registerListeners();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">				finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">				finishRefresh();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">				logger.warn(<span class="string">"Exception encountered during context initialization - cancelling refresh attempt"</span>, ex);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">				destroyBeans();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Reset 'active' flag.</span></span><br><span class="line">				cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Propagate exception to caller.</span></span><br><span class="line">				<span class="keyword">throw</span> ex;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>我们解析aop配置的操作是在        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();中完成的。</p>
<p>我们继续往下看，可以看到有registerBeanPostProcessors(beanFactory);方法</p>
<p>这个方法就是把所有的实现BeanPostProcessor接口的Bean都注入到AbstractBeanFactory的beanPostProcessors属性中。这个跟invokeBeanFactoryPostProcessors方法中将所有实现了BeanFactoryPostProcessor接口的Bean都注入到相应的list集合中并调用其postProcessBeanFactory方法的实现是大体一样的，这里就不再说了，可以看看之前讲解Spring解析属性文件的源码解析部分。</p>
<p>然后我们就直接看到实例化bean的代码段把，在refresh就是    finishBeanFactoryInitialization(beanFactory);的具体实现，我们不一层一层看了，直接看AbstractAutowireCapableBeanFactory类的</p>
<p><strong>initializeBean</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">			AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					invokeAwareMethods(beanName, bean);</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;, getAccessControlContext());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			invokeAwareMethods(beanName, bean);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Object wrappedBean = bean;</span><br><span class="line">		<span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">			wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">					(mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</span><br><span class="line">					beanName, <span class="string">"Invocation of init method failed"</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">			wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> wrappedBean;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法我们已经不陌生了，我们在讲解SpringMVC的时候提到过InitializingBean接口，如果Bean实现了这个接口，会在实例化Bean的时候通过该方法中的invokeInitMethods来调用afterPropertiesSet()方法。而今天在我们关注的BeanPostProcessor接口中，在这个类对应的方法很显然就是</p>
<p>applyBeanPostProcessorsBeforeInitialization和applyBeanPostProcessorsAfterInitialization方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsBeforeInitialization</span><span class="params">(Object existingBean, String beanName)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">	Object result = existingBean;</span><br><span class="line">	<span class="keyword">for</span> (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">		result = beanProcessor.postProcessBeforeInitialization(result, beanName);</span><br><span class="line">		<span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一目了然，就是遍历所有的BeanPostProcessor实现类（已经在registerBeanPostProcessors得到了所有的实现类集合），然后以当前Bean的信息为参数来调用他的postProcessBeforeInitialization方法。</p>
<p>同理如果是applyBeanPostProcessorsAfterInitialization方法，便是遍历后调用postProcessAfterInitialization方法。</p>
<p>分析到这里，很明显我们就可以吧目光转向AspectJAwareAdvisorAutoProxyCreator的这两个方法了。</p>
<h3 id="AspectJAwareAdvisorAutoProxyCreator"><a href="#AspectJAwareAdvisorAutoProxyCreator" class="headerlink" title="AspectJAwareAdvisorAutoProxyCreator"></a>AspectJAwareAdvisorAutoProxyCreator</h3><p>### </p>
<p>在我们上一篇讲解ConfigBeanDefinitionParser的parse方法的时候，说到    configureAutoProxyCreator(parserContext, element);的时候说先不细说，那么到了这一篇就需要从这里入手了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configureAutoProxyCreator</span><span class="params">(ParserContext parserContext, Element element)</span> </span>&#123;</span><br><span class="line">		AopNamespaceUtils.registerAspectJAutoProxyCreatorIfNecessary(parserContext, element);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerAspectJAutoProxyCreatorIfNecessary</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			ParserContext parserContext, Element sourceElement)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		BeanDefinition beanDefinition = AopConfigUtils.registerAspectJAutoProxyCreatorIfNecessary(</span><br><span class="line">				parserContext.getRegistry(), parserContext.extractSource(sourceElement));</span><br><span class="line">		useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement);</span><br><span class="line">		registerComponentIfNecessary(beanDefinition, parserContext);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>1.得到一个包含AspectJAwareAdvisorAutoProxyCreator实例的Bean定义。</p>
<p>2.根据element节点的相关属性设置一些属性。</p>
<p>3.将1中得到的Bean定义注册到Spring容器中。</p>
<p>我们详细说一下1和2.</p>
<p><strong>registerAspectJAutoProxyCreatorIfNecessary</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BeanDefinition <span class="title">registerAspectJAutoProxyCreatorIfNecessary</span><span class="params">(BeanDefinitionRegistry registry, Object source)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> registerOrEscalateApcAsRequired(AspectJAwareAdvisorAutoProxyCreator.class, registry, source);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BeanDefinition <span class="title">registerOrEscalateApcAsRequired</span><span class="params">(Class&lt;?&gt; cls, BeanDefinitionRegistry registry, Object source)</span> </span>&#123;</span><br><span class="line">		Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>);</span><br><span class="line">		<span class="keyword">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;</span><br><span class="line">			BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class="line">			<span class="keyword">if</span> (!cls.getName().equals(apcDefinition.getBeanClassName())) &#123;</span><br><span class="line">				<span class="keyword">int</span> currentPriority = findPriorityForClass(apcDefinition.getBeanClassName());</span><br><span class="line">				<span class="keyword">int</span> requiredPriority = findPriorityForClass(cls);</span><br><span class="line">				<span class="keyword">if</span> (currentPriority &lt; requiredPriority) &#123;</span><br><span class="line">					apcDefinition.setBeanClassName(cls.getName());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		RootBeanDefinition beanDefinition = <span class="keyword">new</span> RootBeanDefinition(cls);</span><br><span class="line">		beanDefinition.setSource(source);</span><br><span class="line">		beanDefinition.getPropertyValues().add(<span class="string">"order"</span>, Ordered.HIGHEST_PRECEDENCE);</span><br><span class="line">		beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">		registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);</span><br><span class="line">		<span class="keyword">return</span> beanDefinition;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>   1)当Spring容器中已经有名为org.springframework.aop.config.internalAutoProxyCreator的Bean。</p>
<p>获取对应的Bean定义，把这个Bean定义的ClassName和AspectJAwareAdvisorAutoProxyCreator比较，如果不相同，比较两个ClassName的优先级。如果AspectJAwareAdvisorAutoProxyCreator的优先级高，则把当前的Bean定义的ClassName设置为AspectJAwareAdvisorAutoProxyCreator。优先级为：</p>
<p>AnnotationAwareAspectJAutoProxyCreator&gt;AspectJAwareAdvisorAutoProxyCreator&gt;InfrastructureAdvisorAutoProxyCreator。</p>
<p>2）如果当前容器中并没有这个BeanName存在。那么就使用AspectJAwareAdvisorAutoProxyCreator构造出一个Bean定义，并注册一些相关属性，把order优先级设置为最低等等。然后返回。</p>
<p><strong>useClassProxyingIfNecessary</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useClassProxyingIfNecessary</span><span class="params">(BeanDefinitionRegistry registry, Element sourceElement)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (sourceElement != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">boolean</span> proxyTargetClass = Boolean.valueOf(sourceElement.getAttribute(PROXY_TARGET_CLASS_ATTRIBUTE));</span><br><span class="line">		<span class="keyword">if</span> (proxyTargetClass) &#123;</span><br><span class="line">			AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">boolean</span> exposeProxy = Boolean.valueOf(sourceElement.getAttribute(EXPOSE_PROXY_ATTRIBUTE));</span><br><span class="line">		<span class="keyword">if</span> (exposeProxy) &#123;</span><br><span class="line">			AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是看到了熟悉的东西，proxy-target-class属性在我们一开始学习aop配置的时候经常会提到，人们通常会告诉你，如果你想对类直接使用动态，那可以在\<aop:config>节点里配置属性：proxy-target-class=true即可,那么动态代理就会使用cglib来完成，cglib可以直接针对类来实现动态代理，而如果我们在aop配置的时候没有设置这个属性或者设置为false，那么就会使用JDK动态代理，这个时候就只能针对接口实现动态代理。</aop:config></p>
<p>那么这个方法其实他的主要作用就是为了上述的Bean定义注册两个属性，分别是proxyTargetClass和exposeProxy。</p>
<p>好了到现在，我们终于往Spring容器中注入了AspectJAwareAdvisorAutoProxyCreator构成的Bean定义。</p>
<p>我们来看下AspectJAwareAdvisorAutoProxyCreator的继承结构。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectJAwareAdvisorAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">AbstractAdvisorAutoProxyCreator</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAdvisorAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">AbstractAutoProxyCreator</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">ProxyProcessorSupport</span></span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">SmartInstantiationAwareBeanPostProcessor</span>, <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmartInstantiationAwareBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title">InstantiationAwareBeanPostProcessor</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InstantiationAwareBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyProcessorSupport</span> <span class="keyword">extends</span> <span class="title">ProxyConfig</span> <span class="keyword">implements</span> <span class="title">Ordered</span>, <span class="title">BeanClassLoaderAware</span>, <span class="title">AopInfrastructureBean</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<p>我们发现他的祖先类有实现了BeanPostProcessor接口。</p>
<p>翻阅源码，你会发现AspectJAwareAdvisorAutoProxyCreator以及他的祖先类都没有对postProcessBeforeInitialization方法有具体的实现，而只有对postProcessAfterInitialization方法有具体实现。</p>
<p>这个方法的实现在祖先类AbstractAutoProxyCreator中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">	if (bean != null) &#123;</span><br><span class="line">		Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">		if (!this.earlyProxyReferences.contains(cacheKey)) &#123;</span><br><span class="line">			return wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看方法的重点wrapIfNecessary</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (beanName != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">			<span class="keyword">return</span> bean;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line">			<span class="keyword">return</span> bean;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">			<span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">			<span class="keyword">return</span> bean;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Create proxy if we have advice.</span></span><br><span class="line">		Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line">		<span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">			<span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">			Object proxy = createProxy(bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line">			<span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">			<span class="keyword">return</span> proxy;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>1.通过getAdvicesAndAdvisorsForBean来获取可以对当前Bean做代理的AdviceBean。</p>
<p>2.如果AdviceBean不为空，则创建动态代理类，最后把其放入缓存，然后返回。</p>
<p><strong>getAdvicesAndAdvisorsForBean</strong></p>
<p>AbstractAdvisorAutoProxyCreator</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Object[] getAdvicesAndAdvisorsForBean(Class&lt;?&gt; beanClass, String beanName, TargetSource targetSource) &#123;</span><br><span class="line">	List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);</span><br><span class="line">	<span class="keyword">if</span> (advisors.isEmpty()) &#123;</span><br><span class="line">		<span class="keyword">return</span> DO_NOT_PROXY;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> advisors.toArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用当前bean的Class和beanName来找到匹配的Advisors</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findEligibleAdvisors</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">	List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">	List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class="line">	extendAdvisors(eligibleAdvisors);</span><br><span class="line">	<span class="keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class="line">		eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1)先获取所有的Advisor</p>
<p>2)然后调用findAdvisorsThatCanApply在所有的Advisor找到符合条件的Advisor集合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findAdvisorsThatCanApply</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	ProxyCreationContext.setCurrentProxiedBeanName(beanName);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		ProxyCreationContext.setCurrentProxiedBeanName(<span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Advisor&gt; <span class="title">findAdvisorsThatCanApply</span><span class="params">(List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (candidateAdvisors.isEmpty()) &#123;</span><br><span class="line">		<span class="keyword">return</span> candidateAdvisors;</span><br><span class="line">	&#125;</span><br><span class="line">	List&lt;Advisor&gt; eligibleAdvisors = <span class="keyword">new</span> LinkedList&lt;Advisor&gt;();</span><br><span class="line">	<span class="keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;</span><br><span class="line">		<span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> IntroductionAdvisor &amp;&amp; canApply(candidate, clazz)) &#123;</span><br><span class="line">			eligibleAdvisors.add(candidate);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">boolean</span> hasIntroductions = !eligibleAdvisors.isEmpty();</span><br><span class="line">	<span class="keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;</span><br><span class="line">		<span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line">			<span class="comment">// already processed</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (canApply(candidate, clazz, hasIntroductions)) &#123;</span><br><span class="line">			eligibleAdvisors.add(candidate);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到选出适合的Advisor的主要方法是canApply，我们主要看这个方法。</p>
<p><strong>canApply</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canApply</span><span class="params">(Pointcut pc, Class&lt;?&gt; targetClass, <span class="keyword">boolean</span> hasIntroductions)</span> </span>&#123;</span><br><span class="line">		Assert.notNull(pc, <span class="string">"Pointcut must not be null"</span>);</span><br><span class="line">		<span class="keyword">if</span> (!pc.getClassFilter().matches(targetClass)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		MethodMatcher methodMatcher = pc.getMethodMatcher();</span><br><span class="line">		IntroductionAwareMethodMatcher introductionAwareMethodMatcher = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (methodMatcher <span class="keyword">instanceof</span> IntroductionAwareMethodMatcher) &#123;</span><br><span class="line">			introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Set&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> LinkedHashSet&lt;Class&lt;?&gt;&gt;(ClassUtils.getAllInterfacesForClassAsSet(targetClass));</span><br><span class="line">		classes.add(targetClass);</span><br><span class="line">		<span class="keyword">for</span> (Class&lt;?&gt; clazz : classes) &#123;</span><br><span class="line">			Method[] methods = clazz.getMethods();</span><br><span class="line">			<span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">				<span class="keyword">if</span> ((introductionAwareMethodMatcher != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">						introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) ||</span><br><span class="line">						methodMatcher.matches(method, targetClass)) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>接下来看创建代理对象</p>
<p><strong>createProxy</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createProxy</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		Class&lt;?&gt; beanClass, String beanName, Object[] specificInterceptors, TargetSource targetSource)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">	proxyFactory.copyFrom(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">			proxyFactory.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">	<span class="keyword">for</span> (Advisor advisor : advisors) &#123;</span><br><span class="line">		proxyFactory.addAdvisor(advisor);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	proxyFactory.setTargetSource(targetSource);</span><br><span class="line">	customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line">	proxyFactory.setFrozen(<span class="keyword">this</span>.freezeProxy);</span><br><span class="line">	<span class="keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line">		proxyFactory.setPreFiltered(<span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法大体的意思就是新建一个ProxyFactory对象，然后将满足条件的Advisor信息都注入到这个对象中，最后调用 proxyFactory.getProxy(getProxyClassLoader());来创建代理对象。</p>
<p><strong>getProxy</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> createAopProxy().getProxy(classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>createAopProxy</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">protected final synchronized AopProxy createAopProxy() &#123;</span><br><span class="line">	if (!this.active) &#123;</span><br><span class="line">		activate();</span><br><span class="line">	&#125;</span><br><span class="line">	return getAopProxyFactory().createAopProxy(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终调用的是DefaultAopProxyFactory的createAopProxy方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">			Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">			<span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> +</span><br><span class="line">						<span class="string">"Either an interface or a target is required for proxy creation."</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (targetClass.isInterface()) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>方法很容易理解，如果proxy-target-class属性指定为true，而且不是对接口进行动态代理，就调用ObjenesisCglibAopProxy来完成动态代理，即使用CGLIB来完成动态代理。否则就是调用JdkDynamicAopProxy来完成动态代理，即使用JDK动态代理来实现。</p>
<p>我们先看我们熟悉的JDK动态代理的具体实现。</p>
<p>JdkDynamicAopProxy</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(<span class="string">"Creating JDK dynamic proxy: target source is "</span> + <span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">	&#125;</span><br><span class="line">	Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised);</span><br><span class="line">	findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line">	<span class="keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getProxy的方法很简单，就是使用当前的ClassLoader来加载当前Bean实现的所有接口，最后生成相应的动态代理实例。</p>
<p>至此，创建动态代理实例的过程就分析完了。</p>
<p>但是更重要的是当我们调用动态代理实例时，JdkDynamicAopProxy中对InvocationHandler接口的的具体实现。</p>
<p><strong>invoke</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		MethodInvocation invocation;</span><br><span class="line">		Object oldProxy = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">		TargetSource targetSource = <span class="keyword">this</span>.advised.targetSource;</span><br><span class="line">		Class&lt;?&gt; targetClass = <span class="keyword">null</span>;</span><br><span class="line">		Object target = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (!<span class="keyword">this</span>.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;</span><br><span class="line">				<span class="comment">// The target does not implement the equals(Object) method itself.</span></span><br><span class="line">				<span class="keyword">return</span> equals(args[<span class="number">0</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!<span class="keyword">this</span>.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;</span><br><span class="line">				<span class="comment">// The target does not implement the hashCode() method itself.</span></span><br><span class="line">				<span class="keyword">return</span> hashCode();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!<span class="keyword">this</span>.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;</span><br><span class="line">					method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123;</span><br><span class="line">				<span class="comment">// Service invocations on ProxyConfig with the proxy config...</span></span><br><span class="line">				<span class="keyword">return</span> AopUtils.invokeJoinpointUsingReflection(<span class="keyword">this</span>.advised, method, args);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			Object retVal;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line">				<span class="comment">// Make invocation available if necessary.</span></span><br><span class="line">				oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">				setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// May be null. Get as late as possible to minimize the time we "own" the target,</span></span><br><span class="line">			<span class="comment">// in case it comes from a pool.</span></span><br><span class="line">			target = targetSource.getTarget();</span><br><span class="line">			<span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">				targetClass = target.getClass();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Get the interception chain for this method.</span></span><br><span class="line">			List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Check whether we have any advice. If we don't, we can fallback on direct</span></span><br><span class="line">			<span class="comment">// reflective invocation of the target, and avoid creating a MethodInvocation.</span></span><br><span class="line">			<span class="keyword">if</span> (chain.isEmpty()) &#123;</span><br><span class="line">				<span class="comment">// We can skip creating a MethodInvocation: just invoke the target directly</span></span><br><span class="line">				<span class="comment">// Note that the final invoker must be an InvokerInterceptor so we know it does</span></span><br><span class="line">				<span class="comment">// nothing but a reflective operation on the target, and no hot swapping or fancy proxying.</span></span><br><span class="line">				retVal = AopUtils.invokeJoinpointUsingReflection(target, method, args);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// We need to create a method invocation...</span></span><br><span class="line">				invocation = <span class="keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line">				<span class="comment">// Proceed to the joinpoint through the interceptor chain.</span></span><br><span class="line">				retVal = invocation.proceed();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Massage return value if necessary.</span></span><br><span class="line">			Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line">			<span class="keyword">if</span> (retVal != <span class="keyword">null</span> &amp;&amp; retVal == target &amp;&amp; returnType.isInstance(proxy) &amp;&amp;</span><br><span class="line">					!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123;</span><br><span class="line">				<span class="comment">// Special case: it returned "this" and the return type of the method</span></span><br><span class="line">				<span class="comment">// is type-compatible. Note that we can't help if the target sets</span></span><br><span class="line">				<span class="comment">// a reference to itself in another returned object.</span></span><br><span class="line">				retVal = proxy;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (retVal == <span class="keyword">null</span> &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(</span><br><span class="line">						<span class="string">"Null return value from advice does not match primitive return type for: "</span> + method);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> retVal;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (target != <span class="keyword">null</span> &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">				<span class="comment">// Must have come from TargetSource.</span></span><br><span class="line">				targetSource.releaseTarget(target);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line">				<span class="comment">// Restore old proxy.</span></span><br><span class="line">				AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>我们直接看重点，直接跳过对不需要执行增强方法的方法的处理。</p>
<p>调用this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);来获得当前方法匹配的Advisor集合。</p>
<p>当Advisor集合不为空的时候，执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We need to create a method invocation...</span></span><br><span class="line">invocation = <span class="keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line"><span class="comment">// Proceed to the joinpoint through the interceptor chain.</span></span><br><span class="line">retVal = invocation.proceed();</span><br></pre></td></tr></table></figure>
<p>这两行就是关键。</p>
<p>我们重点看ReflectiveMethodInvocation的proceed()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">	<span class="comment">//	We start with an index of -1 and increment early.</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.currentInterceptorIndex == <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> invokeJoinpoint();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Object interceptorOrInterceptionAdvice =</span><br><span class="line">			<span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="keyword">this</span>.currentInterceptorIndex);</span><br><span class="line">	<span class="keyword">if</span> (interceptorOrInterceptionAdvice <span class="keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line">		<span class="comment">// Evaluate dynamic method matcher here: static part will already have</span></span><br><span class="line">		<span class="comment">// been evaluated and found to match.</span></span><br><span class="line">		InterceptorAndDynamicMethodMatcher dm =</span><br><span class="line">				(InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class="line">		<span class="keyword">if</span> (dm.methodMatcher.matches(<span class="keyword">this</span>.method, <span class="keyword">this</span>.targetClass, <span class="keyword">this</span>.arguments)) &#123;</span><br><span class="line">			<span class="keyword">return</span> dm.interceptor.invoke(<span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Dynamic matching failed.</span></span><br><span class="line">			<span class="comment">// Skip this interceptor and invoke the next in the chain.</span></span><br><span class="line">			<span class="keyword">return</span> proceed();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// It's an interceptor, so we just invoke it: The pointcut will have</span></span><br><span class="line">		<span class="comment">// been evaluated statically before this object was constructed.</span></span><br><span class="line">		<span class="keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的主要操作就是使用责任链模式来调用chain集合里的interceptor属性的invoke方法。</p>
<p>所以我们只要来看看这个chain到底是怎么个东西就好了。具体怎么得到这个chain的我们就不细说了，有兴趣的可以看源码（DefaultAdvisorAdapterRegistry的getInterceptors方法），chain集合是一个MethodInterceptor集合。</p>
<p>这个Intercepor集合主要包含下面几种：</p>
<p>AspectJAfterThrowingAdvice   对应着aop配置里面\<aop:after-returning>节点里的方法。</aop:after-returning></p>
<p>AspectJAfterAdvice      对应着 \<aop:after></aop:after></p>
<p>AspectJAroundAdvice         对应着 \<aop:around></aop:around></p>
<p>AfterReturningAdviceInterceptor 对应着AfterReturningAdvice      对应着 \<aop:after-returning></aop:after-returning></p>
<p>MethodBeforeAdviceInterceptor       对应着 MethodBeforeAdvice        对应着\ <aop:before></aop:before></p>
<p>这几种MethodInterceptor调用的先后顺序，如果没有在配置文件中指定Order，那么就会以在配置文件中出现的顺序来执行。执行的过程是一个责任链模式的应用，有兴趣的同学可以先一个例子debug深入研究。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2018/01/21/Spring AOP源码​/" data-id="cjcov2eib0000jwbzx5uyil68" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post---Spring源码之AOP" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/21/--Spring源码之AOP/" class="article-date">
  <time datetime="2018-01-21T14:07:52.842Z" itemprop="datePublished">2018-01-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/21/--Spring源码之AOP/">Spring源码之AOP</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前说过了IOC，现在自然要来到AOP了，先来看下配置文件实现的AOP的相关源码解析。</p>
<p>显然还是会用到BeanDefinitionParser接口的实现类。</p>
<p>这里是用ConfigBeanDefinitionParser实现类来完成对\<aop:config>节点的解析。</aop:config></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"xmlHandler"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.tgb.aop.XMLAdvice"</span> /&gt;  </span><br><span class="line">&lt;aop:config&gt;  </span><br><span class="line">    &lt;aop:aspect id=<span class="string">"aspect"</span> ref=<span class="string">"xmlHandler"</span>&gt;  </span><br><span class="line">        &lt;aop:pointcut id=<span class="string">"pointUserMgr"</span> expression=<span class="string">"execution(* com.tgb.aop.*.find*(..))"</span>/&gt;  </span><br><span class="line">          </span><br><span class="line">        &lt;aop:before method=<span class="string">"doBefore"</span>  pointcut-ref=<span class="string">"pointUserMgr"</span>/&gt;  </span><br><span class="line">        &lt;aop:after method=<span class="string">"doAfter"</span>  pointcut-ref=<span class="string">"pointUserMgr"</span>/&gt;  </span><br><span class="line">        &lt;aop:around method=<span class="string">"doAround"</span>  pointcut-ref=<span class="string">"pointUserMgr"</span>/&gt;  </span><br><span class="line">        &lt;aop:after-returning method=<span class="string">"doReturn"</span>  pointcut-ref=<span class="string">"pointUserMgr"</span>/&gt;  </span><br><span class="line">        &lt;aop:after-throwing method=<span class="string">"doThrowing"</span> throwing=<span class="string">"ex"</span> pointcut-ref=<span class="string">"pointUserMgr"</span>/&gt;  </span><br><span class="line">          </span><br><span class="line">    &lt;/aop:aspect&gt;</span><br></pre></td></tr></table></figure>
<h3 id="ConfigBeanDefinitionParser"><a href="#ConfigBeanDefinitionParser" class="headerlink" title="ConfigBeanDefinitionParser"></a>ConfigBeanDefinitionParser</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">		CompositeComponentDefinition compositeDef =</span><br><span class="line">				<span class="keyword">new</span> CompositeComponentDefinition(element.getTagName(), parserContext.extractSource(element));</span><br><span class="line">		parserContext.pushContainingComponent(compositeDef);</span><br><span class="line"><span class="comment">//向Spring容器注册了一个BeanName为org.springframework.aop.config.internalAutoProxyCreator的Bean定义，可以自定义也可以使用Spring提供的（根据优先级来）</span></span><br><span class="line">      <span class="comment">//深入这个方法你会发现熟悉的proxy-target-class属性 以及一个不是很常用的exposeProxy属性</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	向Spring容器注册了一个BeanName为org.springframework.aop.config.internalAutoProxyCreator的Bean定义，可以自定义也可以使用Spring提供的（根据优先级来）</span></span><br><span class="line"><span class="comment">Spring默认提供的是org.springframework.aop.aspectj.autoproxy.AspectJAwareAdvisorAutoProxyCreator，这个类是AOP的核心类，留在下篇讲解</span></span><br><span class="line"><span class="comment">在这个方法里面也会根据配置proxy-target-class和expose-proxy，设置是否使用CGLIB进行代理以及是否暴露最终的代理。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">      </span><br><span class="line">      configureAutoProxyCreator(parserContext, element);</span><br><span class="line"></span><br><span class="line">		List&lt;Element&gt; childElts = DomUtils.getChildElements(element);</span><br><span class="line">		<span class="keyword">for</span> (Element elt: childElts) &#123;</span><br><span class="line">			String localName = parserContext.getDelegate().getLocalName(elt);</span><br><span class="line">			<span class="keyword">if</span> (POINTCUT.equals(localName)) &#123;</span><br><span class="line">				parsePointcut(elt, parserContext);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (ADVISOR.equals(localName)) &#123;</span><br><span class="line">				parseAdvisor(elt, parserContext);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (ASPECT.equals(localName)) &#123;</span><br><span class="line">				parseAspect(elt, parserContext);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		parserContext.popAndRegisterContainingComponent();</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>我们直接来看解析\<aop:config>的方法。</aop:config></p>
<p>1.调用  configureAutoProxyCreator(parserContext, element);在向Spring容器里注册一个名为</p>
<p><strong>org.springframework.aop.config.internalAutoProxyCreator</strong>的Bean定义，类型默认是</p>
<p><strong>org.springframework.aop.aspectj.autoproxy.AspectJAwareAdvisorAutoProxyCreator</strong>,</p>
<p>具体实现先不细说。</p>
<p>2.接着往下看，我们的配置文件里面config节点下是aspect，所以我们这里直接看parseAspect(elt, parserContext);这个方法就帮我们解析了aspect节点下的所有配置，是我们今天要关注的重点。</p>
<p><strong>parseAspect(elt, parserContext)</strong></p>
<p>parseAspect</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseAspect</span><span class="params">(Element aspectElement, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//获取ID和指定的beanName</span></span><br><span class="line">		String aspectId = aspectElement.getAttribute(ID);</span><br><span class="line">		String aspectName = aspectElement.getAttribute(REF);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//往paresState这个栈里面推入一个当前aspcet节点的Entry</span></span><br><span class="line">			<span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> AspectEntry(aspectId, aspectName));</span><br><span class="line">          <span class="comment">//新建一个Bean定义List和BeanReference的List，在将Bean定义转化为Bean的时候会用到</span></span><br><span class="line">			List&lt;BeanDefinition&gt; beanDefinitions = <span class="keyword">new</span> ArrayList&lt;BeanDefinition&gt;();</span><br><span class="line">			List&lt;BeanReference&gt; beanReferences = <span class="keyword">new</span> ArrayList&lt;BeanReference&gt;();</span><br><span class="line"><span class="comment">//如果该aspect节点有declare-parents属性的话，得到其属性对应的值，然后对其进行处理。</span></span><br><span class="line">			List&lt;Element&gt; declareParents = DomUtils.getChildElementsByTagName(aspectElement, DECLARE_PARENTS);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = METHOD_INDEX; i &lt; declareParents.size(); i++) &#123;</span><br><span class="line">				Element declareParentsElement = declareParents.get(i);</span><br><span class="line">				beanDefinitions.add(parseDeclareParents(declareParentsElement, parserContext));</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// We have to parse "advice" and all the advice kinds in one loop, to get the</span></span><br><span class="line">			<span class="comment">// ordering semantics right.</span></span><br><span class="line">          <span class="comment">//对aspect下的子节点进行处理。</span></span><br><span class="line">			NodeList nodeList = aspectElement.getChildNodes();</span><br><span class="line">			<span class="keyword">boolean</span> adviceFoundAlready = <span class="keyword">false</span>;</span><br><span class="line">          <span class="comment">//****开始对子节点遍历</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodeList.getLength(); i++) &#123;</span><br><span class="line">				Node node = nodeList.item(i);</span><br><span class="line">              <span class="comment">/*</span></span><br><span class="line"><span class="comment">              即这个for循环只用来处理&lt;aop:aspect&gt;标签下的&lt;aop:before&gt;、&lt;aop:after&gt;、&lt;aop:after-returning&gt;、&lt;aop:after-throwing method=""&gt;、&lt;aop:around method=""&gt;这五个标签的。</span></span><br><span class="line"><span class="comment">              </span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">				<span class="keyword">if</span> (isAdviceNode(node, parserContext)) &#123;</span><br><span class="line">					<span class="keyword">if</span> (!adviceFoundAlready) &#123;</span><br><span class="line">						adviceFoundAlready = <span class="keyword">true</span>;</span><br><span class="line">						<span class="keyword">if</span> (!StringUtils.hasText(aspectName)) &#123;</span><br><span class="line">							parserContext.getReaderContext().error(</span><br><span class="line">									<span class="string">"&lt;aspect&gt; tag needs aspect bean reference via 'ref' attribute when declaring advices."</span>,</span><br><span class="line">									aspectElement, <span class="keyword">this</span>.parseState.snapshot());</span><br><span class="line">							<span class="keyword">return</span>;</span><br><span class="line">						&#125;</span><br><span class="line">                      <span class="comment">//要注入一个包含aspectName的beanReference，在aspectComponentDefinition 转化为Bean的时候会用到</span></span><br><span class="line">						beanReferences.add(<span class="keyword">new</span> RuntimeBeanReference(aspectName));</span><br><span class="line">					&#125;</span><br><span class="line">					AbstractBeanDefinition advisorDefinition = parseAdvice(</span><br><span class="line">							aspectName, i, aspectElement, (Element) node, parserContext, beanDefinitions, beanReferences);</span><br><span class="line">                  <span class="comment">//将advisorDefinition加入到beanDefinitions</span></span><br><span class="line">					beanDefinitions.add(advisorDefinition);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">	<span class="comment">//新建一个aspectComponentDefinition，注入了beanDefinitions beanReferences</span></span><br><span class="line">			AspectComponentDefinition aspectComponentDefinition = createAspectComponentDefinition(</span><br><span class="line">					aspectElement, aspectId, beanDefinitions, beanReferences, parserContext);</span><br><span class="line">			parserContext.pushContainingComponent(aspectComponentDefinition);</span><br><span class="line"></span><br><span class="line">			List&lt;Element&gt; pointcuts = DomUtils.getChildElementsByTagName(aspectElement, POINTCUT);</span><br><span class="line">			<span class="keyword">for</span> (Element pointcutElement : pointcuts) &#123;</span><br><span class="line">				parsePointcut(pointcutElement, parserContext);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			parserContext.popAndRegisterContainingComponent();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">this</span>.parseState.pop();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>我们直接从对aspect子节点遍历开始看起。</p>
<p>isAdviceNode(node, parserContext)的作用是筛选出了要处理的子节点的名字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAdviceNode</span><span class="params">(Node aNode, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!(aNode <span class="keyword">instanceof</span> Element)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		String name = parserContext.getDelegate().getLocalName(aNode);</span><br><span class="line">		<span class="keyword">return</span> (BEFORE.equals(name) || AFTER.equals(name) || AFTER_RETURNING_ELEMENT.equals(name) ||</span><br><span class="line">				AFTER_THROWING_ELEMENT.equals(name) || AROUND.equals(name));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以很清楚的看出，代表只会处理aop:aspect&gt;标签下的\<aop:before>、\<aop:after>、\<aop:after-returning>、\<aop:after-throwing method="">、\<aop:around method="">这五个标签。</aop:around></aop:after-throwing></aop:after-returning></aop:after></aop:before></p>
<p>接着看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AbstractBeanDefinition advisorDefinition = parseAdvice(</span><br><span class="line">						aspectName, i, aspectElement, (Element) node, parserContext, beanDefinitions, beanReferences);</span><br></pre></td></tr></table></figure>
<p>这里正式处理子节点了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AbstractBeanDefinition <span class="title">parseAdvice</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			String aspectName, <span class="keyword">int</span> order, Element aspectElement, Element adviceElement, ParserContext parserContext,</span></span></span><br><span class="line"><span class="function"><span class="params">			List&lt;BeanDefinition&gt; beanDefinitions, List&lt;BeanReference&gt; beanReferences)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//将当前的节点的信息放入到parseState栈中</span></span><br><span class="line">			<span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> AdviceEntry(parserContext.getDelegate().getLocalName(adviceElement)));</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">			<span class="comment">// create the method factory bean</span></span><br><span class="line">			RootBeanDefinition methodDefinition = <span class="keyword">new</span> RootBeanDefinition(MethodLocatingFactoryBean.class);</span><br><span class="line">			methodDefinition.getPropertyValues().add(<span class="string">"targetBeanName"</span>, aspectName);</span><br><span class="line">			methodDefinition.getPropertyValues().add(<span class="string">"methodName"</span>, adviceElement.getAttribute(<span class="string">"method"</span>));</span><br><span class="line">			methodDefinition.setSynthetic(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// create instance factory definition</span></span><br><span class="line">			RootBeanDefinition aspectFactoryDef =</span><br><span class="line">					<span class="keyword">new</span> RootBeanDefinition(SimpleBeanFactoryAwareAspectInstanceFactory.class);</span><br><span class="line">			aspectFactoryDef.getPropertyValues().add(<span class="string">"aspectBeanName"</span>, aspectName);</span><br><span class="line">			aspectFactoryDef.setSynthetic(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// register the pointcut</span></span><br><span class="line">			AbstractBeanDefinition adviceDef = createAdviceDefinition(</span><br><span class="line">					adviceElement, parserContext, aspectName, order, methodDefinition, aspectFactoryDef,</span><br><span class="line">					beanDefinitions, beanReferences);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// configure the advisor</span></span><br><span class="line">			RootBeanDefinition advisorDefinition = <span class="keyword">new</span> RootBeanDefinition(AspectJPointcutAdvisor.class);</span><br><span class="line">			advisorDefinition.setSource(parserContext.extractSource(adviceElement));</span><br><span class="line"><span class="comment">//看方法名就知道，当Adviser Bean定义通过Spring转化为AspectJPointcutAdvisor实例的时候，</span></span><br><span class="line">          <span class="comment">//advise Bean定义对应的AbstractAspectJAdvice实例将作为前者的构造方法的形参注入。</span></span><br><span class="line">          advisorDefinition.getConstructorArgumentValues().addGenericArgumentValue(adviceDef);</span><br><span class="line">		<span class="comment">//如果节点有order属性，要注入order属性</span></span><br><span class="line">          <span class="keyword">if</span> (aspectElement.hasAttribute(ORDER_PROPERTY)) &#123;</span><br><span class="line">				advisorDefinition.getPropertyValues().add(</span><br><span class="line">						ORDER_PROPERTY, aspectElement.getAttribute(ORDER_PROPERTY));</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// register the final advisor</span></span><br><span class="line">		<span class="comment">//注册到Spring容器中，即BeanFactory中	parserContext.getReaderContext().registerWithGeneratedName(advisorDefinition);</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> advisorDefinition;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">//出栈</span></span><br><span class="line">			<span class="keyword">this</span>.parseState.pop();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>1,创建一个Method工厂Bean定义，里面包含的信息有aspectname以及相应节点的method属性值。</p>
<p>2.创建一个aspectFactory工厂Bean定义，里面包含的信息有asepectname.</p>
<p>3.创建一个Advise Bean定义，下面会重点讲解。</p>
<p>4.创建一个Advisor Bean定义，将AdviseBean注入到其中，然后返回。看方法名就知道，当Adviser Bean定义通过Spring转化为AspectJPointcutAdvisor实例的时候，    advise Bean定义对应的AbstractAspectJAdvice实例将作为前者的构造方法的形参注入。</p>
<p>我们重点来看下是如何创建Advise Bean定义的。</p>
<p><strong>createAdviceDefinition</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AbstractBeanDefinition <span class="title">createAdviceDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			Element adviceElement, ParserContext parserContext, String aspectName, <span class="keyword">int</span> order,</span></span></span><br><span class="line"><span class="function"><span class="params">			RootBeanDefinition methodDef, RootBeanDefinition aspectFactoryDef,</span></span></span><br><span class="line"><span class="function"><span class="params">			List&lt;BeanDefinition&gt; beanDefinitions, List&lt;BeanReference&gt; beanReferences)</span> </span>&#123;</span><br><span class="line"><span class="comment">//新建Advice Bean定义</span></span><br><span class="line">		RootBeanDefinition adviceDefinition = <span class="keyword">new</span> RootBeanDefinition(getAdviceClass(adviceElement, parserContext));</span><br><span class="line">		adviceDefinition.setSource(parserContext.extractSource(adviceElement));</span><br><span class="line">	<span class="comment">//注入 aspectName和declarationOrder属性</span></span><br><span class="line">		adviceDefinition.getPropertyValues().add(ASPECT_NAME_PROPERTY, aspectName);</span><br><span class="line">		adviceDefinition.getPropertyValues().add(DECLARATION_ORDER_PROPERTY, order);</span><br><span class="line"><span class="comment">//如果该节点有returning属性，将其注入该Bean定义的returningName属性</span></span><br><span class="line">		<span class="keyword">if</span> (adviceElement.hasAttribute(RETURNING)) &#123;</span><br><span class="line">			adviceDefinition.getPropertyValues().add(</span><br><span class="line">					RETURNING_PROPERTY, adviceElement.getAttribute(RETURNING));</span><br><span class="line">		&#125;</span><br><span class="line">  <span class="comment">//如果该节点有throwing属性，那么将其注入到该Bean定义的throwingName属性</span></span><br><span class="line">		<span class="keyword">if</span> (adviceElement.hasAttribute(THROWING)) &#123;</span><br><span class="line">			adviceDefinition.getPropertyValues().add(</span><br><span class="line">					THROWING_PROPERTY, adviceElement.getAttribute(THROWING));</span><br><span class="line">		&#125;</span><br><span class="line">  <span class="comment">//如果该节点有arg-names属性，那么将其注入到该Bean定义的argumentNames属性</span></span><br><span class="line">		<span class="keyword">if</span> (adviceElement.hasAttribute(ARG_NAMES)) &#123;</span><br><span class="line">			adviceDefinition.getPropertyValues().add(</span><br><span class="line">					ARG_NAMES_PROPERTY, adviceElement.getAttribute(ARG_NAMES));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//很明显这里是为了该Bean定义中的Bean收集构造方法参数信息</span></span><br><span class="line">		ConstructorArgumentValues cav = adviceDefinition.getConstructorArgumentValues();</span><br><span class="line"><span class="comment">//第一个参数 Method		</span></span><br><span class="line">  cav.addIndexedArgumentValue(METHOD_INDEX, methodDef);</span><br><span class="line">	<span class="comment">//第二个参数 pointcut</span></span><br><span class="line">		Object pointcut = parsePointcutProperty(adviceElement, parserContext);</span><br><span class="line">		<span class="keyword">if</span> (pointcut <span class="keyword">instanceof</span> BeanDefinition) &#123;</span><br><span class="line">			cav.addIndexedArgumentValue(POINTCUT_INDEX, pointcut);</span><br><span class="line">			beanDefinitions.add((BeanDefinition) pointcut);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (pointcut <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">			RuntimeBeanReference pointcutRef = <span class="keyword">new</span> RuntimeBeanReference((String) pointcut);</span><br><span class="line">			cav.addIndexedArgumentValue(POINTCUT_INDEX, pointcutRef);</span><br><span class="line">			beanReferences.add(pointcutRef);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="comment">//第三个参数，asepctFactory</span></span><br><span class="line">		cav.addIndexedArgumentValue(ASPECT_INSTANCE_FACTORY_INDEX, aspectFactoryDef);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> adviceDefinition;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>1.通过节点的标签名字来得到要新建的AdviseBean定义的构造方法的入参。</p>
<p>getAdviceClass</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; getAdviceClass(Element adviceElement, ParserContext parserContext) &#123;</span><br><span class="line">		String elementName = parserContext.getDelegate().getLocalName(adviceElement);</span><br><span class="line">		<span class="keyword">if</span> (BEFORE.equals(elementName)) &#123;</span><br><span class="line">			<span class="keyword">return</span> AspectJMethodBeforeAdvice.class;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (AFTER.equals(elementName)) &#123;</span><br><span class="line">			<span class="keyword">return</span> AspectJAfterAdvice.class;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (AFTER_RETURNING_ELEMENT.equals(elementName)) &#123;</span><br><span class="line">			<span class="keyword">return</span> AspectJAfterReturningAdvice.class;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (AFTER_THROWING_ELEMENT.equals(elementName)) &#123;</span><br><span class="line">			<span class="keyword">return</span> AspectJAfterThrowingAdvice.class;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (AROUND.equals(elementName)) &#123;</span><br><span class="line">			<span class="keyword">return</span> AspectJAroundAdvice.class;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unknown advice kind ["</span> + elementName + <span class="string">"]."</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到五个不同类型的节点都有自己对应的AbstractAdvise实现类。</p>
<p>2.注入一系列的属性</p>
<p>3.注入对应的Bean的构造方法参数。</p>
<p>我们这里主要看注入第二个参数的过程。</p>
<p>我们截取这一段来分析一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Object pointcut = parsePointcutProperty(adviceElement, parserContext);</span><br><span class="line">	<span class="keyword">if</span> (pointcut <span class="keyword">instanceof</span> BeanDefinition) &#123;</span><br><span class="line">		cav.addIndexedArgumentValue(POINTCUT_INDEX, pointcut);</span><br><span class="line">		beanDefinitions.add((BeanDefinition) pointcut);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pointcut <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">		RuntimeBeanReference pointcutRef = <span class="keyword">new</span> RuntimeBeanReference((String) pointcut);</span><br><span class="line">		cav.addIndexedArgumentValue(POINTCUT_INDEX, pointcutRef);</span><br><span class="line">		beanReferences.add(pointcutRef);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>1.先调用parsePointcutProperty得到我们要注入的pointcut。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">parsePointcutProperty</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (element.hasAttribute(POINTCUT) &amp;&amp; element.hasAttribute(POINTCUT_REF)) &#123;</span><br><span class="line">		parserContext.getReaderContext().error(</span><br><span class="line">				<span class="string">"Cannot define both 'pointcut' and 'pointcut-ref' on &lt;advisor&gt; tag."</span>,</span><br><span class="line">				element, <span class="keyword">this</span>.parseState.snapshot());</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (element.hasAttribute(POINTCUT)) &#123;</span><br><span class="line">		<span class="comment">// Create a pointcut for the anonymous pc and register it.</span></span><br><span class="line">		String expression = element.getAttribute(POINTCUT);</span><br><span class="line">		AbstractBeanDefinition pointcutDefinition = createPointcutDefinition(expression);</span><br><span class="line">		pointcutDefinition.setSource(parserContext.extractSource(element));</span><br><span class="line">		<span class="keyword">return</span> pointcutDefinition;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (element.hasAttribute(POINTCUT_REF)) &#123;</span><br><span class="line">		String pointcutRef = element.getAttribute(POINTCUT_REF);</span><br><span class="line">		<span class="keyword">if</span> (!StringUtils.hasText(pointcutRef)) &#123;</span><br><span class="line">			parserContext.getReaderContext().error(</span><br><span class="line">					<span class="string">"'pointcut-ref' attribute contains empty value."</span>, element, <span class="keyword">this</span>.parseState.snapshot());</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> pointcutRef;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		parserContext.getReaderContext().error(</span><br><span class="line">				<span class="string">"Must define one of 'pointcut' or 'pointcut-ref' on &lt;advisor&gt; tag."</span>,</span><br><span class="line">				element, <span class="keyword">this</span>.parseState.snapshot());</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法有点长，但是很好理解：</p>
<p>1.如果当前节点没有pointcut属性和pointcut-ref属性，那么直接返回null。</p>
<p>2.如果当前节点有pointcut属性，则调用createPointcutDefinition创建一个Bean定义，里面对应的bean是一个AspectJExpressionPointcut实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> AbstractBeanDefinition <span class="title">createPointcutDefinition</span><span class="params">(String expression)</span> </span>&#123;</span><br><span class="line">	RootBeanDefinition beanDefinition = <span class="keyword">new</span> RootBeanDefinition(AspectJExpressionPointcut.class);</span><br><span class="line">	beanDefinition.setScope(BeanDefinition.SCOPE_PROTOTYPE);</span><br><span class="line">	beanDefinition.setSynthetic(<span class="keyword">true</span>);</span><br><span class="line">	beanDefinition.getPropertyValues().add(EXPRESSION, expression);</span><br><span class="line">	<span class="keyword">return</span> beanDefinition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到我们把pointcut属性对应的值注入到了AspectJExpressionPointcut的expresssion属性中。</p>
<p>而且要注意这个Bean是原型bean，而我们Spring默认的bean都是单例的。所以当节点中的属性是pointcut时，我们是要给出expression表达式，而对应的Bean是Spring默认给出的。</p>
<p>3.如果节点有pointcut-ref属性，我们直接返回属性值，也就是一个String对象。</p>
<p>2.当得到要注入的pointcut后，根据他的类型来选择不同的操作，如果是pointcut属性，即注入的是一个Bean定义时，我们除了要做必要的注入到构造方法里之外，我们需要把他注入到beanDefinitions这个Bean定义的list中。如果是pointcut-ref,即是String类型，那么额外的操作则变成了把他注入到beanReferences这个BeanReference类型的List，BeanReference的作用这里先稍微说一句，因为有些Bean是需要依赖于其他bean的，所以就需要BeanReference，而具体什么时候起作用以及怎么起作用，我们下次再细说。</p>
<p>我们回到parseAspect方法，我们现在可以吧目光投向parseAdvice后的代码。</p>
<p>我们会将得到的advisorDefinition加入到beanDefinitions。</p>
<p>然后新建一个AspectComponentDefinition实例，里面注入了beanDefinitions和beanReferences。</p>
<p>最后，我们需要对aspect下面的pointcut子节点进行处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Element&gt; pointcuts = DomUtils.getChildElementsByTagName(aspectElement, POINTCUT);</span><br><span class="line">	<span class="keyword">for</span> (Element pointcutElement : pointcuts) &#123;</span><br><span class="line">		parsePointcut(pointcutElement, parserContext);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	parserContext.popAndRegisterContainingComponent();</span><br></pre></td></tr></table></figure>
<p>先得到所有的poincut节点，然后调用parsePointcut注册pointcut的信息，最后会向Spring容器注册一个PointcutComponentDefinition组件。</p>
<p>最后将所有aspect相关信息组成的aspectComponentDefinition注入到Spring容器中。</p>
<p>然后回到parse方法，注入CompositeComponentDefinition到Spring容器中。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2018/01/21/--Spring源码之AOP/" data-id="cjcouzso30000n8bzgj3axs8k" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-session" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/17/session/" class="article-date">
  <time datetime="2018-01-17T14:07:23.732Z" itemprop="datePublished">2018-01-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java-WEB/">Java WEB</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/17/session/">Cookie和Session</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>###前言</p>
<p>最近在看Tomcat的源码，然后想着就把Servlet的相关知识都复习一下吧。自然就需要关注Cookie和Session了。</p>
<p>###Cookie</p>
<p>Response 操作Cookie的方法就一个 addCookie()<br>通常我们添加Cookie的操作如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cookie cookie=<span class="keyword">new</span> Cookie(<span class="string">"name"</span>,<span class="string">"kobe"</span>);</span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure></p>
<p>通常我们这样操作只设置了Cookie的name value<br>但是Cookie还是有很多其他的属性的。<br>name  String   该Cookie的名称。Cookie一旦创建，名称便不可更改<br>value Object   该Cookie的值。如果值为Unicode字符，需要为字符编码。如果值为二进制数据，则需要使用BASE64编码<br>maxAge int     该Cookie失效的时间，单位秒。如果为正数，则该Cookie在maxAge秒之后失效。如果为负数，该Cookie为临时Cookie，关闭浏览器即失效，浏览器也不会以任何形式保存该Cookie。如果为0，表示删除该Cookie。默认为–1<br>secure boolean 该Cookie是否仅被使用安全协议传输。安全协议。安全协议有HTTPS，SSL等，在网络上传输数据之前先将数据加密。默认为false<br><strong>path</strong>  String 该Cookie的使用路径。如果设置为“/sessionWeb/”，则只有contextPath为“/sessionWeb”的程序可以访问该Cookie。如果设置为“/”，则本域名下contextPath都可以访问该Cookie。注意最后一个字符必须为“/”<br>那我们默认没有显式指定的时候是什么呢？<br>这个就跟我们在哪里添加Cookie有关。<br>localhost:8080/mywebapp/testcookie/test1.jsp<br>比如我在/mywebapp/testcookie/test1.jsp中添加的Cookie，没有显示指定path<br>那么这里的path默认就是/mywebapp/testcookie/<br>即默认情况下，只有与创建 cookie 的页面在同一个目录或子目录下的网页才可以访问，这个是因为安全方面的考虑，造成不是所有页面都可以随意访问其他页面创建的 cookie。<br><strong>domain</strong> String<br>可以访问该Cookie的域名。如果设置为“.google.com”，则所有以“google.com”结尾的域名都可以访问该Cookie。注意第一个字符必须为“.”<br>那么如果没有显示的设置呢？<br>如网址为www.jb51.net/test/test.aspx，那么domain默认为www.jb51.net。<br>而跨域访问，如域A为t1.test.com，域B为t2.test.com，那么在域A生产一个令域A和域B都能访问的cookie就要将该cookie的domain设置为.test.com；如果要在域A生产一个令域A不能访问而域B能访问的cookie就要将该cookie的domain设置为t2.test.com。</p>
<p>comment  String<br>该Cookie的用处说明。浏览器显示Cookie信息的时候显示该说明<br>version int 该Cookie使用的版本号。0表示遵循Netscape的Cookie规范，1表示遵循W3C的RFC<br>2109规范</p>
<p>cookie有大小限制 4kb<br>同个网站可以创建多个 cookie ，而多个 cookie 可以存放在同一个cookie 文件中。</p>
<p>介绍了这么多关于Cookie的知识，但是还没有介绍Cookie的应用，我们需要很好的掌握基础知识，但是同样的，我们更需要知道怎样去应用这些知识，学以致用才是我们追求的。</p>
<p>很明显，当没有Cookie的时候，如果我们登陆一个网站，而网站的每一个页面都需要用户名密码验证的时候，我们需要在每次提交访问页面的请求的时候都需要<strong>显式的带上用户名和密码等消息</strong>。（也就是说用户名和密码必须是请求参数），这显然是很糟糕的体验，所以Cookie就出现了，他解决了这一问题。<br>有了Cookie之后可以这么做呢，第一次登陆页面的请求过来，请求参数里面必然是有用户名和密码的。那么我们在服务器端(以Java语言 web容器:Tomcat 为例),将用户名和密码的信息添加到Cookie当中，使用response.addCookie添加。然后将信息存入数据库中。<br>你观看Tomcat的源码：org.apache.catalina.connector.Response就可以看到最后Cookie的信息会存到Set-Cookie这个响应头字段中。<br>然后Cookie信息就会到浏览器中了，这个时候浏览器会根据maxAge即Cookie的有效时间来判断是否需要存放在本地磁盘中，如果maxAge没有在服务器端进行显示的设置，即默认的设置为-1,那么这个Cookie就会随着浏览器窗口的关闭而失效。而如果是一个d大于0的maxAge，就会将其存放到本地磁盘中。（不同的浏览器的存放位置不同），而不同domain或者path的Cookie都会存放在不同的Cookie文件中，而两者都相同的Cookie会存在同一文件中。<br>那么这里很明显我们需要设置一个显式的maxAge，单位为秒，如果希望密码保存一星期则<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cookie.setMaxAge(<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>*<span class="number">7</span>);</span><br></pre></td></tr></table></figure></p>
<p>这时，当我们第二次访问该网站的页面的时候，在我们的请求头里就会出现Cookie的相关信息。<br>会在请求头的Cookie字段中。（因为domain和path都符合，所以我们存在本地磁盘的用户名和密码cookie会出现在请求头中），这时候我们在服务器端再需要验证登录是否合法的时候，就不需要把用户名和密码显示的拿过来了，因为已经在Cookie中带过来了，那么我们就可以在服务器端中找到相应的Cookie信息，然后再去与数据库中的信息比较，看是否有效。这样就避免了每次都要输入用户名和密码。</p>
<p>但是很明显，如果你不是一个开发小白，你就知道上述的设计存在很多问题。<br>1.直接把密码放入到Cookie中也太不严谨了把，cookie信息可是可以直接用js获取的，是没有任何安全保障的。<br>2.是否真的需要每次去把cookie中的信息放到数据库（特指传统的关系型数据库）中去比较。</p>
<p>对于第一点，也就是安全性，相对于第二点的性能，这是我们急需用解决的。<br>解决方法：可能你一开始就会想到，之前不是说了cookie有一个属性叫做secure，你在设置cookie的时候把他设置成true不就好了么，这样他就只能在HTTPS,SSL等安全协议下传输了。但是他也只能保证 cookie 与服务器之间的数据传输过程加密，而保存在本地的 cookie文件并不加密。所以如果想让本地cookie也加密，就得自己加密数据。<br>所以，我们不仅用使用安全传输协议，还需要将cookie信息进行加密。</p>
<p>我们进行如下改进，第一次请求时，我们依然会把用户名和密码存入数据库中，或者查询，看是否已经有这个用户，这是跟数据库的第一次交互。<br>然后我们使用一个密钥将用户名加密，将加密后的密文和用户名分别放入相应的cookie中。而在之后的请求中，服务器端会将用户名再次用密钥进行加密，然后与cookie中的密文进行比较。这样就避免了多次访问数据库以及暴露密码的问题。</p>
<p>###Session<br>在每个context对象，即每个web app都具有一个独立的manager对象。通过server.xml可以配置定制化的manager，也可以不配置。不管怎样，在生成context对象时，都会生成一个manager对象。缺省的是StandardManager类。相应的代码在ContextRuleSet的addRuleInstances方法中。涉及到Digester解析XML的知识,这方面的知识要赶紧啃了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">digester.addObjectCreate(prefix + <span class="string">"Context/Manager"</span>,</span><br><span class="line">                         <span class="string">"org.apache.catalina.session.StandardManager"</span>,</span><br><span class="line">                         <span class="string">"className"</span>);</span><br><span class="line">digester.addSetProperties(prefix + <span class="string">"Context/Manager"</span>);</span><br><span class="line">digester.addSetNext(prefix + <span class="string">"Context/Manager"</span>,</span><br><span class="line">                    <span class="string">"setManager"</span>,</span><br><span class="line">                    <span class="string">"org.apache.catalina.Manager"</span>);</span><br><span class="line"></span><br><span class="line">digester.addObjectCreate(prefix + <span class="string">"Context/Manager/Store"</span>,</span><br><span class="line">                         <span class="keyword">null</span>, <span class="comment">// MUST be specified in the element</span></span><br><span class="line">                         <span class="string">"className"</span>);</span><br><span class="line">digester.addSetProperties(prefix + <span class="string">"Context/Manager/Store"</span>);</span><br><span class="line">digester.addSetNext(prefix + <span class="string">"Context/Manager/Store"</span>,</span><br><span class="line">                    <span class="string">"setStore"</span>,</span><br><span class="line">                    <span class="string">"org.apache.catalina.Store"</span>);</span><br><span class="line"></span><br><span class="line">digester.addObjectCreate(prefix + <span class="string">"Context/Manager/SessionIdGenerator"</span>,</span><br><span class="line">                         <span class="string">"org.apache.catalina.util.StandardSessionIdGenerator"</span>,</span><br><span class="line">                         <span class="string">"className"</span>);</span><br><span class="line">digester.addSetProperties(prefix + <span class="string">"Context/Manager/SessionIdGenerator"</span>);</span><br><span class="line">digester.addSetNext(prefix + <span class="string">"Context/Manager/SessionIdGenerator"</span>,</span><br><span class="line">                    <span class="string">"setSessionIdGenerator"</span>,</span><br><span class="line">                    <span class="string">"org.apache.catalina.SessionIdGenerator"</span>);</span><br></pre></td></tr></table></figure></p>
<p>第一次请求过来是不会带有Cookie的，也就不会有jsessionId出现。Session其实也是一种Cookie。请求过来后，服务器端就会为这个请求的客户机加上Cookie作为标识了。</p>
<p>browser发送Http request；<br>tomcat内核Http11Processor会从HTTP request中解析出“jsessionid”(具体的解析过程为先从request的URL中解析，这是为了有的浏览器把cookie功能禁止后，将URL重写考虑的，如果解析不出来，再从cookie中解析相应的jsessionid)，解析完后封装成一个request对象(当然还有其他的http header)；<br>servlet中获取session，其过程是根据刚才解析得到的jsessionid(如果有的话)，从session池(session maps)中获取相应的session对象；这个地方有个逻辑，就是如果jsessionid为空的话(或者没有其对应的session对象，或者有session对象，但此对象已经过期超时)，可以选择创建一个session，或者不创建；<br>如果创建新session，则将session放入session池中，同时将与其相对应的jsessionid写入cookie通过Http response header的方式发送给browser，然后重复第一步。</p>
<p>以上是session的获取及创建过程。在servlet中获取session，通常是调用request的getSession方法。这个方法需要传入一个boolean参数，这个参数就是实现刚才说的，当jsessionid为空或从session池中获取不到相应的session对象时，选择创建一个新的session还是不创建。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> Session <span class="title">doGetSession</span><span class="params">(<span class="keyword">boolean</span> create)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// There cannot be a session if no context has been assigned yet</span></span><br><span class="line">     Context context = getContext();</span><br><span class="line">     <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> (<span class="keyword">null</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//如果有session存在但是无效</span></span><br><span class="line">     <span class="comment">// Return the current session if it exists and is valid</span></span><br><span class="line">     <span class="keyword">if</span> ((session != <span class="keyword">null</span>) &amp;&amp; !session.isValid()) &#123;</span><br><span class="line">         session = <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//如果有效，直接返回</span></span><br><span class="line">     <span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> (session);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//       获取所在context的manager对象   </span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// Return the requested session if it exists and is valid</span></span><br><span class="line">     Manager manager = context.getManager();</span><br><span class="line">     <span class="keyword">if</span> (manager == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;        <span class="comment">// Sessions are not supported</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//requestedSessionId就是从Http request中解析出来的  </span></span><br><span class="line">     <span class="keyword">if</span> (requestedSessionId != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             session = manager.findSession(requestedSessionId);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">             session = <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//如果存在但无效</span></span><br><span class="line">         <span class="keyword">if</span> ((session != <span class="keyword">null</span>) &amp;&amp; !session.isValid()) &#123;</span><br><span class="line">             session = <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//如果有效，返回</span></span><br><span class="line">         <span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">         	<span class="comment">//session对象有效，记录此次访问时间  </span></span><br><span class="line"></span><br><span class="line">             session.access();</span><br><span class="line">             <span class="keyword">return</span> (session);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 如果参数是false，则不创建新session对象了，直接退出了  </span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// Create a new session if requested and the response is not committed</span></span><br><span class="line">     <span class="keyword">if</span> (!create) &#123;</span><br><span class="line">         <span class="keyword">return</span> (<span class="keyword">null</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> ((response != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">         context.getServletContext().getEffectiveSessionTrackingModes().</span><br><span class="line">                 contains(SessionTrackingMode.COOKIE) &amp;&amp;</span><br><span class="line">         response.getResponse().isCommitted()) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException</span><br><span class="line">           (sm.getString(<span class="string">"coyoteRequest.sessionCreateCommitted"</span>));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//在非常有限的情况下重用客户端提供的会话id。</span></span><br><span class="line">     <span class="comment">// Re-use session IDs provided by the client in very limited</span></span><br><span class="line">     <span class="comment">// circumstances.</span></span><br><span class="line">     String sessionId = getRequestedSessionId();</span><br><span class="line">     <span class="keyword">if</span> (requestedSessionSSL) &#123;</span><br><span class="line">     	<span class="comment">//如果会话ID是从SSL握手获得的</span></span><br><span class="line">         <span class="comment">// If the session ID has been obtained from the SSL handshake then</span></span><br><span class="line">         <span class="comment">// use it.</span></span><br><span class="line">     &#125; </span><br><span class="line">     <span class="comment">//如果路径为/ ，且sessionId是从url中获得的，即url重写获得</span></span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="string">"/"</span>.equals(context.getSessionCookiePath())</span><br><span class="line">             &amp;&amp; isRequestedSessionIdFromCookie())) &#123;</span><br><span class="line">             <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这是常见的(ish)用例:使用相同的会话ID。</span></span><br><span class="line"><span class="comment">同一主机上的多个web应用程序。通常这是</span></span><br><span class="line"><span class="comment">用于Portlet实现。只有在session会话通过cookie跟踪时才有效。</span></span><br><span class="line"><span class="comment">。cookie必须有一条“/”的路径。</span></span><br><span class="line"><span class="comment">否则不会提供给所有web应用程序的请求。</span></span><br><span class="line"><span class="comment">客户提供的任何会话ID都应该是一个会话。</span></span><br><span class="line"><span class="comment">已经存在于主机的某个地方。只有当上下文</span></span><br><span class="line"><span class="comment">被标识为要确认的时候才会检查。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">         <span class="comment">/* This is the common(ish) use case: using the same session ID with</span></span><br><span class="line"><span class="comment">          * multiple web applications on the same host. Typically this is</span></span><br><span class="line"><span class="comment">          * used by Portlet implementations. It only works if sessions are</span></span><br><span class="line"><span class="comment">          * tracked via cookies. The cookie must have a path of "/" else it</span></span><br><span class="line"><span class="comment">          * won't be provided for requests to all web applications.</span></span><br><span class="line"><span class="comment">          *</span></span><br><span class="line"><span class="comment">          * Any session ID provided by the client should be for a session</span></span><br><span class="line"><span class="comment">          * that already exists somewhere on the host. Check if the context</span></span><br><span class="line"><span class="comment">          * is configured for this to be confirmed.</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         <span class="keyword">if</span> (context.getValidateClientProvidedNewSessionId()) &#123;</span><br><span class="line">             <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">             <span class="keyword">for</span> (Container container : getHost().findChildren()) &#123;</span><br><span class="line">                 Manager m = ((Context) container).getManager();</span><br><span class="line">                 <span class="keyword">if</span> (m != <span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="keyword">try</span> &#123;</span><br><span class="line">                         <span class="keyword">if</span> (m.findSession(sessionId) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                             found = <span class="keyword">true</span>;</span><br><span class="line">                             <span class="keyword">break</span>;</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                         <span class="comment">// Ignore. Problems with this manager will be</span></span><br><span class="line">                         <span class="comment">// handled elsewhere.</span></span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">                 sessionId = <span class="keyword">null</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         sessionId = <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//创建一个session</span></span><br><span class="line">     session = manager.createSession(sessionId);</span><br><span class="line">     <span class="comment">// 将新session的jsessionid写入cookie，传给browser ，佐证了session也是cookie</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="comment">// Creating a new session cookie based on that session</span></span><br><span class="line">     <span class="keyword">if</span> ((session != <span class="keyword">null</span>) &amp;&amp; (getContext() != <span class="keyword">null</span>)</span><br><span class="line">            &amp;&amp; getContext().getServletContext().</span><br><span class="line">                    getEffectiveSessionTrackingModes().contains(</span><br><span class="line">                            SessionTrackingMode.COOKIE)) &#123;</span><br><span class="line">         Cookie cookie =</span><br><span class="line">             ApplicationSessionCookieConfig.createSessionCookie(</span><br><span class="line">                     context, session.getIdInternal(), isSecure());</span><br><span class="line"></span><br><span class="line">         response.addSessionCookieInternal(cookie);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (session == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//记录访问时间</span></span><br><span class="line">     session.access();</span><br><span class="line">     <span class="keyword">return</span> session;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session = manager.createSession(sessionId);</span><br></pre></td></tr></table></figure>
<p> StandardManager父类ManagerBase中实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Session <span class="title">createSession</span><span class="params">(String sessionId)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> ((maxActiveSessions &gt;= <span class="number">0</span>) &amp;&amp;</span><br><span class="line">              (getActiveSessions() &gt;= maxActiveSessions)) &#123;</span><br><span class="line">          rejectedSessions++;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> TooManyActiveSessionsException(</span><br><span class="line">                  sm.getString(<span class="string">"managerBase.createSession.ise"</span>),</span><br><span class="line">                  maxActiveSessions);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// Recycle or create a Session instance</span></span><br><span class="line">      Session session = createEmptySession();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Initialize the properties of the new session and return it</span></span><br><span class="line">      session.setNew(<span class="keyword">true</span>);</span><br><span class="line">      session.setValid(<span class="keyword">true</span>);</span><br><span class="line">      session.setCreationTime(System.currentTimeMillis());</span><br><span class="line">      session.setMaxInactiveInterval(((Context) getContainer()).getSessionTimeout() * <span class="number">60</span>);</span><br><span class="line">      String id = sessionId;</span><br><span class="line">      <span class="keyword">if</span> (id == <span class="keyword">null</span>) &#123;</span><br><span class="line">      	<span class="comment">//会去重</span></span><br><span class="line">          id = generateSessionId();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//在这里将session放入sessions中</span></span><br><span class="line">      session.setId(id);</span><br><span class="line">      sessionCounter++;</span><br><span class="line"></span><br><span class="line">      SessionTiming timing = <span class="keyword">new</span> SessionTiming(session.getCreationTime(), <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">synchronized</span> (sessionCreationTiming) &#123;</span><br><span class="line">          sessionCreationTiming.add(timing);</span><br><span class="line">          sessionCreationTiming.poll();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> (session);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>生产id的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">generateSessionId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String result = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Not thread-safe but if one of multiple increments is lost</span></span><br><span class="line">            <span class="comment">// that is not a big deal since the fact that there was any</span></span><br><span class="line">            <span class="comment">// duplicate is a much bigger issue.</span></span><br><span class="line">            duplicates++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result = sessionIdGenerator.generateSessionId();</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">while</span> (sessions.containsKey(result));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用算法生成id,然后会在sessions这个map中查看是否有重复，起到去重的效果。</p>
<p>###URL地址重写<br>URL地址重写是对客户端不支持Cookie的解决方案。URL地址重写的原理是将该用户Session的id信息重写到URL地址中。服务器能够解析重写后的URL获取Session的id。这样即使客户端不支持Cookie，也可以使用Session来记录用户状态。HttpServletResponse类提供了encodeURL(Stringurl)实现URL地址重写</p>
<p>该方法会自动判断客户端是否支持Cookie。如果客户端支持Cookie，会将URL原封不动地输出来。如果客户端不支持Cookie，则会将用户Session的id重写到URL中。<br>增添的jsessionid字符串既不会影响请求的文件名，也不会影响提交的地址栏参数。用户单击这个链接的时候会把Session的id通过URL提交到服务器上，服务器通过解析URL地址获得Session的id。<br>对于WAP程序，由于大部分的手机浏览器都不支持Cookie，WAP程序都会采用URL地址重写来跟踪用户会话。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">response.encodeURL(<span class="string">"index.jsp?c=1&amp;wd=Java"</span>);</span><br><span class="line"><span class="comment">//用于重定向</span></span><br><span class="line">response.sendRedirect(response.encodeRedirectURL(“administrator.jsp”));</span><br></pre></td></tr></table></figure>
<p><strong>encodeURL</strong>       org.apache.catalina.connector.Response(真正我们用户能看到的HttpServletResponse实现类是他的封装类ResponseFacade)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">encodeURL</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       String absolute;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           absolute = toAbsolute(url);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IllegalArgumentException iae) &#123;</span><br><span class="line">           <span class="comment">// Relative URL</span></span><br><span class="line">           <span class="keyword">return</span> url;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (isEncodeable(absolute)) &#123;</span><br><span class="line">           <span class="comment">// W3c spec clearly said</span></span><br><span class="line">           <span class="keyword">if</span> (url.equalsIgnoreCase(<span class="string">""</span>)) &#123;</span><br><span class="line">               url = absolute;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (url.equals(absolute) &amp;&amp; !hasPath(url)) &#123;</span><br><span class="line">               url += <span class="string">'/'</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> (toEncoded(url, request.getSessionInternal().getIdInternal()));</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> (url);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>关键在toEncoded<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">protected</span> String <span class="title">toEncoded</span><span class="params">(String url, String sessionId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((url == <span class="keyword">null</span>) || (sessionId == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (url);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String path = url;</span><br><span class="line">        String query = <span class="string">""</span>;</span><br><span class="line">        String anchor = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> question = url.indexOf(<span class="string">'?'</span>);</span><br><span class="line">        <span class="keyword">if</span> (question &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            path = url.substring(<span class="number">0</span>, question);</span><br><span class="line">            query = url.substring(question);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pound = path.indexOf(<span class="string">'#'</span>);</span><br><span class="line">        <span class="keyword">if</span> (pound &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            anchor = path.substring(pound);</span><br><span class="line">            path = path.substring(<span class="number">0</span>, pound);</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(path);</span><br><span class="line">        <span class="keyword">if</span>( sb.length() &gt; <span class="number">0</span> ) &#123; <span class="comment">// jsessionid can't be first.</span></span><br><span class="line">            sb.append(<span class="string">";"</span>);</span><br><span class="line">            sb.append(SessionConfig.getSessionUriParamName(</span><br><span class="line">                    request.getContext()));</span><br><span class="line">            sb.append(<span class="string">"="</span>);</span><br><span class="line">            sb.append(sessionId);</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(anchor);</span><br><span class="line">        sb.append(query);</span><br><span class="line">        <span class="keyword">return</span> (sb.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SessionConfig.getSessionUriParamName(</span><br><span class="line">request.getContext()));</span><br></pre></td></tr></table></figure>
<p>  调用了这个方法来获取jsessionId<br>  具体获取方法有兴趣的可以深入研究。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2018/01/17/session/" data-id="cjcj5a2ja0000lobzn8o9nly1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-对classpath的理解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/14/对classpath的理解/" class="article-date">
  <time datetime="2018-01-14T13:50:41.923Z" itemprop="datePublished">2018-01-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaWEB/">JavaWEB</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/14/对classpath的理解/">对classpath的理解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在看一个项目，看到他在web.xml配置文件中使用了classpath*:后跟配置文件通配符。</p>
<p>而我一般都是用的classpath:,这时候突然想起我之前有特意查阅过两种方式的区别，不过很遗憾的是我已经忘了，所以这次打算记录下来，就算以后再忘了也后及时查阅。</p>
<h3 id="ResourceLoader"><a href="#ResourceLoader" class="headerlink" title="ResourceLoader"></a>ResourceLoader</h3><p>我们废话不多说，直接看spring对这两种方式修饰配置文件位置的方法是如何加载相应配置文件。</p>
<p>回到AbstractApplicationContext的refresh方法，我们看获取Beanfactory的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">		ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	refreshBeanFactory();</span><br><span class="line">	ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(<span class="string">"Bean factory for "</span> + getDisplayName() + <span class="string">": "</span> + beanFactory);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入AbstractRefreshableApplicationContext的refreshBeanFactory</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">			destroyBeans();</span><br><span class="line">			closeBeanFactory();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">			beanFactory.setSerializationId(getId());</span><br><span class="line">			customizeBeanFactory(beanFactory);</span><br><span class="line">			loadBeanDefinitions(beanFactory);</span><br><span class="line">			<span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">				<span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"I/O error parsing bean definition source for "</span> + getDisplayName(), ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>其中有一个loadBeanDefinitions(beanFactory);就是在这个方法里，我们<strong>读取配置文件并注册Bean</strong></p>
<p>XmlWebApplicationContext(默认是该实例)的loadBeanDefinitions</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">		<span class="comment">// Create a new XmlBeanDefinitionReader for the given BeanFactory.</span></span><br><span class="line">		XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Configure the bean definition reader with this context's</span></span><br><span class="line">		<span class="comment">// resource loading environment.</span></span><br><span class="line">		beanDefinitionReader.setEnvironment(getEnvironment());</span><br><span class="line">		beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">		beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Allow a subclass to provide custom initialization of the reader,</span></span><br><span class="line">		<span class="comment">// then proceed with actually loading the bean definitions.</span></span><br><span class="line">		initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">		loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到有为beanDefinitionReader设置ResourceLoader</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<p>这里我们将XmlWebApplicationContext实例设置为了ResourceLoader，因为XmlWebApplicationContext也是一个实现了ResourceLoader的类的子类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlWebApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractRefreshableWebApplicationContext</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRefreshableWebApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractRefreshableConfigApplicationContext</span></span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">ConfigurableWebApplicationContext</span>, <span class="title">ThemeSource</span> </span>&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRefreshableConfigApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractRefreshableApplicationContext</span></span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">BeanNameAware</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRefreshableApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractApplicationContext</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">extends</span> <span class="title">DefaultResourceLoader</span></span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">ConfigurableApplicationContext</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultResourceLoader</span> <span class="keyword">implements</span> <span class="title">ResourceLoader</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<p>接着看        loadBeanDefinitions(beanDefinitionReader);</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	String[] configLocations = getConfigLocations();</span><br><span class="line">	<span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (String configLocation : configLocations) &#123;</span><br><span class="line">			reader.loadBeanDefinitions(configLocation);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>org.springframework.beans.factory.xml.XmlBeanDefinitionReader父类AbstractBeanDefinitionReader</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> loadBeanDefinitions(location, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location, Set&lt;Resource&gt; actualResources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">	ResourceLoader resourceLoader = getResourceLoader();</span><br><span class="line">	<span class="keyword">if</span> (resourceLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">				<span class="string">"Cannot import bean definitions from location ["</span> + location + <span class="string">"]: no ResourceLoader available"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (resourceLoader <span class="keyword">instanceof</span> ResourcePatternResolver) &#123;</span><br><span class="line">		<span class="comment">// Resource pattern matching available.</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);</span><br><span class="line">			<span class="keyword">int</span> loadCount = loadBeanDefinitions(resources);</span><br><span class="line">			<span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">					actualResources.add(resource);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">"Loaded "</span> + loadCount + <span class="string">" bean definitions from location pattern ["</span> + location + <span class="string">"]"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> loadCount;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">					<span class="string">"Could not resolve bean definition resource pattern ["</span> + location + <span class="string">"]"</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Can only load single resources by absolute URL.</span></span><br><span class="line">		Resource resource = resourceLoader.getResource(location);</span><br><span class="line">		<span class="keyword">int</span> loadCount = loadBeanDefinitions(resource);</span><br><span class="line">		<span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">			actualResources.add(resource);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">"Loaded "</span> + loadCount + <span class="string">" bean definitions from location ["</span> + location + <span class="string">"]"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> loadCount;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        ResourceLoader resourceLoader = getResourceLoader();</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">	public ResourceLoader getResourceLoader() &#123;</span><br><span class="line">		return this.resourceLoader;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>resourceLoader就是XmlWebApplicationContext实例</p>
<p>主要关注    Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);</p>
<p>XmlWebApplicationContext没有直接实现这个方法，在祖先类AbstractApplicationContext中实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Resource[] getResources(String locationPattern) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.resourcePatternResolver.getResources(locationPattern);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们真正调用的是resourcePatternResolver的getResources方法，那他到底是哪个实例呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.resourcePatternResolver = getResourcePatternResolver();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> ResourcePatternResolver <span class="title">getResourcePatternResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> PathMatchingResourcePatternResolver(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>org.springframework.core.io.support.PathMatchingResourcePatternResolver的getResources</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Resource[] getResources(String locationPattern) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">	Assert.notNull(locationPattern, <span class="string">"Location pattern must not be null"</span>);</span><br><span class="line">	<span class="keyword">if</span> (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) &#123;</span><br><span class="line">		<span class="comment">// a class path resource (multiple resources for same name possible)</span></span><br><span class="line">		<span class="keyword">if</span> (getPathMatcher().isPattern(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) &#123;</span><br><span class="line">			<span class="comment">// a class path resource pattern</span></span><br><span class="line">			<span class="keyword">return</span> findPathMatchingResources(locationPattern);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// all class path resources with the given name</span></span><br><span class="line">			<span class="keyword">return</span> findAllClassPathResources(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Only look for a pattern after a prefix here</span></span><br><span class="line">		<span class="comment">// (to not get fooled by a pattern symbol in a strange prefix).</span></span><br><span class="line">		<span class="keyword">int</span> prefixEnd = locationPattern.indexOf(<span class="string">":"</span>) + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) &#123;</span><br><span class="line">			<span class="comment">// a file pattern</span></span><br><span class="line">			<span class="keyword">return</span> findPathMatchingResources(locationPattern);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// a single resource with the given name</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Resource[] &#123;getResourceLoader().getResource(locationPattern)&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>终于来到我们要分析的方法了</strong></p>
<p>再说一下，这个方法是位于org.springframework.core.io.support.PathMatchingResourcePatternResolver的getResources。</p>
<p>我们初看一下这个方法，可以看到大概分三个分支来处理资源的加载。</p>
<p>而如果按照classpath和classpath*来区分的话，很显然就是两种。</p>
<p>当这种两种方式的配置文件路径都是统配符的时候调用的是同一个方法，当然具体方法里的流程还是不一样的，当是指定路径的时候都有各自的处理方法，我们先就从无通配符先来分析吧。</p>
<ul>
<li><p><strong>classpath*</strong></p>
<p>findAllClassPathResources</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Resource[] findAllClassPathResources(String location) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">	String path = location;</span><br><span class="line">	<span class="keyword">if</span> (path.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">		path = path.substring(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	Set&lt;Resource&gt; result = doFindAllClassPathResources(path);</span><br><span class="line">	<span class="keyword">return</span> result.toArray(<span class="keyword">new</span> Resource[result.size()]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果location以/打头，把/去掉，然后调用</p>
<p>doFindAllClassPathResources得到我们想要的资源</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Set&lt;Resource&gt; <span class="title">doFindAllClassPathResources</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		Set&lt;Resource&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;Resource&gt;(<span class="number">16</span>);</span><br><span class="line">		ClassLoader cl = getClassLoader();</span><br><span class="line">		Enumeration&lt;URL&gt; resourceUrls = (cl != <span class="keyword">null</span> ? cl.getResources(path) : ClassLoader.getSystemResources(path));</span><br><span class="line">		<span class="keyword">while</span> (resourceUrls.hasMoreElements()) &#123;</span><br><span class="line">			URL url = resourceUrls.nextElement();</span><br><span class="line">			result.add(convertClassLoaderURL(url));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="string">""</span>.equals(path)) &#123;</span><br><span class="line">			<span class="comment">// The above result is likely to be incomplete, i.e. only containing file system references.</span></span><br><span class="line">			<span class="comment">// We need to have pointers to each of the jar files on the classpath as well...</span></span><br><span class="line">			addAllClassLoaderJarRoots(cl, result);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>1.先定义一个size为16的LinkedHashSet集合，命名为result。</p>
<p>2、然后通过getClassLoader();方法得到一个ClassLaoder对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> getResourceLoader().getClassLoader();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ResourceLoader <span class="title">getResourceLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.resourceLoader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显是调用了resourceLoader属性的getClassLoader();方法，那么这个对象是什么呢，又是什么时候注入的呢，其实上面已经给出答案了。这个对象是一个XmlWebApplicationContext实例。最后你会发现调用的祖先类DefaultResourceLoader的getClassLoader方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">this</span>.classLoader != <span class="keyword">null</span> ? <span class="keyword">this</span>.classLoader : ClassUtils.getDefaultClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后你会发现ClassLoader对象是由ClassUtils.getDefaultClassLoader()得到的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getDefaultClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ClassLoader cl = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		cl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="comment">// Cannot access thread context ClassLoader - falling back...</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (cl == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// No thread context class loader -&gt; use class loader of this class.</span></span><br><span class="line">		cl = ClassUtils.class.getClassLoader();</span><br><span class="line">		<span class="keyword">if</span> (cl == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// getClassLoader() returning null indicates the bootstrap ClassLoader</span></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				cl = ClassLoader.getSystemClassLoader();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">				<span class="comment">// Cannot access system ClassLoader - oh well, maybe the caller can live with null...</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先取当前线程的ClassLoader实例，如果取不到，那就调用ClassUtils类的classLoader实例，如果还是没有，就调用ClassLoader.getSystemClassLoader();返回委托的系统类加载器。该加载器是新的 ClassLoader 实例的默认委托父类加载器，通常是用来启动应用程序的类加载器。 </p>
<p>在运行时启动序列的早期首先调用此方法，这时会创建系统类加载器并将其设置为调用 Thread 的上下文类加载器。<br>默认的系统类加载器是此类的一个与实现有关的实例。 </p>
<p>3.由上面得到的类加载器实例调用 cl.getResources(path)来ClassLoader (Java Platform SE 6)</p>
<p>查找所有给定名称的资源。资源是可以通过类代码以与代码基无关的方式访问的某些数据（图像、声音、文本等）。 </p>
<p>4.将得到的资源的URL封装成UrlResource放入到rusult集合中。</p>
<p>5.如果路径不为“”的话，此时就可以返回result了，但是如果一旦为“”的时候，那就需要调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addAllClassLoaderJarRoots(cl, result);</span><br></pre></td></tr></table></figure>
<p>对类路径中的每个jar文件加载。</p>
<p>​</p>
<p>​</p>
</li>
<li><p><strong>classpath</strong></p>
<p>其实更准确的说是非classpath*</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Resource <span class="title">getResource</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">	Assert.notNull(location, <span class="string">"Location must not be null"</span>);</span><br><span class="line">	<span class="keyword">if</span> (location.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> getResourceByPath(location);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (location.startsWith(CLASSPATH_URL_PREFIX)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// Try to parse the location as a URL...</span></span><br><span class="line">			URL url = <span class="keyword">new</span> URL(location);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (MalformedURLException ex) &#123;</span><br><span class="line">			<span class="comment">// No URL -&gt; resolve as resource path.</span></span><br><span class="line">			<span class="keyword">return</span> getResourceByPath(location);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.如果是以/打头的生成一个ClassPathContextResource类型对象，这个类是DefaultResourceLoader的内部类，继承了ClassPathResource类，实际上还是调用的是后者的方法，在构造方法中会去掉/。</p>
<p>2.如果是以classpath:打头的，生成一个ClassPathResource对象。</p>
<p>3,否则就尝试创建一个UrlResource对象，如果创建失败，生成一个ClassPathContextResource对象返回。</p>
</li>
<li><p>通配符findPathMatchingResources</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Resource <span class="title">getResource</span><span class="params">(String location)</span> </span>&#123;  </span><br><span class="line">    Assert.notNull(location, <span class="string">"Location must not be null"</span>);  </span><br><span class="line">    <span class="keyword">if</span> (location.startsWith(CLASSPATH_URL_PREFIX)) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="comment">// Try to parse the location as a URL...  </span></span><br><span class="line">            URL url = <span class="keyword">new</span> URL(location);  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> UrlResource(url);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">catch</span> (MalformedURLException ex) &#123;  </span><br><span class="line">            <span class="comment">// No URL -&gt; resolve as resource path.  </span></span><br><span class="line">            <span class="keyword">return</span> getResourceByPath(location);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">其实很简单，如果以classpath开头，则创建为一个ClassPathResource，否则则试图以URL的方式加载资源，创建一个UrlResource.</span><br><span class="line">路径包含通配符的</span><br><span class="line">             这种情况是最复杂的，涉及到层层递归，那我把加了注释的代码发出来大家看一下，其实主要的思想就是</span><br><span class="line"><span class="number">1</span>.先获取目录，加载目录里面的所有资源</span><br><span class="line"><span class="number">2</span>.在所有资源里面进行查找匹配，找出我们需要的资源</span><br><span class="line">[java] view plain copy</span><br><span class="line"><span class="keyword">protected</span> Resource[] findPathMatchingResources(String locationPattern) <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">        <span class="comment">//拿到能确定的目录，即拿到不包括通配符的能确定的路径  比如classpath*:/aaa/bbb/spring-*.xml 则返回classpath*:/aaa/bbb/                                     //如果是classpath*:/aaa/*/spring-*.xml，则返回 classpath*:/aaa/  </span></span><br><span class="line">        String rootDirPath = determineRootDir(locationPattern);  </span><br><span class="line">        <span class="comment">//得到spring-*.xml  </span></span><br><span class="line">        String subPattern = locationPattern.substring(rootDirPath.length());  </span><br><span class="line">        <span class="comment">//递归加载所有的根目录资源，要注意的是递归的时候又得考虑classpath,与classpath*的情况，而且还得考虑根路径中是否又包含通配符，参考上面那张流程图  </span></span><br><span class="line">        Resource[] rootDirResources = getResources(rootDirPath);  </span><br><span class="line">        Set&lt;Resource&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;Resource&gt;(<span class="number">16</span>);  </span><br><span class="line">        <span class="comment">//将根目录所有资源中所有匹配我们需要的资源(如spring-*)加载result中  </span></span><br><span class="line">        <span class="keyword">for</span> (Resource rootDirResource : rootDirResources) &#123;  </span><br><span class="line">            rootDirResource = resolveRootDirResource(rootDirResource);  </span><br><span class="line">            <span class="keyword">if</span> (isJarResource(rootDirResource)) &#123;  </span><br><span class="line">                result.addAll(doFindPathMatchingJarResources(rootDirResource, subPattern));  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rootDirResource.getURL().getProtocol().startsWith(ResourceUtils.URL_PROTOCOL_VFS)) &#123;  </span><br><span class="line">                result.addAll(VfsResourceMatchingDelegate.findMatchingResources(rootDirResource, subPattern, getPathMatcher()));  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span> &#123;  </span><br><span class="line">                result.addAll(doFindPathMatchingFileResources(rootDirResource, subPattern));  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </span><br><span class="line">            logger.debug(<span class="string">"Resolved location pattern ["</span> + locationPattern + <span class="string">"] to resources "</span> + result);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> result.toArray(<span class="keyword">new</span> Resource[result.size()]);  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>1.先获取目录，加载目录里面的所有资源</p>
<p>2.在所有资源里面进行查找匹配，找出我们需要的资源</p>
<p><strong>一定要注意determineRootDir得到的是完全确定的目录，也就是说这个目录结构中是不能包含通配符的</strong>.</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1.无论是classpath还是classpath*都可以加载整个classpath下（包括jar包里面）的资源文件。</p>
<p>2.classpath只会返回第一个匹配的资源，查找路径是优先在项目中存在资源文件，再查找jar包。classpath*:会找到所有的。</p>
<p>3.其实两者的区别实际上就是ClassLoader的getResoure和getResources的区别。</p>
<p>classpath*:调用的是getResources,这个已经很明显了，而你如果去观看classpath对应的Resource封装类，你会发现getUrl方法内部都是调用的getResource方法。</p>
<p>4.当出现classpath:spring*/spring-*.xml和classpath<em>\</em>:spring<em>/spring-\</em>.xml时，前者找不到资源后者可以找到。（当然前提是相应位置有），这个到底是否是正确的，还需要明天去公司验证。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2018/01/14/对classpath的理解/" data-id="cjcj5a2ji0001lobz904zktw2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Spring配置文件解析(一)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/11/Spring配置文件解析(一)/" class="article-date">
  <time datetime="2018-01-10T16:08:24.749Z" itemprop="datePublished">2018-01-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/11/Spring配置文件解析(一)/">Spring之BeanFactoryPostProcessor</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>今天在编写代码的时候，在ldap的spring配置文件中也使用了PropertyPlaceholderConfigurer来解析配置文件，而applicationContext这个根配置文件中已经使用了这个配置了，导致配置文件读取不到报错，后来，我只在根配置文件留了相关配置，把配置文件都放在这里面解析，然后就OK了。可是为什么不能有多个PropertyPlaceholderConfigurer实例呢？我们必须要搞清楚。</p>
<p>先看一个简单的配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"propertyConfigurer"</span></span></span><br><span class="line"><span class="tag">		<span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"locations"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">value</span>&gt;</span>classpath:um.properties<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">value</span>&gt;</span>classpath:jms.properties<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">value</span>&gt;</span>classpath:ldap.properties<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>而查找资料，我们可以很容易的看到当想要有多个实例共存的配置其实很简单，就是在配置文件里加上一个属性，</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"ignoreUnresolvablePlaceholders"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>即改成</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"propertyConfigurer"</span></span><br><span class="line">		<span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span><br><span class="line">		&lt;property name=<span class="string">"ignoreUnresolvablePlaceholders"</span> value=<span class="string">"true"</span>/&gt;</span><br><span class="line">		&lt;property name=<span class="string">"locations"</span>&gt;</span><br><span class="line">		</span><br><span class="line">			&lt;list&gt;</span><br><span class="line">				&lt;value&gt;classpath:um.properties&lt;/value&gt;</span><br><span class="line">				&lt;value&gt;classpath:jms.properties&lt;/value&gt;</span><br><span class="line">			&lt;/list&gt;</span><br><span class="line">		&lt;/property&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line">        &lt;bean id=<span class="string">"propertyConfigurer2"</span></span><br><span class="line">		<span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span><br><span class="line">		&lt;property name=<span class="string">"ignoreUnresolvablePlaceholders"</span> value=<span class="string">"true"</span>/&gt;</span><br><span class="line">		&lt;property name=<span class="string">"locations"</span>&gt;</span><br><span class="line">		</span><br><span class="line">		 &lt;list&gt;</span><br><span class="line">            &lt;value&gt;</span><br><span class="line">                classpath:ldap.properties</span><br><span class="line">            &lt;/value&gt;</span><br><span class="line">        &lt;/list&gt;</span><br><span class="line">		&lt;/property&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>这样多个实例就会相安无事，很好，问题解决了，可是这是为什么呢？我们一定要得知真相。</p>
<p>PropertyPlaceholderConfigurer：PlaceholderConfigurerSupport的子类，它解析本地属性或者系统属性或者环境变量定义的占位符(以${}描述)。分析下这个类</p>
<h3 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h3><p>PropertyPlaceholderConfigurer是个bean工厂后置处理器的实现，也就是 BeanFactoryPostProcessor接口的一个实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyPlaceholderConfigurer</span> <span class="keyword">extends</span> <span class="title">PlaceholderConfigurerSupport</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PlaceholderConfigurerSupport</span> <span class="keyword">extends</span> <span class="title">PropertyResourceConfigurer</span></span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">BeanNameAware</span>, <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyResourceConfigurer</span> <span class="keyword">extends</span> <span class="title">PropertiesLoaderSupport</span></span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span>, <span class="title">PriorityOrdered</span> </span>&#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesLoaderSupport</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<p>实现该接口，可以在spring的bean创建之前，修改bean的定义属性。也就是说，Spring允许BeanFactoryPostProcessor在容器实例化任何其它bean之前读取配置元数据，并可以根据需要进行修改，例如可以把bean的scope从singleton改为prototype，也可以把property的值给修改掉。可以同时配置多个BeanFactoryPostProcessor，并通过设置’order’属性来控制各个BeanFactoryPostProcessor的执行次序。<br>注意：BeanFactoryPostProcessor是在spring容器加载了bean的定义文件之后，在bean实例化之前执行的。接口方法的入参是ConfigurrableListableBeanFactory，使用该参数，可以获取到相关bean的定义信息。</p>
<p>我们来看看到底是在什么时候执行的</p>
<p>继续回到Spring初始化的方法refresh()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">			<span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">			prepareRefresh();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">			prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">				postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">				invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">				registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Initialize message source for this context.</span></span><br><span class="line">				initMessageSource();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">				initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">				onRefresh();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">				registerListeners();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">				finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">				finishRefresh();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">				logger.warn(<span class="string">"Exception encountered during context initialization - cancelling refresh attempt"</span>, ex);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">				destroyBeans();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Reset 'active' flag.</span></span><br><span class="line">				cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Propagate exception to caller.</span></span><br><span class="line">				<span class="keyword">throw</span> ex;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>关于BeanFactoryProcessor的调用 就在                        invokeBeanFactoryPostProcessors(beanFactory);</p>
<p>我们来看下这个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">		PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>其中getBeanFactoryPostProcessors()很明显是获取BeanFatoryPostProcessor实例类集合的方法，默认情况下，到这个节点为止，这个方法的到的结果应该是空的。</p>
<p>发现调用的是PostProcessorRegistrationDelegate的invokeBeanFactoryPostProcessors方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Invoke BeanDefinitionRegistryPostProcessors first, if any.</span></span><br><span class="line">		Set&lt;String&gt; processedBeans = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class="line">			BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">			List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="keyword">new</span> LinkedList&lt;BeanFactoryPostProcessor&gt;();</span><br><span class="line">			List&lt;BeanDefinitionRegistryPostProcessor&gt; registryPostProcessors =</span><br><span class="line">					<span class="keyword">new</span> LinkedList&lt;BeanDefinitionRegistryPostProcessor&gt;();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class="line">				<span class="keyword">if</span> (postProcessor <span class="keyword">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line">					BeanDefinitionRegistryPostProcessor registryPostProcessor =</span><br><span class="line">							(BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class="line">					registryPostProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">					registryPostProcessors.add(registryPostProcessor);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					regularPostProcessors.add(postProcessor);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">			<span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line">			<span class="comment">// Separate between BeanDefinitionRegistryPostProcessors that implement</span></span><br><span class="line">			<span class="comment">// PriorityOrdered, Ordered, and the rest.</span></span><br><span class="line">			String[] postProcessorNames =</span><br><span class="line">					beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">			List&lt;BeanDefinitionRegistryPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;BeanDefinitionRegistryPostProcessor&gt;();</span><br><span class="line">			<span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">				<span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">					priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">					processedBeans.add(ppName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			OrderComparator.sort(priorityOrderedPostProcessors);</span><br><span class="line">			registryPostProcessors.addAll(priorityOrderedPostProcessors);</span><br><span class="line">			invokeBeanDefinitionRegistryPostProcessors(priorityOrderedPostProcessors, registry);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.</span></span><br><span class="line">			postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">			List&lt;BeanDefinitionRegistryPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;BeanDefinitionRegistryPostProcessor&gt;();</span><br><span class="line">			<span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">					orderedPostProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">					processedBeans.add(ppName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			OrderComparator.sort(orderedPostProcessors);</span><br><span class="line">			registryPostProcessors.addAll(orderedPostProcessors);</span><br><span class="line">			invokeBeanDefinitionRegistryPostProcessors(orderedPostProcessors, registry);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.</span></span><br><span class="line">			<span class="keyword">boolean</span> reiterate = <span class="keyword">true</span>;</span><br><span class="line">			<span class="keyword">while</span> (reiterate) &#123;</span><br><span class="line">				reiterate = <span class="keyword">false</span>;</span><br><span class="line">				postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">				<span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">					<span class="keyword">if</span> (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">						BeanDefinitionRegistryPostProcessor pp = beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class);</span><br><span class="line">						registryPostProcessors.add(pp);</span><br><span class="line">						processedBeans.add(ppName);</span><br><span class="line">						pp.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">						reiterate = <span class="keyword">true</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Now, invoke the postProcessBeanFactory callback of all processors handled so far.</span></span><br><span class="line">			invokeBeanFactoryPostProcessors(registryPostProcessors, beanFactory);</span><br><span class="line">			invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Invoke factory processors registered with the context instance.</span></span><br><span class="line">			invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">		<span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line">		String[] postProcessorNames =</span><br><span class="line">				beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,</span></span><br><span class="line">		<span class="comment">// Ordered, and the rest.</span></span><br><span class="line">		List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;BeanFactoryPostProcessor&gt;();</span><br><span class="line">		List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		<span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">			<span class="keyword">if</span> (processedBeans.contains(ppName)) &#123;</span><br><span class="line">				<span class="comment">// skip - already processed in first phase above</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">				priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">				orderedPostProcessorNames.add(ppName);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">		OrderComparator.sort(priorityOrderedPostProcessors);</span><br><span class="line">		invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span></span><br><span class="line">		List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;BeanFactoryPostProcessor&gt;();</span><br><span class="line">		<span class="keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line">			orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">		&#125;</span><br><span class="line">		OrderComparator.sort(orderedPostProcessors);</span><br><span class="line">		invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Finally, invoke all other BeanFactoryPostProcessors.</span></span><br><span class="line">		List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;BeanFactoryPostProcessor&gt;();</span><br><span class="line">		<span class="keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">			nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">		&#125;</span><br><span class="line">		invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法又是巨长，我们来简单说一下这个方法都做了什么。</p>
<p>1.如果beanFactory是BeanDefinitionRegistry类型的（默认情况下是DefaultListableBeanFactory，实现了BeanDefinitionRegistry接口），</p>
<p>1.1定义两个List集合 ，一个打算用来存放regularBeanFactoryProcessor，一个存放register集合。</p>
<p>1.2遍历传进来的beanFactoryPostProcessors,如果是BeanDefinitionRegistryPostProcessor类型，则执行他的postProcessBeanDefinitionRegistry方法，然后加入register。如果不是，则加入regular。</p>
<p>1.3通过                beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);</p>
<p>得到所有注册到Spring容器中BeanDefinitionRegistryPostProcessor类型的Bean的beanName。</p>
<p>1.4新建一个名为priorityOrderedPostProcessors的List集合，用来存放实现了PriorityOrdered接口的BeanDefinitionRegistryPostProcessor实现类，并且也把这些实现类的name存入processedBeans这个HashSet中，使用HashSet，不能重复元素。</p>
<p>1.5排序后，把这个priorityOrdered的list集合加入到register中，然后对priorityOrdered执行invokeBeanDefinitionRegistryPostProcessors方法，即执行priorityOrdered的postProcessBeanDefinitionRegistry方法。</p>
<p>1.6新建一个名为orderedPostProcessors的集合来存放实现了Order接口的实现类，并且要剔除实现了PriorityOrdered接口的那部分，也把符合条件的实现类的名字加入processedBeans</p>
<p>1.7排序后，。。。和1.5一样</p>
<p>1.8，对哪些没有实现Order接口也没有实现PriorityOrdered的实现类（即不需要排序的类）调用他们的postProcessBeanDefinitionRegistry方法。</p>
<p>1.9最后对register和regular集合都调用共同要调用的方法，postProcessBeanFactory方法，这样就完成了BeanDefinitionRegistryPostProcessor这一类型BeanFactoryProcessor的调用。</p>
<p>2.如果不是BeanDefinitionRegistry类型的BeanFactory，那么就先直接遍历调用beanFactoryPostProcessors集合元素的postProcessBeanDefinitionRegistry</p>
<p>3.来到了非BeanDefinitionRegistryPostProcessor类型的BeanFactoryProcessor的调用，思路和1中的思路完全一样，就不啰嗦了。</p>
<p>我们分析了Spring对BeanFactoryProcessor实现类的调用节点以及调用的方法，那我们现在就来分析下PropertyPlaceholderConfigurer。</p>
<h3 id="PropertyPlaceholderConfigurer"><a href="#PropertyPlaceholderConfigurer" class="headerlink" title="PropertyPlaceholderConfigurer"></a>PropertyPlaceholderConfigurer</h3><p>我们第一时间肯定是要寻找他的postProcessBeanFactory方法，我们没有在该类中找到，很明显,肯定是他的祖先类实现了，而自己并没有去重写这个方法。</p>
<p>PropertyResourceConfigurer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//load Properties</span></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">          还记得我们处理Properties</span></span><br><span class="line"><span class="comment">          InputStream resource </span></span><br><span class="line"><span class="comment">          props.load(resource);</span></span><br><span class="line"><span class="comment">          </span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">          <span class="comment">//就是为了得到可以直接使用prop.getProperty();的Properties</span></span><br><span class="line">			Properties mergedProps = mergeProperties();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Convert the merged properties, if necessary.</span></span><br><span class="line">			convertProperties(mergedProps);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Let the subclass process the properties.</span></span><br><span class="line">			processProperties(beanFactory, mergedProps);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanInitializationException(<span class="string">"Could not load properties"</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>替换${key} 为配置文件中相应的value，配置文件可以是.xml也可以是.properties</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processProperties</span><span class="params">(ConfigurableListableBeanFactory beanFactoryToProcess, Properties props)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">	StringValueResolver valueResolver = <span class="keyword">new</span> PlaceholderResolvingStringValueResolver(props);</span><br><span class="line">	doProcessProperties(beanFactoryToProcess, valueResolver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>深入这个方法了解源码之后，发现其实并不难，但是还是比较繁琐的。</p>
<p>我就讲下思路吧，有兴趣的可以深入源码了解。</p>
<p>因为beanFactory是入参,所以我们可以很容易的得到所有注册好的Bean,遍历Spring中所有的bean，除开自己以外所有的bean，然后查看每一个bean的属性是否有${….}这种结构，如果有就替换，没有就返回原值，不做处理。这样做是不是会很耗时，我想确实挺耗时的吧，但是好在这是在Spring初始化的时候就完成了，而不是在程序上线运转后在动态的加载，否则真的是我的乖乖，Spring的初始化过程做了很多工作，必然是一个很耗时的过程，但是好在他是在项目初始化的时候完成的，而我们后续的所有动态操作都可以在Spring这个巨大的容器中找到相应的信息来帮助我们处理。</p>
<p>看到这里，你知道为什么一开始会报错了吗？</p>
<p>原因很简单，因为我们得到的是所有的Bean，但是我们目前这个PropertyPlaceholderConfigurer实例并不能解析所有的${}占位符结构，因为这个实例并不包含所有的配置文件呀，有些占位符里的key是在另一个实例中，所以自然解析不到。</p>
<p>那么为什么对每一个实例使用了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name=<span class="string">"ignoreUnresolvablePlaceholders"</span> value=<span class="string">"true"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>就可以了呢？</p>
<p>这个配置其实就是忽略到不能解析的占位符，就是说如果我这个实例没法处理我就不处理了，反正还会有下一个实例来处理这个占位符。那么相应的源码在哪呢？</p>
<p>真正解析占位符的是在PropertyPlaceholderHelper中，初始化这个类的时候就在构造方法里把ignoreUnresolvablePlaceholders注入了，默认这个属性是false，也就是一定要解析，解析不了就要抛异常。</p>
<p>我们看看解析的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">parseStringValue</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			String strVal, PlaceholderResolver placeholderResolver, Set&lt;String&gt; visitedPlaceholders)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		StringBuilder result = <span class="keyword">new</span> StringBuilder(strVal);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> startIndex = strVal.indexOf(<span class="keyword">this</span>.placeholderPrefix);</span><br><span class="line">		<span class="keyword">while</span> (startIndex != -<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> endIndex = findPlaceholderEndIndex(result, startIndex);</span><br><span class="line">			<span class="keyword">if</span> (endIndex != -<span class="number">1</span>) &#123;</span><br><span class="line">				String placeholder = result.substring(startIndex + <span class="keyword">this</span>.placeholderPrefix.length(), endIndex);</span><br><span class="line">				String originalPlaceholder = placeholder;</span><br><span class="line">				<span class="keyword">if</span> (!visitedPlaceholders.add(originalPlaceholder)) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">							<span class="string">"Circular placeholder reference '"</span> + originalPlaceholder + <span class="string">"' in property definitions"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// Recursive invocation, parsing placeholders contained in the placeholder key.</span></span><br><span class="line">				placeholder = parseStringValue(placeholder, placeholderResolver, visitedPlaceholders);</span><br><span class="line">				<span class="comment">// Now obtain the value for the fully resolved key...</span></span><br><span class="line">				String propVal = placeholderResolver.resolvePlaceholder(placeholder);</span><br><span class="line">				<span class="keyword">if</span> (propVal == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.valueSeparator != <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">int</span> separatorIndex = placeholder.indexOf(<span class="keyword">this</span>.valueSeparator);</span><br><span class="line">					<span class="keyword">if</span> (separatorIndex != -<span class="number">1</span>) &#123;</span><br><span class="line">						String actualPlaceholder = placeholder.substring(<span class="number">0</span>, separatorIndex);</span><br><span class="line">						String defaultValue = placeholder.substring(separatorIndex + <span class="keyword">this</span>.valueSeparator.length());</span><br><span class="line">						propVal = placeholderResolver.resolvePlaceholder(actualPlaceholder);</span><br><span class="line">						<span class="keyword">if</span> (propVal == <span class="keyword">null</span>) &#123;</span><br><span class="line">							propVal = defaultValue;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (propVal != <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="comment">// Recursive invocation, parsing placeholders contained in the</span></span><br><span class="line">					<span class="comment">// previously resolved placeholder value.</span></span><br><span class="line">					propVal = parseStringValue(propVal, placeholderResolver, visitedPlaceholders);</span><br><span class="line">					result.replace(startIndex, endIndex + <span class="keyword">this</span>.placeholderSuffix.length(), propVal);</span><br><span class="line">					<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">						logger.trace(<span class="string">"Resolved placeholder '"</span> + placeholder + <span class="string">"'"</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					startIndex = result.indexOf(<span class="keyword">this</span>.placeholderPrefix, startIndex + propVal.length());</span><br><span class="line">				&#125;</span><br><span class="line">              <span class="comment">//*********处理不能解析的情况</span></span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.ignoreUnresolvablePlaceholders) &#123;</span><br><span class="line">					<span class="comment">// Proceed with unprocessed value.</span></span><br><span class="line">					startIndex = result.indexOf(<span class="keyword">this</span>.placeholderPrefix, endIndex + <span class="keyword">this</span>.placeholderSuffix.length());</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Could not resolve placeholder '"</span> +</span><br><span class="line">							placeholder + <span class="string">"'"</span> + <span class="string">" in string value \""</span> + strVal + <span class="string">"\""</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				visitedPlaceholders.remove(originalPlaceholder);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				startIndex = -<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> result.toString();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到当不能处理的时候，如果ignoreUnresolvablePlaceholders为true，就不会抛出异常，而是返回占位符，就是他还是占位符形式，给到下一个能解析他的PropertyPlaceholderConfigurer来解析他。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2018/01/11/Spring配置文件解析(一)/" data-id="cjc99g1dc000040bz8pkzh5td" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post---SpringMVC请求处理之对方法参数的处理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/08/--SpringMVC请求处理之对方法参数的处理/" class="article-date">
  <time datetime="2018-01-07T17:58:41.445Z" itemprop="datePublished">2018-01-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SpringMVC/">SpringMVC</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/08/--SpringMVC请求处理之对方法参数的处理/">SpringMVC请求处理之对方法参数的处理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>讲完了DispatchServlet（也可以说是SpringMVC框架）的初始化之后，我们再接着看DispatchServlet处理请求的原理，也可以说是SpringMVC处理请求的原理。今天就先来看看SpringMVC对方法参数的处理。</p>
<p>我们先给出一个测试的类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wangcc.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.wangcc.entity.Player;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="comment">// 不是以/开头的，springmvc会自动帮你添加/</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">	<span class="meta">@RequestMapping</span>(<span class="string">"testRb"</span>)</span><br><span class="line">	<span class="meta">@ResponseBody</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Player <span class="title">testRb</span><span class="params">(@RequestBody Player player)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> player;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RequestMapping</span>(<span class="string">"testEntity"</span>)</span><br><span class="line">	<span class="meta">@ResponseBody</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Player <span class="title">testEntity</span><span class="params">(Player player)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> player;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RequestMapping</span>(<span class="string">"testEntityWithRp"</span>)</span><br><span class="line">	<span class="meta">@ResponseBody</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Player <span class="title">testEntityWithRp</span><span class="params">(@RequestParam Player player)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> player;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RequestMapping</span>(<span class="string">"/testDate"</span>)</span><br><span class="line">	<span class="meta">@ResponseBody</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Date <span class="title">testDate</span><span class="params">(Date date)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> date;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们之前已经讲过，对带有@Controller注解的Bean以及其方法上有@RequestMapping注解的对应的url请求的处理，调用的是RequestMappingHandlerAdapter的invokeHandleMethod方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ModelAndView <span class="title">invokeHandleMethod</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">			HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">		ServletWebRequest webRequest = <span class="keyword">new</span> ServletWebRequest(request, response);</span><br><span class="line"></span><br><span class="line">		WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);</span><br><span class="line">		ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);</span><br><span class="line">		ServletInvocableHandlerMethod requestMappingMethod = createRequestMappingMethod(handlerMethod, binderFactory);</span><br><span class="line"></span><br><span class="line">		ModelAndViewContainer mavContainer = <span class="keyword">new</span> ModelAndViewContainer();</span><br><span class="line">		mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));</span><br><span class="line">		modelFactory.initModel(webRequest, mavContainer, requestMappingMethod);</span><br><span class="line">		mavContainer.setIgnoreDefaultModelOnRedirect(<span class="keyword">this</span>.ignoreDefaultModelOnRedirect);</span><br><span class="line"></span><br><span class="line">		AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);</span><br><span class="line">		asyncWebRequest.setTimeout(<span class="keyword">this</span>.asyncRequestTimeout);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">final</span> WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">		asyncManager.setTaskExecutor(<span class="keyword">this</span>.taskExecutor);</span><br><span class="line">		asyncManager.setAsyncWebRequest(asyncWebRequest);</span><br><span class="line">		asyncManager.registerCallableInterceptors(<span class="keyword">this</span>.callableInterceptors);</span><br><span class="line">		asyncManager.registerDeferredResultInterceptors(<span class="keyword">this</span>.deferredResultInterceptors);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (asyncManager.hasConcurrentResult()) &#123;</span><br><span class="line">			Object result = asyncManager.getConcurrentResult();</span><br><span class="line">			mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[<span class="number">0</span>];</span><br><span class="line">			asyncManager.clearConcurrentResult();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">"Found concurrent result value ["</span> + result + <span class="string">"]"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			requestMappingMethod = requestMappingMethod.wrapConcurrentResult(result);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		requestMappingMethod.invokeAndHandle(webRequest, mavContainer);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> getModelAndView(mavContainer, modelFactory, webRequest);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>就是通过这个方法得到了ModelAndView实例，所以当完整的走完这个方法之后，也就对请求的处理的主干部分走完了。今天我们就来看这个方法的一小部分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ServletInvocableHandlerMethod requestMappingMethod = createRequestMappingMethod(handlerMethod, binderFactory);</span><br><span class="line">	requestMappingMethod.invokeAndHandle(webRequest, mavContainer);</span><br></pre></td></tr></table></figure>
<h3 id="SpringMVC处理方法参数"><a href="#SpringMVC处理方法参数" class="headerlink" title="SpringMVC处理方法参数"></a>SpringMVC处理方法参数</h3><ul>
<li>我们先看下上面ServletInvocableHandlerMethod实例的获取</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ServletInvocableHandlerMethod requestMappingMethod = createRequestMappingMethod(handlerMethod, binderFactory);</span><br><span class="line">	<span class="function"><span class="keyword">private</span> ServletInvocableHandlerMethod <span class="title">createRequestMappingMethod</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			HandlerMethod handlerMethod, WebDataBinderFactory binderFactory)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		ServletInvocableHandlerMethod requestMethod;</span><br><span class="line">		requestMethod = <span class="keyword">new</span> ServletInvocableHandlerMethod(handlerMethod);</span><br><span class="line">		requestMethod.setHandlerMethodArgumentResolvers(<span class="keyword">this</span>.argumentResolvers);</span><br><span class="line">		requestMethod.setHandlerMethodReturnValueHandlers(<span class="keyword">this</span>.returnValueHandlers);</span><br><span class="line">		requestMethod.setDataBinderFactory(binderFactory);</span><br><span class="line">		requestMethod.setParameterNameDiscoverer(<span class="keyword">this</span>.parameterNameDiscoverer);</span><br><span class="line">		<span class="keyword">return</span> requestMethod;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>1.使用我们在初始化RequestMappingHandlerMapping时注册到AbstractHandlerMapping的urlMap时封装的HandlerMethod实例handlerMethod为参数构建一个ServletInvocableHandlerMethod实例。</p>
<p>2.分别以RequestMappingHandlerAdapter的argumentResolvers和returnValueHandlers属性注入到requestMethod的argumentResolvers属性和returnValueHandlers属性中。</p>
<p>这里需要讲解下RequestMappingHandlerAdapter的argumentResolvers和returnValueHandlers怎么得到的以及内容是什么。</p>
<p>我们在讲解RequestMappingHandlerMapping的时候提到了InitializingBean接口，而我们发现RequestMappingHandlerAdapter也实现了这个接口，那么我们就知道了在初始化这个类的时候是需要执行他的afterPropertiesSet方法,而这两个属性的注入就是在这个方法里完成的。</p>
<p><strong>afterPropertiesSet</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Do this first, it may add ResponseBody advice beans</span></span><br><span class="line">	initControllerAdviceCache();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.argumentResolvers == <span class="keyword">null</span>) &#123;</span><br><span class="line">		List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultArgumentResolvers();</span><br><span class="line">		<span class="keyword">this</span>.argumentResolvers = <span class="keyword">new</span> HandlerMethodArgumentResolverComposite().addResolvers(resolvers);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.initBinderArgumentResolvers == <span class="keyword">null</span>) &#123;</span><br><span class="line">		List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultInitBinderArgumentResolvers();</span><br><span class="line">		<span class="keyword">this</span>.initBinderArgumentResolvers = <span class="keyword">new</span> HandlerMethodArgumentResolverComposite().addResolvers(resolvers);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.returnValueHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">		List&lt;HandlerMethodReturnValueHandler&gt; handlers = getDefaultReturnValueHandlers();</span><br><span class="line">		<span class="keyword">this</span>.returnValueHandlers = <span class="keyword">new</span> HandlerMethodReturnValueHandlerComposite().addHandlers(handlers);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先通过getDefaultArgumentResolvers得到一个HandlerMethodArgumentResolver集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;HandlerMethodArgumentResolver&gt; <span class="title">getDefaultArgumentResolvers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		List&lt;HandlerMethodArgumentResolver&gt; resolvers = <span class="keyword">new</span> ArrayList&lt;HandlerMethodArgumentResolver&gt;();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Annotation-based argument resolution</span></span><br><span class="line">		resolvers.add(<span class="keyword">new</span> RequestParamMethodArgumentResolver(getBeanFactory(), <span class="keyword">false</span>));</span><br><span class="line">		resolvers.add(<span class="keyword">new</span> RequestParamMapMethodArgumentResolver());</span><br><span class="line">		resolvers.add(<span class="keyword">new</span> PathVariableMethodArgumentResolver());</span><br><span class="line">		resolvers.add(<span class="keyword">new</span> PathVariableMapMethodArgumentResolver());</span><br><span class="line">		resolvers.add(<span class="keyword">new</span> MatrixVariableMethodArgumentResolver());</span><br><span class="line">		resolvers.add(<span class="keyword">new</span> MatrixVariableMapMethodArgumentResolver());</span><br><span class="line">		resolvers.add(<span class="keyword">new</span> ServletModelAttributeMethodProcessor(<span class="keyword">false</span>));</span><br><span class="line">		resolvers.add(<span class="keyword">new</span> RequestResponseBodyMethodProcessor(getMessageConverters()));</span><br><span class="line">		resolvers.add(<span class="keyword">new</span> RequestPartMethodArgumentResolver(getMessageConverters()));</span><br><span class="line">		resolvers.add(<span class="keyword">new</span> RequestHeaderMethodArgumentResolver(getBeanFactory()));</span><br><span class="line">		resolvers.add(<span class="keyword">new</span> RequestHeaderMapMethodArgumentResolver());</span><br><span class="line">		resolvers.add(<span class="keyword">new</span> ServletCookieValueMethodArgumentResolver(getBeanFactory()));</span><br><span class="line">		resolvers.add(<span class="keyword">new</span> ExpressionValueMethodArgumentResolver(getBeanFactory()));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Type-based argument resolution</span></span><br><span class="line">		resolvers.add(<span class="keyword">new</span> ServletRequestMethodArgumentResolver());</span><br><span class="line">		resolvers.add(<span class="keyword">new</span> ServletResponseMethodArgumentResolver());</span><br><span class="line">		resolvers.add(<span class="keyword">new</span> HttpEntityMethodProcessor(getMessageConverters()));</span><br><span class="line">		resolvers.add(<span class="keyword">new</span> RedirectAttributesMethodArgumentResolver());</span><br><span class="line">		resolvers.add(<span class="keyword">new</span> ModelMethodProcessor());</span><br><span class="line">		resolvers.add(<span class="keyword">new</span> MapMethodProcessor());</span><br><span class="line">		resolvers.add(<span class="keyword">new</span> ErrorsMethodArgumentResolver());</span><br><span class="line">		resolvers.add(<span class="keyword">new</span> SessionStatusMethodArgumentResolver());</span><br><span class="line">		resolvers.add(<span class="keyword">new</span> UriComponentsBuilderMethodArgumentResolver());</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Custom arguments</span></span><br><span class="line">		<span class="keyword">if</span> (getCustomArgumentResolvers() != <span class="keyword">null</span>) &#123;</span><br><span class="line">			resolvers.addAll(getCustomArgumentResolvers());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Catch-all</span></span><br><span class="line">		resolvers.add(<span class="keyword">new</span> RequestParamMethodArgumentResolver(getBeanFactory(), <span class="keyword">true</span>));</span><br><span class="line">		resolvers.add(<span class="keyword">new</span> ServletModelAttributeMethodProcessor(<span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> resolvers;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>然后将这个集合放入到HandlerMethodArgumentResolverComposite实例中。然后把这个实例赋给argumentResolvers属性。</p>
<p>那么returnValueHandlers属性同理。</p>
<ul>
<li><p>接着分析requestMappingMethod.invokeAndHandle(webRequest, mavContainer);</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeAndHandle</span><span class="params">(ServletWebRequest webRequest,</span></span></span><br><span class="line"><span class="function"><span class="params">			ModelAndViewContainer mavContainer, Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">		Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);</span><br><span class="line">		setResponseStatus(webRequest);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (returnValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (isRequestNotModified(webRequest) || hasResponseStatus() || mavContainer.isRequestHandled()) &#123;</span><br><span class="line">				mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.responseReason)) &#123;</span><br><span class="line">			mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		mavContainer.setRequestHandled(<span class="keyword">false</span>);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">this</span>.returnValueHandlers.handleReturnValue(</span><br><span class="line">					returnValue, getReturnValueType(returnValue), mavContainer, webRequest);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(getReturnValueHandlingErrorMessage(<span class="string">"Error handling return value"</span>, returnValue), ex);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>我们看下第一行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);</span><br></pre></td></tr></table></figure>
<p>这一行就已经得到了这个方法的返回值了。我们进入这个方法看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invokeForRequest</span><span class="params">(NativeWebRequest request, ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">		Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">	Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);</span><br><span class="line">	<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">		StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"Invoking ["</span>);</span><br><span class="line">		sb.append(getBeanType().getSimpleName()).append(<span class="string">"."</span>);</span><br><span class="line">		sb.append(getMethod().getName()).append(<span class="string">"] method with arguments "</span>);</span><br><span class="line">		sb.append(Arrays.asList(args));</span><br><span class="line">		logger.trace(sb.toString());</span><br><span class="line">	&#125;</span><br><span class="line">	Object returnValue = doInvoke(args);</span><br><span class="line">	<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">		logger.trace(<span class="string">"Method ["</span> + getMethod().getName() + <span class="string">"] returned ["</span> + returnValue + <span class="string">"]"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> returnValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
<p>我们发现第一行就是对方法参数的处理，嗯，终于找到我们今天要重点讲解的地方了。</p>
<p>​</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object[] getMethodArgumentValues(NativeWebRequest request, ModelAndViewContainer mavContainer,</span><br><span class="line">		Object... providedArgs) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">	MethodParameter[] parameters = getMethodParameters();</span><br><span class="line">	Object[] args = <span class="keyword">new</span> Object[parameters.length];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameters.length; i++) &#123;</span><br><span class="line">		MethodParameter parameter = parameters[i];</span><br><span class="line">		parameter.initParameterNameDiscovery(<span class="keyword">this</span>.parameterNameDiscoverer);</span><br><span class="line">		GenericTypeResolver.resolveParameterType(parameter, getBean().getClass());</span><br><span class="line">		args[i] = resolveProvidedArgument(parameter, providedArgs);</span><br><span class="line">		<span class="keyword">if</span> (args[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.argumentResolvers.supportsParameter(parameter)) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				args[i] = <span class="keyword">this</span>.argumentResolvers.resolveArgument(</span><br><span class="line">						parameter, mavContainer, request, <span class="keyword">this</span>.dataBinderFactory);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">					logger.trace(getArgumentResolutionErrorMessage(<span class="string">"Error resolving argument"</span>, i), ex);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">throw</span> ex;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (args[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">			String msg = getArgumentResolutionErrorMessage(<span class="string">"No suitable resolver for argument"</span>, i);</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
<p>1.先通过this.argumentResolvers.supportsParameter(parameter)来找到能处理该方法参数的HandlerMethodArgumentResolver实例。</p>
<p>2.然后通过this.argumentResolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory);来调用HandlerMethodArgumentResolver实例的resolveArgument方法来处理参数。</p>
<p><strong>supportsParameter</strong></p>
<p>HandlerMethodArgumentResolverComposite</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> getArgumentResolver(parameter) != <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> HandlerMethodArgumentResolver <span class="title">getArgumentResolver</span><span class="params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line">		HandlerMethodArgumentResolver result = <span class="keyword">this</span>.argumentResolverCache.get(parameter);</span><br><span class="line">		<span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (HandlerMethodArgumentResolver methodArgumentResolver : <span class="keyword">this</span>.argumentResolvers) &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">					logger.trace(<span class="string">"Testing if argument resolver ["</span> + methodArgumentResolver + <span class="string">"] supports ["</span> +</span><br><span class="line">							parameter.getGenericParameterType() + <span class="string">"]"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (methodArgumentResolver.supportsParameter(parameter)) &#123;</span><br><span class="line">					result = methodArgumentResolver;</span><br><span class="line">					<span class="keyword">this</span>.argumentResolverCache.put(parameter, result);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码不难理解，就是在我们开始讲解的注入的HandlerMethodArgumentResolver集合里面筛选出能够处理参数的实例。</p>
<p>我们以这个方法为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"testRb"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Player <span class="title">testRb</span><span class="params">(@RequestBody Player player)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> player;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相应的实例就是RequestResponseBodyMethodProcessor，我们瞅一眼他的supportsParameter方法就一目了然了。</p>
<h3 id="RequestResponseBodyMethodProcessor"><a href="#RequestResponseBodyMethodProcessor" class="headerlink" title="RequestResponseBodyMethodProcessor"></a>RequestResponseBodyMethodProcessor</h3><p>​</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> parameter.hasParameterAnnotation(RequestBody.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以参数上有@RequestBody注解的都会使用这个实例来处理参数。</p>
</li>
</ul>
<p>接着看看是如何调用resolveArgument方法的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">		NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">	HandlerMethodArgumentResolver resolver = getArgumentResolver(parameter);</span><br><span class="line">	Assert.notNull(resolver, <span class="string">"Unknown parameter type ["</span> + parameter.getParameterType().getName() + <span class="string">"]"</span>);</span><br><span class="line">	<span class="keyword">return</span> resolver.resolveArgument(parameter, mavContainer, webRequest, binderFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以调用的就是RequestResponseBodyMethodProcessor的resolveArgument方法了。</p>
<p><strong>resolveArgument</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">		NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">	Object arg = readWithMessageConverters(webRequest, parameter, parameter.getGenericParameterType());</span><br><span class="line">	String name = Conventions.getVariableNameForParameter(parameter);</span><br><span class="line">	WebDataBinder binder = binderFactory.createBinder(webRequest, arg, name);</span><br><span class="line">	<span class="keyword">if</span> (arg != <span class="keyword">null</span>) &#123;</span><br><span class="line">		validateIfApplicable(binder, parameter);</span><br><span class="line">		<span class="keyword">if</span> (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> MethodArgumentNotValidException(parameter, binder.getBindingResult());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	mavContainer.addAttribute(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult());</span><br><span class="line">	<span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先使用readWithMessageConverters来处理参数</p>
<p><strong>readWithMessageConverters</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">Object <span class="title">readWithMessageConverters</span><span class="params">(NativeWebRequest webRequest, MethodParameter methodParam,</span></span></span><br><span class="line"><span class="function"><span class="params">		Type paramType)</span> <span class="keyword">throws</span> IOException, HttpMediaTypeNotSupportedException </span>&#123;</span><br><span class="line"></span><br><span class="line">	HttpServletRequest servletRequest = webRequest.getNativeRequest(HttpServletRequest.class);</span><br><span class="line">	HttpInputMessage inputMessage = <span class="keyword">new</span> ServletServerHttpRequest(servletRequest);</span><br><span class="line"></span><br><span class="line">	InputStream inputStream = inputMessage.getBody();</span><br><span class="line">	<span class="keyword">if</span> (inputStream == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> handleEmptyBody(methodParam);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (inputStream.markSupported()) &#123;</span><br><span class="line">		inputStream.mark(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (inputStream.read() == -<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> handleEmptyBody(methodParam);</span><br><span class="line">		&#125;</span><br><span class="line">		inputStream.reset();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">final</span> PushbackInputStream pushbackInputStream = <span class="keyword">new</span> PushbackInputStream(inputStream);</span><br><span class="line">		<span class="keyword">int</span> b = pushbackInputStream.read();</span><br><span class="line">		<span class="keyword">if</span> (b == -<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> handleEmptyBody(methodParam);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			pushbackInputStream.unread(b);</span><br><span class="line">		&#125;</span><br><span class="line">		inputMessage = <span class="keyword">new</span> ServletServerHttpRequest(servletRequest) &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> InputStream <span class="title">getBody</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="comment">// Form POST should not get here</span></span><br><span class="line">				<span class="keyword">return</span> pushbackInputStream;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">super</span>.readWithMessageConverters(inputMessage, methodParam, paramType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在对数据做一些封装处理后，最后会调用父类AbstractMessageConverterMethodArgumentResolver的readWithMessageConverters方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">	<span class="keyword">protected</span> &lt;T&gt; <span class="function">Object <span class="title">readWithMessageConverters</span><span class="params">(HttpInputMessage inputMessage,</span></span></span><br><span class="line"><span class="function"><span class="params">			MethodParameter methodParam, Type targetType)</span> <span class="keyword">throws</span> IOException, HttpMediaTypeNotSupportedException </span>&#123;</span><br><span class="line"></span><br><span class="line">		MediaType contentType;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			contentType = inputMessage.getHeaders().getContentType();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (InvalidMediaTypeException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> HttpMediaTypeNotSupportedException(ex.getMessage());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (contentType == <span class="keyword">null</span>) &#123;</span><br><span class="line">			contentType = MediaType.APPLICATION_OCTET_STREAM;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Class&lt;?&gt; contextClass = methodParam.getContainingClass();</span><br><span class="line">		Class&lt;T&gt; targetClass = (Class&lt;T&gt;)</span><br><span class="line">				ResolvableType.forMethodParameter(methodParam, targetType).resolve(Object.class);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (HttpMessageConverter&lt;?&gt; converter : <span class="keyword">this</span>.messageConverters) &#123;</span><br><span class="line">			<span class="keyword">if</span> (converter <span class="keyword">instanceof</span> GenericHttpMessageConverter) &#123;</span><br><span class="line">				GenericHttpMessageConverter&lt;?&gt; genericConverter = (GenericHttpMessageConverter&lt;?&gt;) converter;</span><br><span class="line">				<span class="keyword">if</span> (genericConverter.canRead(targetType, contextClass, contentType)) &#123;</span><br><span class="line">					<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">						logger.debug(<span class="string">"Reading ["</span> + targetType + <span class="string">"] as \""</span> +</span><br><span class="line">								contentType + <span class="string">"\" using ["</span> + converter + <span class="string">"]"</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">return</span> genericConverter.read(targetType, contextClass, inputMessage);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (converter.canRead(targetClass, contentType)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">					logger.debug(<span class="string">"Reading ["</span> + targetClass.getName() + <span class="string">"] as \""</span> +</span><br><span class="line">							contentType + <span class="string">"\" using ["</span> + converter + <span class="string">"]"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> ((HttpMessageConverter&lt;T&gt;) converter).read(targetClass, inputMessage);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> HttpMediaTypeNotSupportedException(contentType, <span class="keyword">this</span>.allSupportedMediaTypes);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这里会在messageConverters集合中选择一个合适的HttpMessageConverter来处理数据，这里的messageConverters就是RequestMappingHandlerAdapter中的属性，该属性的注入具体在SpringMVC配置文件解析(六)中有说明。</p>
<p>而RequestResponseBodyMethodProcessor是在初始化的时候注入messageConverters属性的，回头看getDefaultArgumentResolvers，有一句</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resolvers.add(<span class="keyword">new</span> RequestResponseBodyMethodProcessor(getMessageConverters()));</span><br></pre></td></tr></table></figure>
<p>但是遗憾的是，我们在所有的messageConverters集合中都找不到能够处理这个数据的HttpMessageConverter，其中ByteArrayHttpMessageConverter能处理这种MediaType（使用get方式的<a href="http://localhost:8080/SpringMVC/test/testRb?name=kobe&amp;age=39的MediaType是application/octet-stream），但是他只支持byte类型，而我们这里的参数是Player这种自定义类型。" target="_blank" rel="noopener">http://localhost:8080/SpringMVC/test/testRb?name=kobe&amp;age=39的MediaType是application/octet-stream），但是他只支持byte类型，而我们这里的参数是Player这种自定义类型。</a></p>
<p>没有任何的HttpMessageConverter可以处理，所以就导致了报错，本来按照程序应该是报如下错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public HttpMediaTypeNotSupportedException(MediaType contentType, List&lt;MediaType&gt; supportedMediaTypes) &#123;</span><br><span class="line">	this(contentType, supportedMediaTypes, &quot;Content type &apos;&quot; + contentType + &quot;&apos; not supported&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是实际结果却是http 400 bad request。这个我们需要再看看到底是什么原因。</p>
<p>到这里，就把第一个方法的参数处理过程分析完了。</p>
<p>那么需要如何更改才能使得不报错了，我们可以不使用application/octet-stream这中MediaType来传输数据了，我们只要把他改成application/json,使用json格式来传递输出就可以使用处理Json格式的Convert来处理数据了，而处理完参数之后的操作我们留到以后再分析。</p>
<h3 id="ServletModelAttributeMethodProcessor"><a href="#ServletModelAttributeMethodProcessor" class="headerlink" title="ServletModelAttributeMethodProcessor"></a>ServletModelAttributeMethodProcessor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"testEntity"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Player <span class="title">testEntity</span><span class="params">(Player player)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> player;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们接着看第二个方法，先还是在HandlerMethodArgumentResolverComposite的supportsParameter方法中筛选出适合的HandlerMethodArgumentResolver来处理。</p>
<p>得到的答案是ServletModelAttributeMethodProcessor</p>
<p>他的注册方式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">resolvers.add(<span class="keyword">new</span> ServletModelAttributeMethodProcessor(<span class="keyword">false</span>));</span><br><span class="line">resolvers.add(<span class="keyword">new</span> ServletModelAttributeMethodProcessor(<span class="keyword">true</span>));</span><br></pre></td></tr></table></figure>
<p>我们看看这个类先</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ServletModelAttributeMethodProcessor</span><span class="params">(<span class="keyword">boolean</span> annotationNotRequired)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>(annotationNotRequired);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ModelAttributeMethodProcessor</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ModelAttributeMethodProcessor</span><span class="params">(<span class="keyword">boolean</span> annotationNotRequired)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.annotationNotRequired = annotationNotRequired;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化ServletModelAttributeMethodProcessor时，会调用父类ModelAttributeMethodProcessor的骨构造方法，而且supportsParameter也是在父类中，我们看看这个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (parameter.hasParameterAnnotation(ModelAttribute.class)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.annotationNotRequired) &#123;</span><br><span class="line">		<span class="keyword">return</span> !BeanUtils.isSimpleProperty(parameter.getParameterType());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果参数是有@ModelAttribute注解的就支持，如果没有这个注解，当构造方法的实参是true时，如果Method的参数类型不是简单类型也支持，因为有一个实参为true的ServletModelAttributeMethodProcessor被注册，并且Method的参数类型是Player，不是简单类型，所以符合。</p>
<p>直接看resolveArgument方法，这个方法的实现还是在父类中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">		NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">	String name = ModelFactory.getNameForParameter(parameter);</span><br><span class="line">	Object attribute = (mavContainer.containsAttribute(name) ?</span><br><span class="line">			mavContainer.getModel().get(name) : createAttribute(name, parameter, binderFactory, webRequest));</span><br><span class="line"></span><br><span class="line">	WebDataBinder binder = binderFactory.createBinder(webRequest, attribute, name);</span><br><span class="line">	<span class="keyword">if</span> (binder.getTarget() != <span class="keyword">null</span>) &#123;</span><br><span class="line">		bindRequestParameters(binder, webRequest);</span><br><span class="line">		validateIfApplicable(binder, parameter);</span><br><span class="line">		<span class="keyword">if</span> (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BindException(binder.getBindingResult());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Add resolved attribute and BindingResult at the end of the model</span></span><br><span class="line">	Map&lt;String, Object&gt; bindingResultModel = binder.getBindingResult().getModel();</span><br><span class="line">	mavContainer.removeAttributes(bindingResultModel);</span><br><span class="line">	mavContainer.addAllAttributes(bindingResultModel);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> binder.convertIfNecessary(binder.getTarget(), parameter.getParameterType(), parameter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个过程的具体实现先不分析了，以后有空再细说，主要就是</p>
<p>通过DataBinder实例化了Employee对象，并写入了对应的属性，最后把这个实例对象返回给我们。</p>
<h3 id="RequestParamMethodArgumentResolver"><a href="#RequestParamMethodArgumentResolver" class="headerlink" title="RequestParamMethodArgumentResolver"></a>RequestParamMethodArgumentResolver</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"testEntityWithRp"</span>)</span><br><span class="line">	<span class="meta">@ResponseBody</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Player <span class="title">testEntityWithRp</span><span class="params">(@RequestParam Player player)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> player;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>还是一样，通过筛选，得到了对应的HandlerMethodArgumentResolver是RequestParamMethodArgumentResolver,对应的注册代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">resolvers.add(<span class="keyword">new</span> RequestParamMethodArgumentResolver(getBeanFactory(), <span class="keyword">false</span>));</span><br><span class="line">resolvers.add(<span class="keyword">new</span> RequestParamMethodArgumentResolver(getBeanFactory(), <span class="keyword">true</span>));</span><br></pre></td></tr></table></figure>
<p>看看他的构造方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public RequestParamMethodArgumentResolver(ConfigurableBeanFactory beanFactory, boolean useDefaultResolution) &#123;</span><br><span class="line">	super(beanFactory);</span><br><span class="line">	this.useDefaultResolution = useDefaultResolution;</span><br><span class="line">&#125;</span><br><span class="line">	public AbstractNamedValueMethodArgumentResolver(ConfigurableBeanFactory beanFactory) &#123;</span><br><span class="line">	this.configurableBeanFactory = beanFactory;</span><br><span class="line">	this.expressionContext = (beanFactory != null ? new BeanExpressionContext(beanFactory, new RequestScope()) : null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实例化的时候调用了父类AbstractNamedValueMethodArgumentResolver的构造方法。</p>
<p>supportsParameter方法在本类中实现，resolveArgument在父类中实现。</p>
<p>先看supportsParameter</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line">	Class&lt;?&gt; paramType = parameter.getParameterType();</span><br><span class="line">	<span class="keyword">if</span> (parameter.hasParameterAnnotation(RequestParam.class)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (Map.class.isAssignableFrom(paramType)) &#123;</span><br><span class="line">			String paramName = parameter.getParameterAnnotation(RequestParam.class).value();</span><br><span class="line">			<span class="keyword">return</span> StringUtils.hasText(paramName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (parameter.hasParameterAnnotation(RequestPart.class)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (MultipartFile.class.equals(paramType) || <span class="string">"javax.servlet.http.Part"</span>.equals(paramType.getName())) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.useDefaultResolution) &#123;</span><br><span class="line">			<span class="keyword">return</span> BeanUtils.isSimpleProperty(paramType);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当Method参数有@RequestParam注解时，如果此时参数实现了Map接口的时候，@RequestParam注解需要具有value属性，否则不支持，如果有@RequestPart注解，不支持，如果参数是简单类型，支持。如果是MultipartFile类型，且是javax.servlet.http.Part，支持。</p>
<p>显然我们这个方法符合这个要求。我们接着看resolveArgument</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">			NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">		Class&lt;?&gt; paramType = parameter.getParameterType();</span><br><span class="line">		NamedValueInfo namedValueInfo = getNamedValueInfo(parameter);</span><br><span class="line"></span><br><span class="line">		Object arg = resolveName(namedValueInfo.name, parameter, webRequest);</span><br><span class="line">		<span class="keyword">if</span> (arg == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (namedValueInfo.defaultValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">				arg = resolveDefaultValue(namedValueInfo.defaultValue);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (namedValueInfo.required &amp;&amp; !parameter.getParameterType().getName().equals(<span class="string">"java.util.Optional"</span>)) &#123;</span><br><span class="line">				handleMissingValue(namedValueInfo.name, parameter);</span><br><span class="line">			&#125;</span><br><span class="line">			arg = handleNullValue(namedValueInfo.name, arg, paramType);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">""</span>.equals(arg) &amp;&amp; namedValueInfo.defaultValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">			arg = resolveDefaultValue(namedValueInfo.defaultValue);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (binderFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">			WebDataBinder binder = binderFactory.createBinder(webRequest, <span class="keyword">null</span>, namedValueInfo.name);</span><br><span class="line">			arg = binder.convertIfNecessary(arg, paramType, parameter);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		handleResolvedValue(arg, namedValueInfo.name, parameter, mavContainer, webRequest);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> arg;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>仔细阅读源码，你会发现在处理参数的时候会使用request.getParameter(参数名)即request.getParameter(“player”)得到，很明显我们的参数传的是name=1&amp;age=3。因此得到null，RequestParamMethodArgumentResolver处理missing value会触发MissingServletRequestParameterException异常。</p>
<p>那需要如何处理呢，很简单，去掉@RequestParam注解就好了，这样就给方法2一样了。</p>
<h3 id="InitBinder注解"><a href="#InitBinder注解" class="headerlink" title="@InitBinder注解"></a>@InitBinder注解</h3><p>我们继续看方法四</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/testDate"</span>)</span><br><span class="line">	<span class="meta">@ResponseBody</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Date <span class="title">testDate</span><span class="params">(Date date)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> date;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>我们用这样的链接<a href="http://localhost:8080/SpringMVC/test/testDate?date=2018-01-07去调用，会返回错误，400" target="_blank" rel="noopener">http://localhost:8080/SpringMVC/test/testDate?date=2018-01-07去调用，会返回错误，400</a> bad request。为什么呢？来分析一下。</p>
<p>上面我们分析过RequestParamMethodArgumentResolver和ServletModelAttributeMethodProcessor,他们一个支持简单类型一个支持非简单类型，那么这里的Date类型到底是简单类型还是非简单类型呢，看下BeanUtils.isSimpleProperty(paramType);的源码就知道了，他属于简单类型，所以使用的是RequestParamMethodArgumentResolver。这时我们使用request.getParameter(“date”)得到了日期字符串，到这里还是一切正常的，但是后面的使用DataBinder找到合适的属性编辑器进行类型转换时，最终找到java.util.Date对象的构造函数 public Date(String s)，而由于我们传递的格式不是标准的UTC时间格式，因此最终触发了IllegalArgumentException异常。</p>
<p>所以要解决这个问题的方法最简单就是把日期格式设置为标准的UTC时间格式，但是这样并不符合我们的日常习惯，我们肯定是想能够使用请求中的那种日期格式的，那我们能怎么办呢。其实要实现这个功能并不难。在TestController中添加如下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@InitBinder</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initBinder</span><span class="params">(WebDataBinder binder)</span> </span>&#123;</span><br><span class="line">  SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">  binder.registerCustomEditor(Date.class, <span class="keyword">new</span> CustomDateEditor(dateFormat, <span class="keyword">false</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是的只要添加这几行代码就可以了。</p>
<p>那到底是为什么呢？<br>@InitBinder注解在实例化ServletInvocableHandlerMethod的时候被注入到WebDataBinderFactory中的，而WebDataBinderFactory是ServletInvocableHandlerMethod的一个属性。在RequestMappingHandlerAdapter的invokeHandleMethod方法中的getDataBinderFactory就是得到的WebDataBinderFactory。</p>
<p>我们来把目光转向getDataBinderFactory方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> WebDataBinderFactory <span class="title">getDataBinderFactory</span><span class="params">(HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Class&lt;?&gt; handlerType = handlerMethod.getBeanType();</span><br><span class="line">		Set&lt;Method&gt; methods = <span class="keyword">this</span>.initBinderCache.get(handlerType);</span><br><span class="line">		<span class="keyword">if</span> (methods == <span class="keyword">null</span>) &#123;</span><br><span class="line">			methods = HandlerMethodSelector.selectMethods(handlerType, INIT_BINDER_METHODS);</span><br><span class="line">			<span class="keyword">this</span>.initBinderCache.put(handlerType, methods);</span><br><span class="line">		&#125;</span><br><span class="line">		List&lt;InvocableHandlerMethod&gt; initBinderMethods = <span class="keyword">new</span> ArrayList&lt;InvocableHandlerMethod&gt;();</span><br><span class="line">		<span class="comment">// Global methods first</span></span><br><span class="line">		<span class="keyword">for</span> (Entry&lt;ControllerAdviceBean, Set&lt;Method&gt;&gt; entry : <span class="keyword">this</span>.initBinderAdviceCache .entrySet()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (entry.getKey().isApplicableToBeanType(handlerType)) &#123;</span><br><span class="line">				Object bean = entry.getKey().resolveBean();</span><br><span class="line">				<span class="keyword">for</span> (Method method : entry.getValue()) &#123;</span><br><span class="line">					initBinderMethods.add(createInitBinderMethod(bean, method));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">			Object bean = handlerMethod.getBean();</span><br><span class="line">			initBinderMethods.add(createInitBinderMethod(bean, method));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> createDataBinderFactory(initBinderMethods);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法就是筛选出有@InitBinder注解的方法，将其注入到DataBinderFactory中。</p>
<p>我们需要重点关注的就是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">		methods = HandlerMethodSelector.selectMethods(handlerType, INIT_BINDER_METHODS);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MethodFilter INIT_BINDER_METHODS = <span class="keyword">new</span> MethodFilter() &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> AnnotationUtils.findAnnotation(method, InitBinder.class) != <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>筛选出有@InitBinder注解的方法。</p>
<p>之后RequestParamMethodArgumentResolver通过WebDataBinderFactory创建的WebDataBinder里的自定义属性编辑器找到合适的属性编辑器(我们自定义的属性编辑器是用CustomDateEditor处理Date对象，而testDate的参数刚好是Date)，最终CustomDateEditor把这个String对象转换成Date对象。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2018/01/08/--SpringMVC请求处理之对方法参数的处理/" data-id="cjc5323q100007cbzlvfs0v32" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post---SpringMVC配置文件详解（六）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/08/--SpringMVC配置文件详解（六）/" class="article-date">
  <time datetime="2018-01-07T17:58:41.444Z" itemprop="datePublished">2018-01-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SpringMVC/">SpringMVC</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/08/--SpringMVC配置文件详解（六）/">SpringMVC配置文件详解（六）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我们之前已经讲解过了</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个标签了，但是他下面是可以有子标签的，今天我们就来讲一下他的子标签，我们在配置文件中使用了他的子标签来完成了对json数据的转化。我们先看下配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mvc:message-converters</span> <span class="attr">register-defaults</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- @ResponseBody乱码问题，将StringHttpMessageConverter的默认编码设为UTF-8 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.http.converter.StringHttpMessageConverter"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 配置Fastjson支持 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">bean</span></span></span><br><span class="line"><span class="tag">			<span class="attr">class</span>=<span class="string">"com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"charset"</span> <span class="attr">value</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"supportedMediaTypes"</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">value</span>&gt;</span>application/json<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">value</span>&gt;</span>text/html;charset=UTF-8<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"features"</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">value</span>&gt;</span>WriteMapNullValue<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">value</span>&gt;</span>QuoteFieldNames<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">value</span>&gt;</span>WriteDateUseDateFormat<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">value</span>&gt;</span>WriteEnumUsingToString<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="解析"><a href="#解析" class="headerlink" title="\解析"></a>\解析</h3><p>我们直接看parse方法了。</p>
<p>我们截取注册RequestMappingHandlerAdapter的部分</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">	ManagedList&lt;?&gt; messageConverters = getMessageConverters(element, source, parserContext);</span><br><span class="line">		ManagedList&lt;?&gt; argumentResolvers = getArgumentResolvers(element, parserContext);</span><br><span class="line">		ManagedList&lt;?&gt; returnValueHandlers = getReturnValueHandlers(element, parserContext);</span><br><span class="line">		String asyncTimeout = getAsyncTimeout(element);</span><br><span class="line">		RuntimeBeanReference asyncExecutor = getAsyncExecutor(element);</span><br><span class="line">		ManagedList&lt;?&gt; callableInterceptors = getCallableInterceptors(element, source, parserContext);</span><br><span class="line">		ManagedList&lt;?&gt; deferredResultInterceptors = getDeferredResultInterceptors(element, source, parserContext);</span><br><span class="line"></span><br><span class="line">		RootBeanDefinition handlerAdapterDef = <span class="keyword">new</span> RootBeanDefinition(RequestMappingHandlerAdapter.class);</span><br><span class="line">		handlerAdapterDef.setSource(source);</span><br><span class="line">		handlerAdapterDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">		handlerAdapterDef.getPropertyValues().add(<span class="string">"contentNegotiationManager"</span>, contentNegotiationManager);</span><br><span class="line">		handlerAdapterDef.getPropertyValues().add(<span class="string">"webBindingInitializer"</span>, bindingDef);</span><br><span class="line">		handlerAdapterDef.getPropertyValues().add(<span class="string">"messageConverters"</span>, messageConverters);</span><br><span class="line">		addResponseBodyAdvice(handlerAdapterDef);</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>其中getMessageConverters(element, source, parserContext);就是得到我们配置的messageConverters，然后使用    handlerAdapterDef.getPropertyValues().add(“messageConverters”, messageConverters);注入到messageConverters属性中。</p>
<p><strong>getMessageConverters</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ManagedList&lt;?&gt; getMessageConverters(Element element, Object source, ParserContext parserContext) &#123;</span><br><span class="line">		Element convertersElement = DomUtils.getChildElementByTagName(element, <span class="string">"message-converters"</span>);</span><br><span class="line">		ManagedList&lt;? <span class="keyword">super</span> Object&gt; messageConverters = <span class="keyword">new</span> ManagedList&lt;Object&gt;();</span><br><span class="line">		<span class="keyword">if</span> (convertersElement != <span class="keyword">null</span>) &#123;</span><br><span class="line">			messageConverters.setSource(source);</span><br><span class="line">			<span class="keyword">for</span> (Element beanElement : DomUtils.getChildElementsByTagName(convertersElement, <span class="string">"bean"</span>, <span class="string">"ref"</span>)) &#123;</span><br><span class="line">				Object object = parserContext.getDelegate().parsePropertySubElement(beanElement, <span class="keyword">null</span>);</span><br><span class="line">				messageConverters.add(object);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (convertersElement == <span class="keyword">null</span> || Boolean.valueOf(convertersElement.getAttribute(<span class="string">"register-defaults"</span>))) &#123;</span><br><span class="line">			messageConverters.setSource(source);</span><br><span class="line">			messageConverters.add(createConverterDefinition(ByteArrayHttpMessageConverter.class, source));</span><br><span class="line"></span><br><span class="line">			RootBeanDefinition stringConverterDef = createConverterDefinition(StringHttpMessageConverter.class, source);</span><br><span class="line">			stringConverterDef.getPropertyValues().add(<span class="string">"writeAcceptCharset"</span>, <span class="keyword">false</span>);</span><br><span class="line">			messageConverters.add(stringConverterDef);</span><br><span class="line"></span><br><span class="line">			messageConverters.add(createConverterDefinition(ResourceHttpMessageConverter.class, source));</span><br><span class="line">			messageConverters.add(createConverterDefinition(SourceHttpMessageConverter.class, source));</span><br><span class="line">			messageConverters.add(createConverterDefinition(AllEncompassingFormHttpMessageConverter.class, source));</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (romePresent) &#123;</span><br><span class="line">				messageConverters.add(createConverterDefinition(AtomFeedHttpMessageConverter.class, source));</span><br><span class="line">				messageConverters.add(createConverterDefinition(RssChannelHttpMessageConverter.class, source));</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (jackson2XmlPresent) &#123;</span><br><span class="line">				RootBeanDefinition jacksonConverterDef = createConverterDefinition(MappingJackson2XmlHttpMessageConverter.class, source);</span><br><span class="line">				GenericBeanDefinition jacksonFactoryDef = createObjectMapperFactoryDefinition(source);</span><br><span class="line">				jacksonFactoryDef.getPropertyValues().add(<span class="string">"createXmlMapper"</span>, <span class="keyword">true</span>);</span><br><span class="line">				jacksonConverterDef.getConstructorArgumentValues().addIndexedArgumentValue(<span class="number">0</span>, jacksonFactoryDef);</span><br><span class="line">				messageConverters.add(jacksonConverterDef);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (jaxb2Present) &#123;</span><br><span class="line">				messageConverters.add(createConverterDefinition(Jaxb2RootElementHttpMessageConverter.class, source));</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (jackson2Present) &#123;</span><br><span class="line">				RootBeanDefinition jacksonConverterDef = createConverterDefinition(MappingJackson2HttpMessageConverter.class, source);</span><br><span class="line">				GenericBeanDefinition jacksonFactoryDef = createObjectMapperFactoryDefinition(source);</span><br><span class="line">				jacksonConverterDef.getConstructorArgumentValues().addIndexedArgumentValue(<span class="number">0</span>, jacksonFactoryDef);</span><br><span class="line">				messageConverters.add(jacksonConverterDef);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (gsonPresent) &#123;</span><br><span class="line">				messageConverters.add(createConverterDefinition(GsonHttpMessageConverter.class, source));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> messageConverters;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>1,查看配置文件中是否有\标签，如果有，将其下的bean注入到messageConverters中。</p>
<p>2.如果没有，就使用默认的注册策略。如果有，且标签里的register-defaults属性为true，那么也要在用户自己实现的messageConverters中添加默认策略。</p>
<p>默认策略注册了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ByteArrayHttpMessageConverter</span><br><span class="line">StringHttpMessageConverter</span><br><span class="line">ResourceHttpMessageConverter</span><br><span class="line">SourceHttpMessageConverter</span><br><span class="line">AllEncompassingFormHttpMessageConverter</span><br><span class="line">AtomFeedHttpMessageConverter</span><br><span class="line">RssChannelHttpMessageConverter</span><br></pre></td></tr></table></figure>
<p>以及当程序中引入了某些包后自动会注册相应xml，json类型数据的MessageConverter。</p>
<p>举个例子，当添加了Gson包这个处理json数据的包之后，就会默认的添加GsonHttpMessageConverter。相应代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (gsonPresent) &#123;</span><br><span class="line">				messageConverters.add(createConverterDefinition(GsonHttpMessageConverter.class, source));</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>
<p>所以这也也是为什么当添加了jackson包或者Gson包，我们的SpringMVC可以自动的处理json格式数据，而为什么我们添加fastjson这个处理json数据的包就不行呢，就必须自己注册，因为默认策略里没有他的一席之地。</p>
<p>\允许了用户实现自己的MessageConverter注入到messageConverters中，扩展了SpringMVC的作用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2018/01/08/--SpringMVC配置文件详解（六）/" data-id="cjc5323qf00017cbzjjedcmuw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post---SpringMVC配置文件解析（五）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/07/--SpringMVC配置文件解析（五）/" class="article-date">
  <time datetime="2018-01-07T08:11:02.871Z" itemprop="datePublished">2018-01-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SpringMVC/">SpringMVC</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/07/--SpringMVC配置文件解析（五）/">SpringMVC配置文件解析（五）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我们接着讲解SpringMVC处理静态资源的方法，这一篇要讲解的是</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>配置处理静态资源的原理</p>
<h3 id="的解析"><a href="#的解析" class="headerlink" title="\的解析"></a>\<mvc:default-servlet-handler>的解析</mvc:default-servlet-handler></h3><p>不多说废话了，直接来到DefaultServletHandlerBeanDefinitionParser的parse方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">		Object source = parserContext.extractSource(element);</span><br><span class="line"></span><br><span class="line">		String defaultServletName = element.getAttribute(<span class="string">"default-servlet-name"</span>);</span><br><span class="line">		RootBeanDefinition defaultServletHandlerDef = <span class="keyword">new</span> RootBeanDefinition(DefaultServletHttpRequestHandler.class);</span><br><span class="line">		defaultServletHandlerDef.setSource(source);</span><br><span class="line">		defaultServletHandlerDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">		<span class="keyword">if</span> (StringUtils.hasText(defaultServletName)) &#123;</span><br><span class="line">			defaultServletHandlerDef.getPropertyValues().add(<span class="string">"defaultServletName"</span>, defaultServletName);</span><br><span class="line">		&#125;</span><br><span class="line">		String defaultServletHandlerName = parserContext.getReaderContext().generateBeanName(defaultServletHandlerDef);</span><br><span class="line">		parserContext.getRegistry().registerBeanDefinition(defaultServletHandlerName, defaultServletHandlerDef);</span><br><span class="line">		parserContext.registerComponent(<span class="keyword">new</span> BeanComponentDefinition(defaultServletHandlerDef, defaultServletHandlerName));</span><br><span class="line"></span><br><span class="line">		Map&lt;String, String&gt; urlMap = <span class="keyword">new</span> ManagedMap&lt;String, String&gt;();</span><br><span class="line">		urlMap.put(<span class="string">"/**"</span>, defaultServletHandlerName);</span><br><span class="line"></span><br><span class="line">		RootBeanDefinition handlerMappingDef = <span class="keyword">new</span> RootBeanDefinition(SimpleUrlHandlerMapping.class);</span><br><span class="line">		handlerMappingDef.setSource(source);</span><br><span class="line">		handlerMappingDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">		handlerMappingDef.getPropertyValues().add(<span class="string">"urlMap"</span>, urlMap);</span><br><span class="line"></span><br><span class="line">		String handlerMappingBeanName = parserContext.getReaderContext().generateBeanName(handlerMappingDef);</span><br><span class="line">		parserContext.getRegistry().registerBeanDefinition(handlerMappingBeanName, handlerMappingDef);</span><br><span class="line">		parserContext.registerComponent(<span class="keyword">new</span> BeanComponentDefinition(handlerMappingDef, handlerMappingBeanName));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Ensure BeanNameUrlHandlerMapping (SPR-8289) and default HandlerAdapters are not "turned off"</span></span><br><span class="line">		MvcNamespaceUtils.registerDefaultComponents(parserContext, source);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>1.注册了一个DefaultServletHttpRequestHandler实例，beanName为defaultServletHandlerName。</p>
<p>2.注册了一个SimpleUrlHandlerMapping实例，并且注册了属性urlMap。</p>
<p>为urlMap添加了一个元素，key为”/**”,value为defaultServletHandlerName。</p>
<p>注意，这里没有指定SimpleUrlHandlerMapping的order，所以是默认的Integer.MAX，也就是优先级最低的。</p>
<p>3.注册默认的Mapping 以及Adapter等。</p>
<p>上一篇已经说过\<mvc:resources>注册的SimpleUrlHandlerMapping实例的order为Integer.MAX-1，也就是说当这两种处理静态资源的方式都使用了的时候，会优先使用\<mvc:resources>注册的。</mvc:resources></mvc:resources></p>
<p>那我们接下来就看看使用\<mvc:default-servlet-handler>到底是如何处理静态资源请求的吧。</mvc:default-servlet-handler></p>
<h3 id="处理静态资源"><a href="#处理静态资源" class="headerlink" title="处理静态资源"></a>处理静态资源</h3><p>首先getHandler得到的是上述defaultServletHandlerName对应的Bean,DefaultServletHttpRequestHandler实例。</p>
<p>而ha.supports(handler);得到的HandlerAdpater肯定是</p>
<p>HttpRequestHandlerAdapter，这个之前都讲过。</p>
<p>那么走到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br></pre></td></tr></table></figure>
<p>之后的具体执行也是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">      ((HttpRequestHandler) handler).handleRequest(request, response);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>其实都和\<mvc:resources>的步骤一样，就不细说了，只是之类的handler不一样，这时的Handler是</mvc:resources></p>
<p>DefaultServletHttpRequestHandler。所有的处理都在他的handleRequest方法中。</p>
<p><strong>handleRequest(request, response)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">	RequestDispatcher rd = <span class="keyword">this</span>.servletContext.getNamedDispatcher(<span class="keyword">this</span>.defaultServletName);</span><br><span class="line">	<span class="keyword">if</span> (rd == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"A RequestDispatcher could not be located for the default servlet '"</span> +</span><br><span class="line">				<span class="keyword">this</span>.defaultServletName +<span class="string">"'"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	rd.forward(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到这段代码，是不是又回到了刚开始学习Servlet的时候呢，真的有好久好久没看到forward(requset,response);方法了，是时候来回顾一下了。</p>
<p>我们先看看这段代码做了什么。</p>
<p>1.用defaultServletName得到相应的RequestDispatcher实现类。</p>
<p>2.调用RequestDispatcher的forward来处理请求。</p>
<ul>
<li>首先我们来看看是如何得到RequestDispatcher实现类的。</li>
</ul>
<p>我们这里的Web容器是Tomcat，对应的defaultServletName是default。至于这个defaullt的配置，在../lib/conf/web.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.apache.catalina.servlets.DefaultServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>debug<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>0<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>listings<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们在这清楚的看到他是初始化时就要启动的一个servlet，而且知道了对应的类是org.apache.catalina.servlets.DefaultServlet。</p>
<p>接下来就要看这个方法的具体执行了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RequestDispatcher rd = <span class="keyword">this</span>.servletContext.getNamedDispatcher(<span class="keyword">this</span>.defaultServletName);</span><br></pre></td></tr></table></figure>
<p>这就需要回到我们的Tomcat源码中讲解了，Tomcat中serlvetContext的实现是ApplciationContext和ApplicationContextFacade，虽然我们给到用户的是后者，但是后者就是对前者的包装，实际的方法的实现都在ApplciationContext中，我们来看看这个类中的getNamedDispatcher方法</p>
<p><strong>getNamedDispatcher(String name)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestDispatcher <span class="title">getNamedDispatcher</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Validate the name argument</span></span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create and return a corresponding request dispatcher</span></span><br><span class="line">    Wrapper wrapper = (Wrapper) context.findChild(name);</span><br><span class="line">    <span class="keyword">if</span> (wrapper == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ApplicationDispatcher(wrapper, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我们已经分析过Tomcat源码后，对这个方法就不难理解了。</p>
<p>1.通过name获得对应Wrapper实例（对Servlet实现类的封装，这里既是对DefaultServlet的封装）,所有的Servlet类都被当做Web容器的子容器。</p>
<p>2.返回一个ApplicationDispatcher实例，该实例封装了Wrapper实例。</p>
<p>所以最终得到的是一个ApplicationDispatcher实例。</p>
<p>那么接下来就是调用这个实例的forward方法了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forward</span><span class="params">(ServletRequest request, ServletResponse response)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> ServletException, IOException</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (Globals.IS_SECURITY_ENABLED) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               PrivilegedForward dp = <span class="keyword">new</span> PrivilegedForward(request,response);</span><br><span class="line">               AccessController.doPrivileged(dp);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (PrivilegedActionException pe) &#123;</span><br><span class="line">               Exception e = pe.getException();</span><br><span class="line">               <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ServletException)</span><br><span class="line">                   <span class="keyword">throw</span> (ServletException) e;</span><br><span class="line">               <span class="keyword">throw</span> (IOException) e;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           doForward(request,response);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>我们主要分析doForward方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doForward</span><span class="params">(ServletRequest request, ServletResponse response)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> ServletException, IOException</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// Reset any output that has been buffered, but keep headers/cookies</span></span><br><span class="line">      <span class="keyword">if</span> (response.isCommitted()) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException</span><br><span class="line">              (sm.getString(<span class="string">"applicationDispatcher.forward.ise"</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          response.resetBuffer();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> e;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Set up to handle the specified request and response</span></span><br><span class="line">      State state = <span class="keyword">new</span> State(request, response, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (WRAP_SAME_OBJECT) &#123;</span><br><span class="line">          <span class="comment">// Check SRV.8.2 / SRV.14.2.5.1 compliance</span></span><br><span class="line">          checkSameObjects(request, response);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      wrapResponse(state);</span><br><span class="line">      <span class="comment">// Handle an HTTP named dispatcher forward</span></span><br><span class="line">      <span class="keyword">if</span> ((servletPath == <span class="keyword">null</span>) &amp;&amp; (pathInfo == <span class="keyword">null</span>)) &#123;</span><br><span class="line"></span><br><span class="line">          ApplicationHttpRequest wrequest =</span><br><span class="line">              (ApplicationHttpRequest) wrapRequest(state);</span><br><span class="line">          HttpServletRequest hrequest = state.hrequest;</span><br><span class="line">          wrequest.setRequestURI(hrequest.getRequestURI());</span><br><span class="line">          wrequest.setContextPath(hrequest.getContextPath());</span><br><span class="line">          wrequest.setServletPath(hrequest.getServletPath());</span><br><span class="line">          wrequest.setPathInfo(hrequest.getPathInfo());</span><br><span class="line">          wrequest.setQueryString(hrequest.getQueryString());</span><br><span class="line"></span><br><span class="line">          processRequest(request,response,state);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Handle an HTTP path-based forward</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">          ApplicationHttpRequest wrequest =</span><br><span class="line">              (ApplicationHttpRequest) wrapRequest(state);</span><br><span class="line">          String contextPath = context.getPath();</span><br><span class="line">          HttpServletRequest hrequest = state.hrequest;</span><br><span class="line">          <span class="keyword">if</span> (hrequest.getAttribute(</span><br><span class="line">                  RequestDispatcher.FORWARD_REQUEST_URI) == <span class="keyword">null</span>) &#123;</span><br><span class="line">              wrequest.setAttribute(RequestDispatcher.FORWARD_REQUEST_URI,</span><br><span class="line">                                    hrequest.getRequestURI());</span><br><span class="line">              wrequest.setAttribute(RequestDispatcher.FORWARD_CONTEXT_PATH,</span><br><span class="line">                                    hrequest.getContextPath());</span><br><span class="line">              wrequest.setAttribute(RequestDispatcher.FORWARD_SERVLET_PATH,</span><br><span class="line">                                    hrequest.getServletPath());</span><br><span class="line">              wrequest.setAttribute(RequestDispatcher.FORWARD_PATH_INFO,</span><br><span class="line">                                    hrequest.getPathInfo());</span><br><span class="line">              wrequest.setAttribute(RequestDispatcher.FORWARD_QUERY_STRING,</span><br><span class="line">                                    hrequest.getQueryString());</span><br><span class="line">          &#125;</span><br><span class="line"> </span><br><span class="line">          wrequest.setContextPath(contextPath);</span><br><span class="line">          wrequest.setRequestURI(requestURI);</span><br><span class="line">          wrequest.setServletPath(servletPath);</span><br><span class="line">          wrequest.setPathInfo(pathInfo);</span><br><span class="line">          <span class="keyword">if</span> (queryString != <span class="keyword">null</span>) &#123;</span><br><span class="line">              wrequest.setQueryString(queryString);</span><br><span class="line">              wrequest.setQueryParams(queryString);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          processRequest(request,response,state);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (request.isAsyncStarted()) &#123;</span><br><span class="line">          <span class="comment">// An async request was started during the forward, don't close the</span></span><br><span class="line">          <span class="comment">// response as it may be written to during the async handling</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>  (response <span class="keyword">instanceof</span> ResponseFacade) &#123;</span><br><span class="line">          ((ResponseFacade) response).finish();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">          <span class="comment">// Close anyway</span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              PrintWriter writer = response.getWriter();</span><br><span class="line">              writer.close();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  ServletOutputStream stream = response.getOutputStream();</span><br><span class="line">                  stream.close();</span><br><span class="line">              &#125; <span class="keyword">catch</span> (IllegalStateException f) &#123;</span><br><span class="line">                  <span class="comment">// Ignore</span></span><br><span class="line">              &#125; <span class="keyword">catch</span> (IOException f) &#123;</span><br><span class="line">                  <span class="comment">// Ignore</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">              <span class="comment">// Ignore</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法很长，主要的实现其实就是处理请求，有兴趣的可以看看源码。所以最后就是使用DefaultServlet来处理静态资源的请求，具体处理过程有兴趣的可以看看源码。</p>
<p>其实上面对RequestDispatcher实例已经其forward方法的分析看下来，都没有出现我们在学习forward方法提到的这个方法有请求转发的贡功能，一直都是用这个Servlet实例来处理请求呀，并没有出现第二个Servlet呀？</p>
<p>这是因为我们是使用getNamedDispatcher来得到RequestDispatcher实例的，就是通过名字来找到对应的Servlet,然后使用这个servlet来处理请求，确实没有转发给第二个Servlet处理。</p>
<p>而我们常说的具有请求转发功能的RequestDispatcher是由getRequestDispatcher来得到的。</p>
<p>通常表现为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//获取请求转发器对象，该转发器的指向通过getRequestDisPatcher()的参数设置</span></span><br><span class="line">RequestDispatcher requestDispatcher =request.getRequestDispatcher(<span class="string">"资源的URL"</span>);</span><br><span class="line"> <span class="comment">//调用forward()方法，转发请求      </span></span><br><span class="line">requestDispatcher.forward(request,response);</span><br></pre></td></tr></table></figure>
<p>我们发现这里是调用Request对象的getRequestDispatcher方法，而实际上内部调用的还是ApplicationContext的getRequestDispatcher方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> RequestDispatcher <span class="title">getRequestDispatcher</span><span class="params">(<span class="keyword">final</span> String path)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Validate the path argument</span></span><br><span class="line">     <span class="keyword">if</span> (path == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> (<span class="keyword">null</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (!path.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                 sm.getString(<span class="string">"applicationContext.requestDispatcher.iae"</span>, path));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Need to separate the query string and the uri. This is required for</span></span><br><span class="line">     <span class="comment">// the ApplicationDispatcher constructor. Mapping also requires the uri</span></span><br><span class="line">     <span class="comment">// without the query string.</span></span><br><span class="line">     String uri;</span><br><span class="line">     String queryString;</span><br><span class="line">     <span class="keyword">int</span> pos = path.indexOf(<span class="string">'?'</span>);</span><br><span class="line">     <span class="keyword">if</span> (pos &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">         uri = path.substring(<span class="number">0</span>, pos);</span><br><span class="line">         queryString = path.substring(pos + <span class="number">1</span>);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         uri = path;</span><br><span class="line">         queryString = <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     String normalizedPath = RequestUtil.normalize(uri);</span><br><span class="line">     <span class="keyword">if</span> (normalizedPath == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> (<span class="keyword">null</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (getContext().getDispatchersUseEncodedPaths()) &#123;</span><br><span class="line">         <span class="comment">// Decode</span></span><br><span class="line">         String decodedPath;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             decodedPath = URLDecoder.decode(normalizedPath, <span class="string">"UTF-8"</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">             <span class="comment">// Impossible</span></span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Security check to catch attempts to encode /../ sequences</span></span><br><span class="line">         normalizedPath = RequestUtil.normalize(decodedPath);</span><br><span class="line">         <span class="keyword">if</span> (!decodedPath.equals(normalizedPath)) &#123;</span><br><span class="line">             getContext().getLogger().warn(</span><br><span class="line">                     sm.getString(<span class="string">"applicationContext.illegalDispatchPath"</span>, path),</span><br><span class="line">                     <span class="keyword">new</span> IllegalArgumentException());</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// URI needs to include the context path</span></span><br><span class="line">         uri = URLEncoder.DEFAULT.encode(getContextPath(), <span class="string">"UTF-8"</span>) + uri;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// uri is passed to the constructor for ApplicationDispatcher and is</span></span><br><span class="line">         <span class="comment">// ultimately used as the value for getRequestURI() which returns</span></span><br><span class="line">         <span class="comment">// encoded values. Therefore, since the value passed in for path</span></span><br><span class="line">         <span class="comment">// was decoded, encode uri here.</span></span><br><span class="line">         uri = URLEncoder.DEFAULT.encode(getContextPath() + uri, <span class="string">"UTF-8"</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     pos = normalizedPath.length();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Use the thread local URI and mapping data</span></span><br><span class="line">     DispatchData dd = dispatchData.get();</span><br><span class="line">     <span class="keyword">if</span> (dd == <span class="keyword">null</span>) &#123;</span><br><span class="line">         dd = <span class="keyword">new</span> DispatchData();</span><br><span class="line">         dispatchData.set(dd);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     MessageBytes uriMB = dd.uriMB;</span><br><span class="line">     uriMB.recycle();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Use the thread local mapping data</span></span><br><span class="line">     MappingData mappingData = dd.mappingData;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Map the URI</span></span><br><span class="line">     CharChunk uriCC = uriMB.getCharChunk();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         uriCC.append(context.getPath(), <span class="number">0</span>, context.getPath().length());</span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">          * Ignore any trailing path params (separated by ';') for mapping</span></span><br><span class="line"><span class="comment">          * purposes</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         <span class="keyword">int</span> semicolon = normalizedPath.indexOf(<span class="string">';'</span>);</span><br><span class="line">         <span class="keyword">if</span> (pos &gt;= <span class="number">0</span> &amp;&amp; semicolon &gt; pos) &#123;</span><br><span class="line">             semicolon = -<span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         uriCC.append(normalizedPath, <span class="number">0</span>, semicolon &gt; <span class="number">0</span> ? semicolon : pos);</span><br><span class="line">         context.getMapper().map(uriMB, mappingData);</span><br><span class="line">         <span class="keyword">if</span> (mappingData.wrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">return</span> (<span class="keyword">null</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">          * Append any trailing path params (separated by ';') that were</span></span><br><span class="line"><span class="comment">          * ignored for mapping purposes, so that they're reflected in the</span></span><br><span class="line"><span class="comment">          * RequestDispatcher's requestURI</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         <span class="keyword">if</span> (semicolon &gt; <span class="number">0</span>) &#123;</span><br><span class="line">             uriCC.append(normalizedPath, semicolon, pos - semicolon);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         <span class="comment">// Should never happen</span></span><br><span class="line">         log(sm.getString(<span class="string">"applicationContext.mapping.error"</span>), e);</span><br><span class="line">         <span class="keyword">return</span> (<span class="keyword">null</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     Wrapper wrapper = (Wrapper) mappingData.wrapper;</span><br><span class="line">     String wrapperPath = mappingData.wrapperPath.toString();</span><br><span class="line">     String pathInfo = mappingData.pathInfo.toString();</span><br><span class="line"></span><br><span class="line">     mappingData.recycle();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Construct a RequestDispatcher to process this request</span></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> ApplicationDispatcher(wrapper, uri, wrapperPath, pathInfo,</span><br><span class="line">             queryString, <span class="keyword">null</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法也是巨长，我们简单说一下他做了什么：</p>
<p>1.通过用户(程序员)指定的path，我们先查看path是否带有参数（即是否有? ，当使用get方式请求时，参数会用?a=b&amp;c=d形式呈现），如果有参数，则将参数放入到queryString属性中。</p>
<p>2.通过调用context.getMapper().map(uriMB, mappingData);得到我们要转发的Servlet（Servlet被封装成Warpper,Warpper封装在了MappingData中），具体怎么找的，我们在讲解Tomcat的时候说过。</p>
<p>3.将我们得到warpper实例，rui，queryString等注入到ApplicationDispatcher实例中，然后调用该实例的forward方法处理请求，就实现了将请求转发到另一个Servlet中处理的效果。</p>
<p>既然我们已经讲了在服务器端进行转发的forward方法，那我们刚好讲下在客户机上跳转的sendRedirect方法，一般以如下形式使用。</p>
<p><strong>sendRedirect</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求重定向到另外的资源</span></span><br><span class="line">    response.sendRedirect(<span class="string">"资源的URL"</span>);</span><br></pre></td></tr></table></figure>
<p>我们使用的Web容器是Tomcat，所以我们就找到org.apache.catalina.connector.Response的sendRedirect方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendRedirect</span><span class="params">(String location)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       sendRedirect(location, SC_FOUND);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Internal method that allows a redirect to be sent with a status other</span></span><br><span class="line"><span class="comment">    * than &#123;<span class="doctag">@link</span> HttpServletResponse#SC_FOUND&#125; (302). No attempt is made to</span></span><br><span class="line"><span class="comment">    * validate the status code.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendRedirect</span><span class="params">(String location, <span class="keyword">int</span> status)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (isCommitted()) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(sm.getString(<span class="string">"coyoteResponse.sendRedirect.ise"</span>));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Ignore any call from an included servlet</span></span><br><span class="line">       <span class="keyword">if</span> (included) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Clear any data content that has been buffered</span></span><br><span class="line">       resetBuffer(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Generate a temporary redirect to the specified location</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           String locationUri;</span><br><span class="line">           <span class="comment">// Relative redirects require HTTP/1.1</span></span><br><span class="line">           <span class="keyword">if</span> (getRequest().getCoyoteRequest().getSupportsRelativeRedirects() &amp;&amp;</span><br><span class="line">                   getContext().getUseRelativeRedirects()) &#123;</span><br><span class="line">               locationUri = location;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               locationUri = toAbsolute(location);</span><br><span class="line">           &#125;</span><br><span class="line">           setStatus(status);</span><br><span class="line">           setHeader(<span class="string">"Location"</span>, locationUri);</span><br><span class="line">           <span class="keyword">if</span> (getContext().getSendRedirectBody()) &#123;</span><br><span class="line">               PrintWriter writer = getWriter();</span><br><span class="line">               writer.print(sm.getString(<span class="string">"coyoteResponse.sendRedirect.note"</span>,</span><br><span class="line">                       RequestUtil.filter(locationUri)));</span><br><span class="line">               flushBuffer();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">           log.warn(sm.getString(<span class="string">"response.sendRedirectFail"</span>, location), e);</span><br><span class="line">           setStatus(SC_NOT_FOUND);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Cause the response to be finished (from the application perspective)</span></span><br><span class="line">       setSuspended(<span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>方法很好理解，就是重新封装了一个请求，给出了请求行的状态为302（302为重定向，我们还是需要多熟悉状态码滴）并且使用了Location这个请求头，将给定的url放入这个请求头属性中，当浏览器接受到请求头信息中的 Location: xxxx 后，就会自动跳转到 xxxx 指向的URL地址，这个跳转只有浏览器知道，所以使用了这个跳转这后，浏览器地址栏的url是会改变的，变成了我指定的url，而使用forward是不会改变的，因为他只是把请求转发给另一个servlet来处理。</p>
<p><strong>include</strong></p>
<p>既然都说了forward方法和sendRedirect方法了，那就再说下include方法吧。</p>
<p>使用方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.getRequestDispatcher(<span class="string">"jsp2.jsp"</span>).include(request,   response);</span><br></pre></td></tr></table></figure>
<p>功能是将RequestDispatcher对象封装的资源内容作为当前响应内容的一部分包含进来，从而实现可编程的服务器端包含功能。</p>
<p>这个方法的实现依旧是在ApplicationDispatcher中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">include</span><span class="params">(ServletRequest request, ServletResponse response)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Globals.IS_SECURITY_ENABLED) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                PrivilegedInclude dp = <span class="keyword">new</span> PrivilegedInclude(request,response);</span><br><span class="line">                AccessController.doPrivileged(dp);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (PrivilegedActionException pe) &#123;</span><br><span class="line">                Exception e = pe.getException();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ServletException)</span><br><span class="line">                    <span class="keyword">throw</span> (ServletException) e;</span><br><span class="line">                <span class="keyword">throw</span> (IOException) e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            doInclude(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doInclude</span><span class="params">(ServletRequest request, ServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set up to handle the specified request and response</span></span><br><span class="line">        State state = <span class="keyword">new</span> State(request, response, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (WRAP_SAME_OBJECT) &#123;</span><br><span class="line">            <span class="comment">// Check SRV.8.2 / SRV.14.2.5.1 compliance</span></span><br><span class="line">            checkSameObjects(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Create a wrapped response to use for this request</span></span><br><span class="line">        wrapResponse(state);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Handle an HTTP named dispatcher include</span></span><br><span class="line">        <span class="keyword">if</span> (name != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            ApplicationHttpRequest wrequest =</span><br><span class="line">                (ApplicationHttpRequest) wrapRequest(state);</span><br><span class="line">            wrequest.setAttribute(Globals.NAMED_DISPATCHER_ATTR, name);</span><br><span class="line">            <span class="keyword">if</span> (servletPath != <span class="keyword">null</span>)</span><br><span class="line">                wrequest.setServletPath(servletPath);</span><br><span class="line">            wrequest.setAttribute(Globals.DISPATCHER_TYPE_ATTR,</span><br><span class="line">                    DispatcherType.INCLUDE);</span><br><span class="line">            wrequest.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,</span><br><span class="line">                    getCombinedPath());</span><br><span class="line">            invoke(state.outerRequest, state.outerResponse, state);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Handle an HTTP path based include</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            ApplicationHttpRequest wrequest =</span><br><span class="line">                (ApplicationHttpRequest) wrapRequest(state);</span><br><span class="line">            String contextPath = context.getPath();</span><br><span class="line">            <span class="keyword">if</span> (requestURI != <span class="keyword">null</span>)</span><br><span class="line">                wrequest.setAttribute(RequestDispatcher.INCLUDE_REQUEST_URI,</span><br><span class="line">                                      requestURI);</span><br><span class="line">            <span class="keyword">if</span> (contextPath != <span class="keyword">null</span>)</span><br><span class="line">                wrequest.setAttribute(RequestDispatcher.INCLUDE_CONTEXT_PATH,</span><br><span class="line">                                      contextPath);</span><br><span class="line">            <span class="keyword">if</span> (servletPath != <span class="keyword">null</span>)</span><br><span class="line">                wrequest.setAttribute(RequestDispatcher.INCLUDE_SERVLET_PATH,</span><br><span class="line">                                      servletPath);</span><br><span class="line">            <span class="keyword">if</span> (pathInfo != <span class="keyword">null</span>)</span><br><span class="line">                wrequest.setAttribute(RequestDispatcher.INCLUDE_PATH_INFO,</span><br><span class="line">                                      pathInfo);</span><br><span class="line">            <span class="keyword">if</span> (queryString != <span class="keyword">null</span>) &#123;</span><br><span class="line">                wrequest.setAttribute(RequestDispatcher.INCLUDE_QUERY_STRING,</span><br><span class="line">                                      queryString);</span><br><span class="line">                wrequest.setQueryParams(queryString);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            wrequest.setAttribute(Globals.DISPATCHER_TYPE_ATTR,</span><br><span class="line">                    DispatcherType.INCLUDE);</span><br><span class="line">            wrequest.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,</span><br><span class="line">                    getCombinedPath());</span><br><span class="line">            invoke(state.outerRequest, state.outerResponse, state);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>咋一看doInclude方法好像跟forward里的doForward方法没差呀，确实很多地方都相同，但是他相较而言多了一个        invoke(state.outerRequest, state.outerResponse, state);方法</p>
<p>这个方法就是include的核心了，这个方法完成了是将RequestDispatcher对象封装的资源内容作为当前响应内容的一部分包含进来的功能，有兴趣的可以看看源码具体如何实现。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>到这里，对SpringMVC配置文件的讲解就先告一段落了，接下来就要讲解HandlerMethod到底是如何处理请求等一系列问题了，我们只是解决了SpringMVC的一小部分问题，后面的路还很长呀。</p>
<p>先把这篇的内容做一个小总结：</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2018/01/07/--SpringMVC配置文件解析（五）/" data-id="cjc4i2ng50000dobzp31u641d" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post---SpringMVC配置文件的解析(二)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/07/--SpringMVC配置文件的解析(二)/" class="article-date">
  <time datetime="2018-01-06T18:59:09.977Z" itemprop="datePublished">2018-01-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SpringMVC/">SpringMVC</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/07/--SpringMVC配置文件的解析(二)/">SpringMVC配置文件的解析(二)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>上一篇我们已经将配置文件中的bean节点的注册化和实例化讲解了。接下来我们来看下下面这种扩展节点是什么解析的。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-pacakge</span>=<span class="string">""</span>  /&gt;</span></span><br></pre></td></tr></table></figure>
<p>在Spring的配置节点中分为两种，一种就是bean，import这种的原生节点（个人臆造），另一种就是上面举例的这种扩展节点。还记得我们讲解解析bean节点的代码吗。</p>
<p>将目光投向</p>
<p>DefaultBeanDefinitionDocumentReader的parseBeanDefinitions(root, this.delegate);方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">		NodeList nl = root.getChildNodes();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">			Node node = nl.item(i);</span><br><span class="line">			<span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">				Element ele = (Element) node;</span><br><span class="line">				<span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">				<span class="comment">//解析原生节点，bean import等</span></span><br><span class="line">                     parseDefaultElement(ele, delegate);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">                     <span class="comment">//解析拓展节点</span></span><br><span class="line">					delegate.parseCustomElement(ele);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		delegate.parseCustomElement(root);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码并不难理解，就是解析节点，我们分析bean的解析注册时，走的是                  parseDefaultElement(ele, delegate);</p>
<p>那么到了拓展节点，自然就是走                    delegate.parseCustomElement(ele);了。</p>
<p>我们就以这个方法为切入点来分析。</p>
<h3 id="节点的解析"><a href="#节点的解析" class="headerlink" title="\节点的解析"></a>\<context:component-scan base-pacakge="">节点的解析</context:component-scan></h3><p>delegate.parseCustomElement(ele);</p>
<p>这里的delegate是一个BeanDefinitionParserDelegate实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parseCustomElement</span><span class="params">(Element ele)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> parseCustomElement(ele, <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parseCustomElement</span><span class="params">(Element ele, BeanDefinition containingBd)</span> </span>&#123;</span><br><span class="line">		String namespaceUri = getNamespaceURI(ele);</span><br><span class="line">      <span class="comment">//得到handler</span></span><br><span class="line">		NamespaceHandler handler = <span class="keyword">this</span>.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</span><br><span class="line">		<span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">			error(<span class="string">"Unable to locate Spring NamespaceHandler for XML schema namespace ["</span> + namespaceUri + <span class="string">"]"</span>, ele);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> handler.parse(ele, <span class="keyword">new</span> ParserContext(<span class="keyword">this</span>.readerContext, <span class="keyword">this</span>, containingBd));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法代码行数很少：</p>
<p>1.先得到NamespaceHandler实例</p>
<p>2.使用这个实例来解析扩展元素。</p>
<p>我们先看我们这个要得到的NamespaceHandler实例</p>
<p> NamespaceHandler在这里到底起到了什么作用，这个实例又是根据什么得来的呢？           </p>
<p>首先通过Element的NameSpace得到相应的命名空间。（这个属于XML的知识啦）</p>
<p>然后根据不同的Namespace获取对应的NamespaceHandler，这个是怎么匹配上的呢，是因为我们在Beans标签配置了命名空间，然后就可以配置对应的标签，解析标签时，我们就有相应命名空间所对应的NamespaceHandler来解析。</p>
<p>我们回想下我们编写Spring的配置文件时，都需要在Beans标签上配置命名空间。比如我们的配置文件就有如下配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/context/spring-context-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd"</span> <span class="attr">default-autowire</span>=<span class="string">"byName"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中我们就看到有context标签。这个就对应了ContextNamespaceHandler。</p>
<p>这个ContextNamespaceHandler是NamespaceHandlerSupport的直接子类（NamespaceHandlerSupport直接实现了NamespaceHandler接口）。我们捎带手的来看下这个类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		registerBeanDefinitionParser(<span class="string">"property-placeholder"</span>, <span class="keyword">new</span> PropertyPlaceholderBeanDefinitionParser());</span><br><span class="line">		registerBeanDefinitionParser(<span class="string">"property-override"</span>, <span class="keyword">new</span> PropertyOverrideBeanDefinitionParser());</span><br><span class="line">		registerBeanDefinitionParser(<span class="string">"annotation-config"</span>, <span class="keyword">new</span> AnnotationConfigBeanDefinitionParser());</span><br><span class="line">		registerBeanDefinitionParser(<span class="string">"component-scan"</span>, <span class="keyword">new</span> ComponentScanBeanDefinitionParser());</span><br><span class="line">		registerBeanDefinitionParser(<span class="string">"load-time-weaver"</span>, <span class="keyword">new</span> LoadTimeWeaverBeanDefinitionParser());</span><br><span class="line">		registerBeanDefinitionParser(<span class="string">"spring-configured"</span>, <span class="keyword">new</span> SpringConfiguredBeanDefinitionParser());</span><br><span class="line">		registerBeanDefinitionParser(<span class="string">"mbean-export"</span>, <span class="keyword">new</span> MBeanExportBeanDefinitionParser());</span><br><span class="line">		registerBeanDefinitionParser(<span class="string">"mbean-server"</span>, <span class="keyword">new</span> MBeanServerBeanDefinitionParser());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到这个类就是注册了一些BeanDefinitionParser，其中就包括\<context:component-scan>节点对应的ComponentScanBeanDefinitionParser()</context:component-scan></p>
<p>以\<context:component-scan>节点为例，我们已经在第一步里得到了ContextNamespaceHandler实例。</context:component-scan></p>
<p>接下来便来到第二步，去调用handler.parse()方法。</p>
<p>这个方法很明显具体实现是在NamespaceHandlerSupport类中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> findParserForElement(element, parserContext).parse(element, parserContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> BeanDefinitionParser <span class="title">findParserForElement</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">	String localName = parserContext.getDelegate().getLocalName(element);</span><br><span class="line">	BeanDefinitionParser parser = <span class="keyword">this</span>.parsers.get(localName);</span><br><span class="line">	<span class="keyword">if</span> (parser == <span class="keyword">null</span>) &#123;</span><br><span class="line">		parserContext.getReaderContext().fatal(</span><br><span class="line">				<span class="string">"Cannot locate BeanDefinitionParser for element ["</span> + localName + <span class="string">"]"</span>, element);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> parser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们通过findParserForElement来找到对应的BeanDefinitionParser,很显然这里是ComponentScanBeanDefinitionParser实例，这个实例的注入时机已经在上面说明了。</p>
<p>然后再调用ComponentScanBeanDefinitionParser的parse(element, parserContext);方法来进行解析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">		String basePackage = element.getAttribute(BASE_PACKAGE_ATTRIBUTE);</span><br><span class="line">		basePackage = parserContext.getReaderContext().getEnvironment().resolvePlaceholders(basePackage);</span><br><span class="line">      <span class="comment">//先得到basepacakge,可能有多个</span></span><br><span class="line">		String[] basePackages = StringUtils.tokenizeToStringArray(basePackage,</span><br><span class="line">				ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Actually scan for bean definitions and register them.</span></span><br><span class="line">		ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element);</span><br><span class="line">		Set&lt;BeanDefinitionHolder&gt; beanDefinitions = scanner.doScan(basePackages);</span><br><span class="line">		registerComponents(parserContext.getReaderContext(), beanDefinitions, element);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>还记得我们首次使用\<context:component-scan>节点的时候，文档告诉我们这个节点的作用吗？</context:component-scan></p>
<p>使用这个节点的标配是指定他的base-package=”xxxx”这个属性。一旦指定了这个base-package就意味着这个包下面的所有类都会被扫描，然后会将带有@Component,@Controller,@Service,@Respository的类都会被注册到Spring容器中，而这个功能的实现就是靠的上面的这个方法。这里多说一句，@Component是通用注解，而后面的三个注解是子注解，将各种功能的Bean分类，不信你去看这几个注解的源码，你会发现，后面的三个注解都被@Component标注了。</p>
<p>我们来分析一下这个方法。</p>
<p>   （1）获取context:component-scan 配置的属性base-package的值，然后放到数组。</p>
<pre><code>（2）创建扫描对应包下的class和jar文件的对象ClassPathBeanDefinitionScanner ，由这个类来实现扫描包下的class和jar文件并把注解的Bean包装成BeanDefinition。

（3）BeanDefinition注册到Bean工厂。
</code></pre><p> 其中扫描的操作是由ClassPathBeanDefinitionScanner的doScan方法完成的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">	Assert.notEmpty(basePackages, <span class="string">"At least one base package must be specified"</span>);</span><br><span class="line">     <span class="comment">//在这里终于看到了我们很熟悉的BeanDefinitionHolder了，这里新建了一个Set集合，为什么是Set，不允许重复元素呀，看到这里，在看看方法的返回类型，我们就能知道下面的代码的作用啦，其实就是得到相应的BeanDefinitionHolder集合，那么具体怎么得到的呢，我们需要继续往下看。</span></span><br><span class="line">	Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> LinkedHashSet&lt;BeanDefinitionHolder&gt;();</span><br><span class="line">	<span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">		Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">		<span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line">			ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">			candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">			String beanName = <span class="keyword">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="keyword">this</span>.registry);</span><br><span class="line">			<span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">				postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">				AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">				BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(candidate, beanName);</span><br><span class="line">				definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">				beanDefinitions.add(definitionHolder);</span><br><span class="line">				registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.新建一个BeanDefinitionHolder集合，看到这里，在看看方法的返回类型，我们就能知道下面的代码的作用啦，其实就是得到相应的BeanDefinitionHolder集合，那么具体怎么得到的呢，我们需要继续往下看。</p>
<p>2.调用父类ClassPathScanningCandidateComponentProvider的findCandidateComponents方法扫描包并且得到BeanDefinitionHolder集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;BeanDefinition&gt; <span class="title">findCandidateComponents</span><span class="params">(String basePackage)</span> </span>&#123;</span><br><span class="line">		Set&lt;BeanDefinition&gt; candidates = <span class="keyword">new</span> LinkedHashSet&lt;BeanDefinition&gt;();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//base-package中的值替换为classpath*:cn/test/**/*.class  </span></span><br><span class="line"></span><br><span class="line">			String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +</span><br><span class="line">					resolveBasePackage(basePackage) + <span class="string">"/"</span> + <span class="keyword">this</span>.resourcePattern;</span><br><span class="line">                     <span class="comment">//获取所有base-package下的资源  </span></span><br><span class="line"></span><br><span class="line">			Resource[] resources = <span class="keyword">this</span>.resourcePatternResolver.getResources(packageSearchPath);</span><br><span class="line">			<span class="keyword">boolean</span> traceEnabled = logger.isTraceEnabled();</span><br><span class="line">			<span class="keyword">boolean</span> debugEnabled = logger.isDebugEnabled();</span><br><span class="line">			<span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">				<span class="keyword">if</span> (traceEnabled) &#123;</span><br><span class="line">					logger.trace(<span class="string">"Scanning "</span> + resource);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (resource.isReadable()) &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						MetadataReader metadataReader = <span class="keyword">this</span>.metadataReaderFactory.getMetadataReader(resource);</span><br><span class="line">                                                                        <span class="comment">//对context:exclude-filter进行过滤  </span></span><br><span class="line"></span><br><span class="line">						<span class="keyword">if</span> (isCandidateComponent(metadataReader)) &#123;</span><br><span class="line">                                                    <span class="comment">//包装BeanDefinition  </span></span><br><span class="line"></span><br><span class="line">							ScannedGenericBeanDefinition sbd = <span class="keyword">new</span> ScannedGenericBeanDefinition(metadataReader);</span><br><span class="line">							sbd.setResource(resource);</span><br><span class="line">							sbd.setSource(resource);</span><br><span class="line"></span><br><span class="line">							<span class="keyword">if</span> (isCandidateComponent(sbd)) &#123;</span><br><span class="line">								<span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">									logger.debug(<span class="string">"Identified candidate component class: "</span> + resource);</span><br><span class="line">								&#125;</span><br><span class="line">								candidates.add(sbd);</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">else</span> &#123;</span><br><span class="line">								<span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">									logger.debug(<span class="string">"Ignored because not a concrete top-level class: "</span> + resource);</span><br><span class="line">								&#125;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span> &#123;</span><br><span class="line">							<span class="keyword">if</span> (traceEnabled) &#123;</span><br><span class="line">								logger.trace(<span class="string">"Ignored because not matching any filter: "</span> + resource);</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">								<span class="string">"Failed to read candidate component class: "</span> + resource, ex);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (traceEnabled) &#123;</span><br><span class="line">						logger.trace(<span class="string">"Ignored because not readable: "</span> + resource);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"I/O failure during classpath scanning"</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> candidates;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>  (1)先根据context:component-scan 中属性的base-package=”cn.test”配置转换为classpath<em>:cn/test/**/</em>.class，并扫描对应下的class和jar文件并获取类对应的路径，返回Resources</p>
<pre><code> (2)根据\&lt;context:exclude-filter&gt;指定的不扫描包，\&lt;context:exclude-filter&gt;指定的扫描包配置进行过滤不包含的包对应下的class和jar。

（3）封装成BeanDefinition放到队列里。
</code></pre><p>我们通过findCandidateComponents得到了BeanDefinition集合，接下来我们就需要将Bean注册到BeanFactory中了，也就是注册到Spring容器中了。</p>
<p>3.通过registerBeanDefinition将Bean注册到BeanFactory工厂中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">	BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, registry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register bean definition under primary name.</span></span><br><span class="line">	String beanName = definitionHolder.getBeanName();</span><br><span class="line">	registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register aliases for bean name, if any.</span></span><br><span class="line">	String[] aliases = definitionHolder.getAliases();</span><br><span class="line">	<span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">			registry.registerAlias(beanName, alias);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到这里就不用再分析了吧，到了这里和之前讲解bean节点的注入初始化的步骤都是一样的了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2018/01/07/--SpringMVC配置文件的解析(二)/" data-id="cjc3psf260003vcbzd40149sm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CAS/">CAS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java-WEB/">Java WEB</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaWEB/">JavaWEB</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java基础/">Java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mybatis/">Mybatis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringMVC/">SpringMVC</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js-css/">js&&css</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/02/06/Spring事务实现的四种方式/">Spring事务实现之编程式事务</a>
          </li>
        
          <li>
            <a href="/2018/02/06/Spring事务管理/">Spring事务管理</a>
          </li>
        
          <li>
            <a href="/2018/02/05/CAS简单实例/">CAS简单实例</a>
          </li>
        
          <li>
            <a href="/2018/02/05/CAS/">CAS</a>
          </li>
        
          <li>
            <a href="/2018/02/05/数据库基础知识/">数据库基础知识</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>