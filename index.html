<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>迷途书童的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="厚积薄发">
<meta property="og:type" content="website">
<meta property="og:title" content="迷途书童的博客">
<meta property="og:url" content="https://cong96.github.io/index.html">
<meta property="og:site_name" content="迷途书童的博客">
<meta property="og:description" content="厚积薄发">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="迷途书童的博客">
<meta name="twitter:description" content="厚积薄发">
  
    <link rel="alternate" href="/atom.xml" title="迷途书童的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">迷途书童的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">一天进步一点</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://cong96.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Spring事务实现的四种方式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/06/Spring事务实现的四种方式/" class="article-date">
  <time datetime="2018-02-06T15:16:15.324Z" itemprop="datePublished">2018-02-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/06/Spring事务实现的四种方式/">Spring事务实现之编程式事务</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>###编程式事务（TranscationTemplate）</p>
<p>废话不多说，直接看配置文件。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span> <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans/spring-beans-3.1.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/context/spring-context-3.1.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.1.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.1.xsd"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.wangcc.transcation.template"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 引入配置文件 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"propertyConfigurer"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"location"</span> <span class="attr">value</span>=<span class="string">"classpath:jdbc.properties"</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"ignoreUnresolvablePlaceholders"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span> </span><br><span class="line">         <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line">         <span class="comment">&lt;!-- 配置数据源 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span></span></span><br><span class="line"><span class="tag">		<span class="attr">init-method</span>=<span class="string">"init"</span> <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"$&#123;driver&#125;"</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;url&#125;"</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;username&#125;"</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;password&#125;"</span> /&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 初始化连接大小 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialSize"</span> <span class="attr">value</span>=<span class="string">"$&#123;initialSize&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 连接池最大数量 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxActive"</span> <span class="attr">value</span>=<span class="string">"$&#123;maxActive&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 连接池最大空闲 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxIdle"</span> <span class="attr">value</span>=<span class="string">"$&#123;maxIdle&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 连接池最小空闲 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minIdle"</span> <span class="attr">value</span>=<span class="string">"$&#123;minIdle&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 获取连接最大等待时间 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxWait"</span> <span class="attr">value</span>=<span class="string">"$&#123;maxWait&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">		<span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">		Druid内置提供一个StatFilter，用于统计监控信息。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		StatFilter的别名是stat，这个别名映射配置信息保存在:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		druid-xxx.jar!/META-INF/druid-filter.properties。</span></span><br><span class="line"><span class="comment">		在spring中使用别名配置方式如下</span></span><br><span class="line"><span class="comment">		 --&gt;</span></span><br><span class="line">		     <span class="comment">&lt;!-- 配置监控统计拦截的filters，去掉后监控界面sql无法统计 --&gt;</span>  </span><br><span class="line">		 </span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"filters"</span> <span class="attr">value</span>=<span class="string">"stat"</span> /&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"timeBetweenEvictionRunsMillis"</span> <span class="attr">value</span>=<span class="string">"3000"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minEvictableIdleTimeMillis"</span> <span class="attr">value</span>=<span class="string">"300000"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"validationQuery"</span> <span class="attr">value</span>=<span class="string">"SELECT 'x'"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testWhileIdle"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testOnBorrow"</span> <span class="attr">value</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testOnReturn"</span> <span class="attr">value</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"poolPreparedStatements"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxPoolPreparedStatementPerConnectionSize"</span></span></span><br><span class="line"><span class="tag">			<span class="attr">value</span>=<span class="string">"20"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- mybatis配置 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 自动扫描mapping.xml文件 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperLocations"</span> <span class="attr">value</span>=<span class="string">"classpath*:mapper/*.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:mybatis-config.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- com.ulic.gpolicyutils --&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"typeAliasesPackage"</span> <span class="attr">value</span>=<span class="string">"com.wangcc.transcation.template.entity"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt;</span>  </span><br><span class="line">    </span><br><span class="line">      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"com.wangcc.transcation.template.dao"</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactoryBeanName"</span> <span class="attr">value</span>=<span class="string">"sqlSessionFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line">      <span class="comment">&lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.transaction.support.TransactionTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"transactionManager"</span> <span class="attr">ref</span>=<span class="string">"transactionManager"</span>/&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--ISOLATION_DEFAULT 表示由使用的数据库决定  --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"isolationLevelName"</span> <span class="attr">value</span>=<span class="string">"ISOLATION_DEFAULT"</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"propagationBehaviorName"</span> <span class="attr">value</span>=<span class="string">"PROPAGATION_REQUIRED"</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在进行事务管理之前的配置可以忽略不看，就是进行了数据源以及Spring与Mybatis结合的一些配置。</p>
<p>我们在配置TransactionManager的时候注入了dataSource数据源属性。</p>
<p>然后在配置TransactionTemplate的时候又将TransactionManager注入其中，并且配置了隔离级别与事务传播级别。注意，这两个关键的参数是在TransactionTemplate中指定的。</p>
<p>那我们很明显的可以知道TransactionTemplate这个类就是我们实现编程式事务关键的核心类。</p>
<p>我们来看下我们是怎么使用调用这个类的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> TransactionTemplate template;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String inUserName, String outUserName, Double money)</span> </span>&#123;</span><br><span class="line">		template.execute(<span class="keyword">new</span> TransactionCallbackWithoutResult() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doInTransactionWithoutResult</span><span class="params">(TransactionStatus transactionStatus)</span> </span>&#123;</span><br><span class="line">				accountDao.reduceMoney(outUserName, money);</span><br><span class="line">				<span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">				accountDao.addMoney(inUserName, money);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非常简单，当我们想要对一个方法使用编程式的事务的时候，我们只需要调用TransactionTemplate的execute方法即可实现编程式的事务，非常的简单，但是你也可以发现，耦合度非常非常的高，这也是为什么我们之后大多会使用切面来声明事务的原因。</p>
<p>要实现编程式的事务，只需要调用execute方法，然后使用一个匿名类来构造execute方法的入参，入参类型是TransactionCallback，接着将我们具体的方法内容放置在该类型中的doInTransaction方法中。但是你看上述的代码，并不是实现了doInTransaction方法呀，别着急TransactionCallbackWithoutResult是TransactionCallback的一个子类，doInTransactionWithoutResult是该类重写的doInTransaction调用的一个方法。</p>
<p>编程式的事务实现起来非常简单，但是很显然耦合度过高，已不推荐使用，也应该是实现Spring事务的唯一一种没有使用到代理模式思想的实现方式。而其他的所谓的三种实现Spring事务的方法，核心都是动态代理，当然你也可以说是拦截器，但是归根节点还是动态代理。</p>
<h3 id="编程式事务源码解析"><a href="#编程式事务源码解析" class="headerlink" title="编程式事务源码解析"></a>编程式事务源码解析</h3><p>看完了如何实现编程式事务，我们就来简单分析下编程式事务实现的原理把。</p>
<p>显然我们分析的核心肯定是TransactionTemplate类，我们先看这个类的声明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionTemplate</span> <span class="keyword">extends</span> <span class="title">DefaultTransactionDefinition</span></span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">TransactionOperations</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<p>我们发现他继承了DefaultTransactionDefinition这个类</p>
<p>实现了InitializingBean接口，这个接口已经很熟悉了，会在创建bean之后执行他的afterPropertiesSet方法。</p>
<p>还实现了TransactionOperations接口，正是这个接口，定义了我们刚才多次提到的execute方法。</p>
<ul>
<li><strong>DefaultTransactionDefinition</strong></li>
</ul>
<p>我们先来看看他的父类DefaultTransactionDefinition</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultTransactionDefinition</span> <span class="keyword">implements</span> <span class="title">TransactionDefinition</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFIX_PROPAGATION = <span class="string">"PROPAGATION_"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Prefix for the isolation constants defined in TransactionDefinition */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFIX_ISOLATION = <span class="string">"ISOLATION_"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Prefix for transaction timeout values in description strings */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFIX_TIMEOUT = <span class="string">"timeout_"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Marker for read-only transactions in description strings */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String READ_ONLY_MARKER = <span class="string">"readOnly"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Constants instance for TransactionDefinition */</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> Constants constants = <span class="keyword">new</span> Constants(TransactionDefinition.class);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> propagationBehavior = PROPAGATION_REQUIRED;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> isolationLevel = ISOLATION_DEFAULT;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> timeout = TIMEOUT_DEFAULT;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> readOnly = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="comment">//....</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现他给出了默认的isolationLevel（事务隔离级别），propagationBehavior（事务传播属性），timeout（超时时间），readOnly(是否只读)等等。</p>
<p>而所有的事务隔离级别，事务传播属性值的定义都在DefaultTransactionDefinition实现的接口TransactionDefinition中。</p>
<p>我们在DefaultTransactionDefinition中看到有isolationLevel和propagationBehavior这两个Fields。所以这个时候我们就明白了在配置文件中指定的事务隔离级别和事务传播属性就是DefaultTransactionDefinition中的这两个属性。</p>
<p>关于父类DefaultTransactionDefinition的介绍就到这里，<strong>主要就是给出了默认的事务隔离级别和事务传播属性，并且暴露出属性和给出值让用户可以自定义事务隔离级别和事务传播属性等。</strong></p>
<ul>
<li><p><strong>InitializingBean</strong></p>
<p>TransactionTemplate实现了InitializingBean接口，那我们就有必要看看实现这个接口的目的是什么。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.transactionManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Property 'transactionManager' is required"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法很简单，目的也一目了然，就是在创建这个Bean之后，一定要向其中注入了transactionManager属性，否则就要报错，他必须有transactionManager属性，因为真正去实现事务的类还是在transactionManager中。</p>
</li>
<li><p><strong>TransactionOperations</strong></p>
<p>这个接口定义了execute方法。</p>
<p>也是我们在程序中直接调用的方法，我们需要重点关注。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(TransactionCallback&lt;T&gt; action)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.transactionManager <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager) &#123;</span><br><span class="line">		<span class="keyword">return</span> ((CallbackPreferringPlatformTransactionManager) <span class="keyword">this</span>.transactionManager).execute(<span class="keyword">this</span>, action);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//得到事务</span></span><br><span class="line">		TransactionStatus status = <span class="keyword">this</span>.transactionManager.getTransaction(<span class="keyword">this</span>);</span><br><span class="line">		T result;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">//开启事务，调用回调方法</span></span><br><span class="line">			result = action.doInTransaction(status); <span class="comment">//即我们具体业务逻辑实现的地方</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">			<span class="comment">// Transactional code threw application exception -&gt; rollback</span></span><br><span class="line">             <span class="comment">//如果是RuntimeException异常，回顾</span></span><br><span class="line">			rollbackOnException(status, ex);</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Error err) &#123;</span><br><span class="line">			<span class="comment">// Transactional code threw error -&gt; rollback</span></span><br><span class="line">             <span class="comment">//如果是Error 虚拟机产生的异常，回滚</span></span><br><span class="line">			rollbackOnException(status, err);</span><br><span class="line">			<span class="keyword">throw</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">			<span class="comment">// Transactional code threw unexpected exception -&gt; rollback</span></span><br><span class="line">			rollbackOnException(status, ex);</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(ex, <span class="string">"TransactionCallback threw undeclared checked exception"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">         <span class="comment">//提交事务</span></span><br><span class="line">		<span class="keyword">this</span>.transactionManager.commit(status);</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2018/02/06/Spring事务实现的四种方式/" data-id="cjdbsim8s0000fcbz48l0cw7u" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Spring事务管理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/06/Spring事务管理/" class="article-date">
  <time datetime="2018-02-06T15:16:15.323Z" itemprop="datePublished">2018-02-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/06/Spring事务管理/">Spring事务管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="数据库事务四大特性"><a href="#数据库事务四大特性" class="headerlink" title="数据库事务四大特性"></a>数据库事务四大特性</h3><ul>
<li><p><strong>原子性（Atomicity）</strong></p>
<p>​       原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，这和前面两篇博客介绍事务的功能是一样的概念，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p>
</li>
<li><p><strong>一致性（Consistency）</strong></p>
<p>　    一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。</p>
<p>　　拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p>
</li>
<li><p><strong>隔离性（Isolation）</strong></p>
<p>　    隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p>
<p>　　即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</p>
<p>　　 关于事务的隔离性数据库提供了多种隔离级别，稍后会介绍到。</p>
</li>
<li><p><strong>持久性（Durability）</strong></p>
<p>   　持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>
<p>　　例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。</p>
</li>
</ul>
<p>我们重点介绍事务的隔离性</p>
<h3 id="不考虑事务的隔离性会引发的问题"><a href="#不考虑事务的隔离性会引发的问题" class="headerlink" title="不考虑事务的隔离性会引发的问题"></a>不考虑事务的隔离性会引发的问题</h3><p>当多个线程都开启事务操作数据库中的数据时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性，如果部考虑事务的隔离性，将会引发下列问题。</p>
<ul>
<li><p><strong>脏读（事务没提交，提前读取）</strong></p>
<p>脏读就是指当一个事务正在访问数据，并且对数据进行了修改，<strong>而这种修改还没有提交到数据库中</strong>，这时，另外一个事务也访问这个数据，然后使用了这个数据。</p>
</li>
<li><p><strong>不可重复读（两次读的不一致）</strong></p>
<p>是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。例如，一个编辑人员两次读取同一文档，但在两次读取之间，作者重写了该文档。当编辑人员第二次读取文档时，文档已更改。原始读取不可重复。如果只有在作者全部完成编写后编辑人员才可以读取文档，则可以避免该问题。</p>
</li>
<li><p><strong>幻读</strong></p>
<p>事务在操作过程中进行两次查询，第二次查询的结果包含了第一次查询中未出现的数据或者缺少了第一次查询中出现的数据（这里并不要求两次查询的SQL语句相同）。这是因为在两次查询过程中有另外一个事务插入数据造成的。</p>
<p>也可以这样理解：这是当事务不是独立执行时发生的一种现象，例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。</p>
<p><strong>幻读和不可重复读都是读取了另一条已经提交的事务（这点与脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。</strong></p>
</li>
<li><p><strong>丢失更新</strong></p>
<ul>
<li><p><strong>回滚丢失</strong></p>
<p>当2个事务更新相同的数据源，如果第一个事务被提交，而另外一个事务却被撤销，那么会连同第一个事务所做的跟新也被撤销。也就是说第一个事务做的跟新丢失了。（这一点其实是非常疑惑的，回去google下把，在百度里实在找不到答案）</p>
</li>
<li><p><strong>覆盖丢失</strong></p>
<p>他和不可重复读本质上是同一类并发问题，通常他被看做不可重复读的特例：当2个或这个多个事务查询同样的记录然后各自基于最初的查询结果更新该行时，会造成第二类丢失更新。因为每个事务都不知道不知道其他事务的存在，最后一个事务对记录做的修改将覆盖其他事务对该记录做的已提交的更新。</p>
</li>
</ul>
</li>
</ul>
<h3 id="数据库事务隔离级别"><a href="#数据库事务隔离级别" class="headerlink" title="数据库事务隔离级别"></a>数据库事务隔离级别</h3><ul>
<li><p><strong>Read uncommitted（未授权读取、读未提交）</strong></p>
<p>如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“排他写锁”实现。可能出现脏读,事务B读取到了事务A未提交的数据。</p>
</li>
<li><p><strong>Read committed(授权读取、读提交)</strong></p>
<p>读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。</p>
<p>该隔离级别避免了脏读，但是却可能出现不可重复读。事务A事先读取了数据，事务B紧接了更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变。(我们JDK中读写锁的设计就是对应这一层把)</p>
</li>
<li><p><strong>Repeatable read(可重复读取)</strong></p>
<p>读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。</p>
<p>避免了不可重复读取和脏读，但是有时可能出现幻读。这可以通过“共享读锁”和“排他写锁”实现。</p>
</li>
<li><p><strong>Serializable(序列化)</strong></p>
<p>提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，但不能并发执行。如果仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。</p>
<p>序列化是最高的事务隔离级别，同时代价也花费最高，性能很低，一般很少使用，在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻读。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>ISOLATION LEVEL</th>
<th>dirty reads</th>
<th>non-repeatble reads</th>
<th>phantom reads</th>
</tr>
</thead>
<tbody>
<tr>
<td>Read Uncommitted</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>READ COMMITTED</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>REPEATABLE READ</td>
<td>N</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>Serializable</td>
<td>N</td>
<td>N</td>
<td>Y</td>
</tr>
</tbody>
</table>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed。它能够避免脏读取，而且具有较好的并发性能。尽管它会导致不可重复读、幻读和第二类丢失更新这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制。</strong></p>
<p>共享锁：共享锁和共享锁可以共存。<br>排他锁：排他锁和所有锁都不能共存。</p>
<p>乐观锁和悲观锁不是数据库中真正存在的锁，只是人们在解决更新丢失时的不同的解决方案，体现的是人们看待事务的态度。<br>悲观锁：认为每一条sql语句都会出现更新丢失的情况<br>隔离级别不设置为Serializable，防止效率过低。<br>在查询时手动加上排他锁。<br>如果数据库中的数据查询比较多而更新比较少的话，悲观锁将会导致效率低下。</p>
<p>乐观锁：认为每一条sql语句都不会出现更新丢失的情况<br>在表中增加一个version字段，在更新数据库记录是将version加一，从而在修改数据时通过检查版本号是否改变判断出当前更新基于的查询是否已经是过时的版本。<br>如果数据库中数据的修改比较多，更新失败的次数会比较多，程序需要多次重复执行更新操作</p>
<p><strong>共享锁(S锁)</strong></p>
<ul>
<li>用于只读操作(SELECT)，锁定共享的资源。共享锁不会阻止其他用户读，但是阻止其他的用户写和修改。</li>
</ul>
<p><strong>更新锁(U锁)</strong></p>
<ul>
<li>用于可更新的资源中。防止当多个会话在读取、锁定以及随后可能进行的资源更新时发生常见形式的死锁。</li>
</ul>
<p><strong>独占锁(X锁，也叫排他锁)</strong></p>
<ul>
<li>一次只能有一个独占锁用在一个资源上，并且阻止其他所有的锁包括共享缩。写是独占锁，可以有效的防止“脏读”。</li>
</ul>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p><strong>数据库创建索引能够大大提高系统的性能。</strong></p>
<ul>
<li>通过创建唯一性的索引，可以保证数据库表中每一行数据的唯一性。</li>
<li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li>
<li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li>
<li>在使用分组和排序子句进行数据检索时，同样可以显著的减少查询中分组和排序的时间。</li>
<li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li>
</ul>
<p><strong>增加索引也有许多不利的方面。</strong></p>
<ul>
<li>创建索引和维护索引需要消耗时间，这种时间随着数量的增加而增加。</li>
<li>索引需要占物理空间，除了数据表占据数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要额空间就会更大。</li>
<li>当对表中的数据进行增加，删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li>
</ul>
<p><strong>应该对如下的列建立索引</strong></p>
<ul>
<li>在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构。</li>
<li>在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度。</li>
<li>在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的。</li>
<li>在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</li>
<li>在经常使用在where子句中的列上面创建索引，加快条件的判断速度。</li>
</ul>
<p><strong>有些列不应该创建索引</strong></p>
<ul>
<li>在查询中很少使用或者作为参考的列不应该创建索引。</li>
<li>对于那些只有很少数据值的列也不应该增加索引（比如性别，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度）。</li>
<li>对于那些定义为text，image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。</li>
<li>当修改性能远远大于检索性能时，不应该创建索引，因为修改性能和检索性能是矛盾的。</li>
</ul>
<p><strong>创建索引的方法：直接创建和间接创建（在表中定义主键约束或者唯一性约束时，同时也创建了索引）。</strong></p>
<p><strong>索引的特征：</strong></p>
<ul>
<li><strong>唯一性</strong>索引保证在索引列中的全部数据是唯一的，不会包含冗余数据。</li>
<li><strong>复合</strong>索引就是一个索引创建在两个列或者多个列上。可以减少在一个表中所创建的索引数量。</li>
</ul>
<h3 id="Spring事务隔离级别"><a href="#Spring事务隔离级别" class="headerlink" title="Spring事务隔离级别"></a>Spring事务隔离级别</h3><table>
<thead>
<tr>
<th>Isolation Level</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>ISOLATION_ DEFAULT</td>
<td>使用数据库设置的隔离级别 ( 默认 ) ，由 DBA 默认的设置来决定隔离级别 。至于数据库的默认隔离级别，如果DBA没有设置的话，MySql默认为 REPEATABLE_READ，Oracle和Sql Server默认为 READ_COMMITTED</td>
</tr>
<tr>
<td>ISOLATION_  READ_UNCOMMITTED</td>
<td>会出现脏读、不可重复读、幻读 ( 隔离级别最低，并发性能高 )</td>
</tr>
<tr>
<td>ISOLATION_   READ_COMMITTED</td>
<td>会出现不可重复读、幻读问题（锁定正在读取的行）</td>
</tr>
<tr>
<td>ISOLATION_    REPEATABLE_READ</td>
<td>会出幻读（锁定所读取的所有行）</td>
</tr>
<tr>
<td>ISOLATION_     SERIALIZABLE</td>
<td>保证所有的情况不会发生（锁表）</td>
</tr>
</tbody>
</table>
<p>我们一般在使用Spring事务配置的时候直接使用默认的ISOLATION_ DEFAULT ，当然在特殊的场景下，我们需要做出相应的调整。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2018/02/06/Spring事务管理/" data-id="cjdbsim920001fcbzb0xvqgf9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-使用代理代理技术完成Spring事务管理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/06/使用代理代理技术完成Spring事务管理/" class="article-date">
  <time datetime="2018-02-06T15:16:15.321Z" itemprop="datePublished">2018-02-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/06/使用代理代理技术完成Spring事务管理/">Spring事务管理之AOP方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="使用AOP完成Spring事务管理"><a href="#使用AOP完成Spring事务管理" class="headerlink" title="使用AOP完成Spring事务管理"></a>使用AOP完成Spring事务管理</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"get*"</span> <span class="attr">read-only</span>=<span class="string">"true"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> /&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- rollback-for只对检查型异常适用 这里一般为自定义的Exception 继承Exception父类 因为RuntimeException和Error，Spring默认进行回顾，我们在源码分析中可以看到这一点 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> <span class="attr">rollback-for</span>=<span class="string">"Exception"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 适用切面来添加适用处理的功能 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"execution(* wangcc.service.impl.*.*(..))"</span></span></span><br><span class="line"><span class="tag">		<span class="attr">id</span>=<span class="string">"serviceMethod"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"serviceMethod"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当我们使用AOP完成Spring事务管理的时候，我们在处理业务逻辑的时候只需要关心业务逻辑的处理，而Spring事务会通过动态代理的方式来增强需要使用事务的方法来完成Spring事务。</p>
<h3 id="AOP完成Spring事务管理源码分析"><a href="#AOP完成Spring事务管理源码分析" class="headerlink" title="AOP完成Spring事务管理源码分析"></a>AOP完成Spring事务管理源码分析</h3><h4 id="tx-advice节点的解析"><a href="#tx-advice节点的解析" class="headerlink" title="tx:advice节点的解析"></a>tx:advice节点的解析</h4><p>我们观看上面的XML文件配置，很明显tx:advice这个节点生成的Bean是来完成Spring事务管理功能的，在AOP中充当增强方法处理的作用。而aop：pointcut节点就很明显是指定到底在哪些类的那些方法中执行这个方法增加，即Spring事务管理。</p>
<p>对于AOP，我们已经分析过其源码了，不过当时分析的是aop:pointcut与aop:aspect的组合。而这里aop:aspect换成了aop:advisor。我们知道在分析aop源码的时候aop:aspect节点下的aop:before,aop:after等节点都会传化为AspectJPointcutAdvisor类型的Bean，并且其中包含一个AbstractAspectJAdvice的子类类型的Bean，而且这些子类除了AspectJMethodBeforeAdvice（之后进行了一层封装后实现接口），都直接实现了MethodInterceptor接口，而最后我们需要的就是实现了MethodInterceptor接口的类。</p>
<p>那么我们在分析tx:advice节点的时候，显然可以想象得到他的最终产物也对应着一个Interceptor。</p>
<p>事实也是如此,我们找到解析该节点的类TxAdviceBeanDefinitionParser。找到getBeanClass方法，你会发现BeanClass对应着是TransactionInterceptor，而他也是实现了MethodInterceptor接口的一个类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">protected</span> Class&lt;?&gt; getBeanClass(Element element) &#123;</span><br><span class="line">		<span class="keyword">return</span> TransactionInterceptor.class;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看下TxAdviceBeanDefinitionParser的声明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TxAdviceBeanDefinitionParser</span> <span class="keyword">extends</span> <span class="title">AbstractSingleBeanDefinitionParser</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSingleBeanDefinitionParser</span> <span class="keyword">extends</span> <span class="title">AbstractBeanDefinitionParser</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBeanDefinitionParser</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionParser</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<p>我们可以看到直接实现BeanDefinitionParser接口的是他祖先类AbstractBeanDefinitionParser类。</p>
<ul>
<li><p><strong>parse</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">		AbstractBeanDefinition definition = parseInternal(element, parserContext);</span><br><span class="line">	<span class="comment">//...省略了一坨代码，主要是将得到的Bean定义注册到Spring容器中，并做一些处理。不是关注的重点</span></span><br><span class="line">		<span class="keyword">return</span> definition;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>在parse方法中，重点是parseInternal方法的实现，也就是如何得到Bean定义。而这个方法在AbstractBeanDefinitionParser中是个抽象方法。具体的实现在AbstractSingleBeanDefinitionParser中。</p>
</li>
<li><p><strong>parseInternal</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> AbstractBeanDefinition <span class="title">parseInternal</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">	BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition();</span><br><span class="line">     <span class="comment">//看是否有parent</span></span><br><span class="line">	String parentName = getParentName(element);</span><br><span class="line">	<span class="keyword">if</span> (parentName != <span class="keyword">null</span>) &#123;</span><br><span class="line">		builder.getRawBeanDefinition().setParentName(parentName);</span><br><span class="line">	&#125;</span><br><span class="line">     <span class="comment">//getBeanClass留给子类实现</span></span><br><span class="line">     <span class="comment">//得到该Bean的Class,这里就是之前说的TransactionInterceptor</span></span><br><span class="line">	Class&lt;?&gt; beanClass = getBeanClass(element);</span><br><span class="line">     <span class="comment">//将Class注册到Bean定义中</span></span><br><span class="line">	<span class="keyword">if</span> (beanClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">		builder.getRawBeanDefinition().setBeanClass(beanClass);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//getBeanClassName留给子类实现，但是这里TxAdviceBeanDefinitionParser并没实现</span></span><br><span class="line">		String beanClassName = getBeanClassName(element);</span><br><span class="line">		<span class="keyword">if</span> (beanClassName != <span class="keyword">null</span>) &#123;</span><br><span class="line">			builder.getRawBeanDefinition().setBeanClassName(beanClassName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	builder.getRawBeanDefinition().setSource(parserContext.extractSource(element));</span><br><span class="line">	<span class="keyword">if</span> (parserContext.isNested()) &#123;</span><br><span class="line">		<span class="comment">// Inner bean definition must receive same scope as containing bean.</span></span><br><span class="line">		builder.setScope(parserContext.getContainingBeanDefinition().getScope());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (parserContext.isDefaultLazyInit()) &#123;</span><br><span class="line">		<span class="comment">// Default-lazy-init applies to custom bean definitions as well.</span></span><br><span class="line">		builder.setLazyInit(<span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">     <span class="comment">//对Bean定义进行一系列的参数设置之后，终于来到解析节点，这个方法也是给子类实现的。</span></span><br><span class="line">	doParse(element, parserContext, builder);</span><br><span class="line">	<span class="keyword">return</span> builder.getBeanDefinition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在对Bean定义进行了一系列参数的设置之后，调用doParse对节点进行解析。</p>
<p>​</p>
</li>
</ul>
<ul>
<li><strong>doParse</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doParse</span><span class="params">(Element element, ParserContext parserContext, BeanDefinitionBuilder builder)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//注入transcationManager属性，如果在配置中没有配置transaction-manager属性，那么这时Spring配置文件中，事务管理器的Bean的Id必须是transcationManager。</span></span><br><span class="line">		builder.addPropertyReference(<span class="string">"transactionManager"</span>, TxNamespaceHandler.getTransactionManagerName(element));</span><br><span class="line">	<span class="comment">//得到tx:attributes节点</span></span><br><span class="line">		List&lt;Element&gt; txAttributes = DomUtils.getChildElementsByTagName(element, ATTRIBUTES_ELEMENT);</span><br><span class="line">      <span class="comment">//该节点直接出现一次，如果出现多次，报错</span></span><br><span class="line">		<span class="keyword">if</span> (txAttributes.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">			parserContext.getReaderContext().error(</span><br><span class="line">					<span class="string">"Element &lt;attributes&gt; is allowed at most once inside element &lt;advice&gt;"</span>, element);</span><br><span class="line">		&#125;</span><br><span class="line">      <span class="comment">//如果出现一次，那么就可以开始解析这个节点里的内容了</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (txAttributes.size() == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="comment">// Using attributes source.</span></span><br><span class="line">			Element attributeSourceElement = txAttributes.get(<span class="number">0</span>);</span><br><span class="line">			RootBeanDefinition attributeSourceDefinition = parseAttributeSource(attributeSourceElement, parserContext);</span><br><span class="line">          <span class="comment">//用得到的attributeSourceDefinition注入transactionAttributeSource属性</span></span><br><span class="line">			builder.addPropertyValue(<span class="string">"transactionAttributeSource"</span>, attributeSourceDefinition);</span><br><span class="line">		&#125;</span><br><span class="line">      <span class="comment">//如果没有显式的配置这个节点，还是需要注入transactionAttributeSource属性，这里给出一个默认的AnnotationTransactionAttributeSource</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Assume annotations source.</span></span><br><span class="line">			builder.addPropertyValue(<span class="string">"transactionAttributeSource"</span>,</span><br><span class="line">					<span class="keyword">new</span> RootBeanDefinition(<span class="string">"org.springframework.transaction.annotation.AnnotationTransactionAttributeSource"</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到doParse方法主要就是为TransactionInterceptor这个类注册了两个属性，transactionAttributeSource和transactionManager。</p>
<p>我们再看看当有显式配置tx:attributes节点时对transactionAttributeSource属性的配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RootBeanDefinition attributeSourceDefinition = parseAttributeSource(attributeSourceElement, parserContext);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>parseAttributeSource</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RootBeanDefinition <span class="title">parseAttributeSource</span><span class="params">(Element attrEle, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//得到所有的tx:method节点</span></span><br><span class="line">	List&lt;Element&gt; methods = DomUtils.getChildElementsByTagName(attrEle, METHOD_ELEMENT);</span><br><span class="line">     <span class="comment">//创建一个Map，用来存放TypedStringValue（name属性值的包装类）为key，RuleBasedTransactionAttribute为Value的键值对</span></span><br><span class="line">     <span class="comment">//即每一个method name都对应着相应TransactionAttribute</span></span><br><span class="line">	ManagedMap&lt;TypedStringValue, RuleBasedTransactionAttribute&gt; transactionAttributeMap =</span><br><span class="line">		<span class="keyword">new</span> ManagedMap&lt;TypedStringValue, RuleBasedTransactionAttribute&gt;(methods.size());</span><br><span class="line">	transactionAttributeMap.setSource(parserContext.extractSource(attrEle));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (Element methodEle : methods) &#123;</span><br><span class="line">         <span class="comment">//得到tx:method中name属性的属性值</span></span><br><span class="line">		String name = methodEle.getAttribute(METHOD_NAME_ATTRIBUTE);</span><br><span class="line">         <span class="comment">//将属性值封装成TypedStringValue类型</span></span><br><span class="line">		TypedStringValue nameHolder = <span class="keyword">new</span> TypedStringValue(name);</span><br><span class="line">		nameHolder.setSource(parserContext.extractSource(methodEle));</span><br><span class="line">		</span><br><span class="line">		RuleBasedTransactionAttribute attribute = <span class="keyword">new</span> RuleBasedTransactionAttribute();</span><br><span class="line">		String propagation = methodEle.getAttribute(PROPAGATION_ATTRIBUTE);</span><br><span class="line">		String isolation = methodEle.getAttribute(ISOLATION_ATTRIBUTE);</span><br><span class="line">		String timeout = methodEle.getAttribute(TIMEOUT_ATTRIBUTE);</span><br><span class="line">		String readOnly = methodEle.getAttribute(READ_ONLY_ATTRIBUTE);</span><br><span class="line">		<span class="keyword">if</span> (StringUtils.hasText(propagation)) &#123;</span><br><span class="line">			attribute.setPropagationBehaviorName(RuleBasedTransactionAttribute.PREFIX_PROPAGATION + propagation);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (StringUtils.hasText(isolation)) &#123;</span><br><span class="line">			attribute.setIsolationLevelName(RuleBasedTransactionAttribute.PREFIX_ISOLATION + isolation);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (StringUtils.hasText(timeout)) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				attribute.setTimeout(Integer.parseInt(timeout));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (NumberFormatException ex) &#123;</span><br><span class="line">				parserContext.getReaderContext().error(<span class="string">"Timeout must be an integer value: ["</span> + timeout + <span class="string">"]"</span>, methodEle);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (StringUtils.hasText(readOnly)) &#123;</span><br><span class="line">			attribute.setReadOnly(Boolean.valueOf(methodEle.getAttribute(READ_ONLY_ATTRIBUTE)));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		List&lt;RollbackRuleAttribute&gt; rollbackRules = <span class="keyword">new</span> LinkedList&lt;RollbackRuleAttribute&gt;();</span><br><span class="line">		<span class="keyword">if</span> (methodEle.hasAttribute(ROLLBACK_FOR_ATTRIBUTE)) &#123;</span><br><span class="line">			String rollbackForValue = methodEle.getAttribute(ROLLBACK_FOR_ATTRIBUTE);</span><br><span class="line">			addRollbackRuleAttributesTo(rollbackRules,rollbackForValue);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (methodEle.hasAttribute(NO_ROLLBACK_FOR_ATTRIBUTE)) &#123;</span><br><span class="line">			String noRollbackForValue = methodEle.getAttribute(NO_ROLLBACK_FOR_ATTRIBUTE);</span><br><span class="line">			addNoRollbackRuleAttributesTo(rollbackRules,noRollbackForValue);</span><br><span class="line">		&#125;</span><br><span class="line">		attribute.setRollbackRules(rollbackRules);</span><br><span class="line"></span><br><span class="line">		transactionAttributeMap.put(nameHolder, attribute);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	RootBeanDefinition attributeSourceDefinition = <span class="keyword">new</span> RootBeanDefinition(NameMatchTransactionAttributeSource.class);</span><br><span class="line">	attributeSourceDefinition.setSource(parserContext.extractSource(attrEle));</span><br><span class="line">	attributeSourceDefinition.getPropertyValues().add(<span class="string">"nameMap"</span>, transactionAttributeMap);</span><br><span class="line">	<span class="keyword">return</span> attributeSourceDefinition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法很长，但是并不难理解。</p>
<p>就是如果在tx:method节点中有对Methodname显式的指定事务传播属性，事务级别，只读，超时等属性，就把他加入到RuleBasedTransactionAttribute中。没有显式指定的话就使用默认的。然后将所有的method节点的信息都存入到NameMatchTransactionAttributeSource中。</p>
<p>那么到这里，我们就分析完了tx:advice节点了。</p>
<p><strong>他主要就是创建了类型为TransactionInterceptor的Bean，并且注入了这个Bean的两个属性，transactionAttributeSource和transactionManager。而当有tx:method节点的时候，transactionAttributeSource属性对应的类型是NameMatchTransactionAttributeSource，如果没有，则对应AnnotationTransactionAttributeSource。</strong></p>
<h4 id="aop-config节点的解析"><a href="#aop-config节点的解析" class="headerlink" title="aop:config节点的解析"></a>aop:config节点的解析</h4><p>关于aop:config节点的解析，我们在讲解Spring  AOP实现的时候已经说过了，但是当时讲的是aop:aspect和aop：pointcut的组合，现在我们要讲解aop:pointcut和aop:advisor的组合。</p>
<p>我们直接看到ConfigBeanDefinitionParser中解析节点的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">	CompositeComponentDefinition compositeDef =</span><br><span class="line">			<span class="keyword">new</span> CompositeComponentDefinition(element.getTagName(), parserContext.extractSource(element));</span><br><span class="line">	parserContext.pushContainingComponent(compositeDef);</span><br><span class="line"></span><br><span class="line">	configureAutoProxyCreator(parserContext, element);</span><br><span class="line"></span><br><span class="line">	List&lt;Element&gt; childElts = DomUtils.getChildElements(element);</span><br><span class="line">	<span class="keyword">for</span> (Element elt: childElts) &#123;</span><br><span class="line">		String localName = parserContext.getDelegate().getLocalName(elt);</span><br><span class="line">		<span class="keyword">if</span> (POINTCUT.equals(localName)) &#123;</span><br><span class="line">			parsePointcut(elt, parserContext);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ADVISOR.equals(localName)) &#123;</span><br><span class="line">			parseAdvisor(elt, parserContext);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ASPECT.equals(localName)) &#123;</span><br><span class="line">			parseAspect(elt, parserContext);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	parserContext.popAndRegisterContainingComponent();</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>parseAdvisor</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseAdvisor</span><span class="params">(Element advisorElement, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">		AbstractBeanDefinition advisorDef = createAdvisorBeanDefinition(advisorElement, parserContext);</span><br><span class="line">		String id = advisorElement.getAttribute(ID);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> AdvisorEntry(id));</span><br><span class="line">			String advisorBeanName = id;</span><br><span class="line">			<span class="keyword">if</span> (StringUtils.hasText(advisorBeanName)) &#123;</span><br><span class="line">				parserContext.getRegistry().registerBeanDefinition(advisorBeanName, advisorDef);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				advisorBeanName = parserContext.getReaderContext().registerWithGeneratedName(advisorDef);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			Object pointcut = parsePointcutProperty(advisorElement, parserContext);</span><br><span class="line">			<span class="keyword">if</span> (pointcut <span class="keyword">instanceof</span> BeanDefinition) &#123;</span><br><span class="line">				advisorDef.getPropertyValues().add(POINTCUT, pointcut);</span><br><span class="line">				parserContext.registerComponent(</span><br><span class="line">						<span class="keyword">new</span> AdvisorComponentDefinition(advisorBeanName, advisorDef, (BeanDefinition) pointcut));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (pointcut <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">				advisorDef.getPropertyValues().add(POINTCUT, <span class="keyword">new</span> RuntimeBeanReference((String) pointcut));</span><br><span class="line">				parserContext.registerComponent(</span><br><span class="line">						<span class="keyword">new</span> AdvisorComponentDefinition(advisorBeanName, advisorDef));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">this</span>.parseState.pop();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>方法不难理解，就是将pointcut和advice-ref，也就是之前我们分析的那个节点对应的Bean,TranscationInterceptor关联起来得到DefaultBeanFactoryPointcutAdvisor，然后注入到Spring容器中。</p>
</li>
</ul>
<p>到这里，我们的切面就完成了，然而最重要的是怎么调用我们这个切面。</p>
<h4 id="运用AOP实现的事务管理的调用过程"><a href="#运用AOP实现的事务管理的调用过程" class="headerlink" title="运用AOP实现的事务管理的调用过程"></a>运用AOP实现的事务管理的调用过程</h4><p>具体怎么注册拦截器，怎么创建代理类的过程请看AOP源码解析部分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(<span class="keyword">final</span> MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">	<span class="comment">// Work out the target class: may be &#123;@code null&#125;.</span></span><br><span class="line">	<span class="comment">// The TransactionAttributeSource should be passed the target class</span></span><br><span class="line">	<span class="comment">// as well as the method, which may be from an interface.</span></span><br><span class="line">	Class&lt;?&gt; targetClass = (invocation.getThis() != <span class="keyword">null</span> ? AopUtils.getTargetClass(invocation.getThis()) : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Adapt to TransactionAspectSupport's invokeWithinTransaction...</span></span><br><span class="line">	<span class="keyword">return</span> invokeWithinTransaction(invocation.getMethod(), targetClass, <span class="keyword">new</span> InvocationCallback() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Object <span class="title">proceedWithInvocation</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> invocation.proceed();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>invokeWithinTransaction</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">invokeWithinTransaction</span><span class="params">(Method method, Class&lt;?&gt; targetClass, <span class="keyword">final</span> InvocationCallback invocation)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If the transaction attribute is null, the method is non-transactional.</span></span><br><span class="line">	<span class="keyword">final</span> TransactionAttribute txAttr = getTransactionAttributeSource().getTransactionAttribute(method, targetClass);</span><br><span class="line">	<span class="keyword">final</span> PlatformTransactionManager tm = determineTransactionManager(txAttr);</span><br><span class="line">	<span class="keyword">final</span> String joinpointIdentification = methodIdentification(method, targetClass);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (txAttr == <span class="keyword">null</span> || !(tm <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line">		<span class="comment">// Standard transaction demarcation with getTransaction and commit/rollback calls.</span></span><br><span class="line">	<span class="comment">//开启事务，设置事务隔离级别，传播属性等	</span></span><br><span class="line">         TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);</span><br><span class="line">		Object retVal = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// This is an around advice: Invoke the next interceptor in the chain.</span></span><br><span class="line">			<span class="comment">// This will normally result in a target object being invoked.</span></span><br><span class="line">			retVal = invocation.proceedWithInvocation();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			<span class="comment">// target invocation exception</span></span><br><span class="line">             <span class="comment">//如果抛出异常，处理他</span></span><br><span class="line">			completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			cleanupTransactionInfo(txInfo);</span><br><span class="line">		&#125;</span><br><span class="line">		commitTransactionAfterReturning(txInfo);</span><br><span class="line">		<span class="keyword">return</span> retVal;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//省略了CallbackPreferringPlatformTransactionManager这一块，这一块基本就是编程式事务实现事务管理的逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2018/02/06/使用代理代理技术完成Spring事务管理/" data-id="cjdbsnhui0000uobz1fs2qsl6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CAS简单实例" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/05/CAS简单实例/" class="article-date">
  <time datetime="2018-02-05T14:22:29.691Z" itemprop="datePublished">2018-02-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CAS/">CAS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/05/CAS简单实例/">CAS简单实例</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="CAS-Server部署"><a href="#CAS-Server部署" class="headerlink" title="CAS Server部署"></a>CAS Server部署</h3><p>在了解了CAS是什么以及CAS的作用之后，我们可以开始体验对CAS的使用了。</p>
<p>首先下载CAS Server，下载路径：<a href="http://developer.jasig.org/cas/" target="_blank" rel="noopener">http://developer.jasig.org/cas/</a></p>
<p>当然也可以在github上下载cas server,但是放在github上的版本不再是用maven部署的项目了。</p>
<p>所以，如果你习惯使用maven，然后对版本没有太高的要求，可以在上面的网站下载，我们这里选用cas server 4.0版本。</p>
<p>然后我们将cas-server解压，将多模块maven项目导入到Eclipse。</p>
<p>cas server默认支持的请求方式是https ssl，所以如果我们想要使用简单的http请求来测试，那么我们需要对cas-server-webapp这个Maven项目里面的配置文件进行更改。</p>
<p><strong>修改配置</strong></p>
<p>0.修改 WEB-INF/deployerConfigContext.xml </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"proxyAuthenticationHandler"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"org.jasig.cas.authentication.handler.support.HttpBasedServiceCredentialsAuthenticationHandler"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:httpClient-ref</span>=<span class="string">"httpClient"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>中添加 p:requireSecure=”false”</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"proxyAuthenticationHandler"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"org.jasig.cas.authentication.handler.support.HttpBasedServiceCredentialsAuthenticationHandler"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:httpClient-ref</span>=<span class="string">"httpClient"</span> <span class="attr">p:requireSecure</span>=<span class="string">"false"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>1.修改WEB-INF/spring-configuration/ticketGrantingTicketCookieGenerator.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"ticketGrantingTicketCookieGenerator"</span> <span class="attr">class</span>=<span class="string">"org.jasig.cas.web.support.CookieRetrievingCookieGenerator"</span></span></span><br><span class="line"><span class="tag">		<span class="attr">p:cookieSecure</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">		<span class="attr">p:cookieMaxAge</span>=<span class="string">"-1"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">p:cookieName</span>=<span class="string">"CASTGC"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">p:cookiePath</span>=<span class="string">"/cas"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>将p:cookieSecure=”true”修改为p:cookieSecure=”false”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;ticketGrantingTicketCookieGenerator&quot; class=&quot;org.jasig.cas.web.support.CookieRetrievingCookieGenerator&quot;</span><br><span class="line">		p:cookieSecure=&quot;false&quot;</span><br><span class="line">		p:cookieMaxAge=&quot;-1&quot;</span><br><span class="line">	p:cookieName=&quot;CASTGC&quot;</span><br><span class="line">	p:cookiePath=&quot;/cas&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>2.修改WEB-INF/spring-configuration/warnCookieGenerator.xml </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"warnCookieGenerator"</span> <span class="attr">class</span>=<span class="string">"org.jasig.cas.web.support.CookieRetrievingCookieGenerator"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">p:cookieSecure</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">p:cookieMaxAge</span>=<span class="string">"-1"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">p:cookieName</span>=<span class="string">"CASPRIVACY"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">p:cookiePath</span>=<span class="string">"/cas"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>也是将p:cookieSecure=”true”修改为p:cookieSecure=”false”</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"warnCookieGenerator"</span> <span class="attr">class</span>=<span class="string">"org.jasig.cas.web.support.CookieRetrievingCookieGenerator"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">p:cookieSecure</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">p:cookieMaxAge</span>=<span class="string">"-1"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">p:cookieName</span>=<span class="string">"CASPRIVACY"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">p:cookiePath</span>=<span class="string">"/cas"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>3.如果该程序所在的tomcat服务器端口不是默认的8080，那么就需要修改WEB-INF/cas.properties</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.name=http://localhost:8080</span><br></pre></td></tr></table></figure>
<p>将端口修改，当然如果有在hosts里配置域名的话，也可以把localhost替换成域名。</p>
<p>完成了这些后，我们就可以用tomcat来启动cas-server-webapp这个项目了。</p>
<h3 id="访问CAS"><a href="#访问CAS" class="headerlink" title="访问CAS"></a>访问CAS</h3><p>我并没有更改tomcat端口，也咩有使用域名，这个时候我们访问10.18.1.132:9060/cas/</p>
<p>我们会来到默认的登陆页面。</p>
<p><strong>注意</strong>：在某些教程中，你会看到说我们只需要输入相同的用户名和密码就可以通过校验，但是在cas server 4.0及以后的版本中，用户名和密码不再是简单的相同就可以通过验证了，而是给出了一个配置文件用来配置默认的登陆用户名和密码，系统默认设置的只有一个  casuser/Mellon。这个配置在deployerConfigContext.xml，primaryAuthenticationHandler这个bean中。</p>
<h3 id="CAS-Client部署"><a href="#CAS-Client部署" class="headerlink" title="CAS Client部署"></a>CAS Client部署</h3><p>我们现在已经把Server端部署好了，接下来就需要部署client端了。</p>
<p>0.新建两个Maven web app项目:testapp1,testapp2。</p>
<p>1.对两个项目就行简单配置。</p>
<p>首先我们需要引入cas-client的相关包。</p>
<p>在pom.xml中加入</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jasig.cas.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cas-client-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后我们需要在web.xml中配置一些过滤器以及监听器。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.jasig.cas.client.session.SingleSignOutHttpSessionListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CAS Single Sign Out Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.jasig.cas.client.session.SingleSignOutFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CAS Single Sign Out Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CAS Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.jasig.cas.client.authentication.AuthenticationFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>casServerLoginUrl<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>http://localhost:8080/cas/login<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>serverName<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>http://localhost:8081/<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CAS Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CAS Validation Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        org.jasig.cas.client.validation.Cas20ProxyReceivingTicketValidationFilter</span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>casServerUrlPrefix<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>http://localhost:8080/cas<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>serverName<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>http://localhost:8081<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CAS Validation Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CAS HttpServletRequest Wrapper Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        org.jasig.cas.client.util.HttpServletRequestWrapperFilter</span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CAS HttpServletRequest Wrapper Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CAS Assertion Thread Local Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.jasig.cas.client.util.AssertionThreadLocalFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CAS Assertion Thread Local Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：CAS FIlter和CAS Validation Filter中对serverName这个init-param的value是不一样的，具体不同看配置。</p>
<p>还有这里我们使用了不同的端口，这里的tomcat端口已经不是8080了，而是8081。</p>
<p>而对于testapp2的配置，我们只需要做下相应的更改就好了，testapp2对应的tomcat端口为8082。</p>
<h3 id="如何在不同的tomcat端口中部署项目"><a href="#如何在不同的tomcat端口中部署项目" class="headerlink" title="如何在不同的tomcat端口中部署项目"></a>如何在不同的tomcat端口中部署项目</h3><p>当我们对testapp1和testapp2都部署好了之后。我们就需要在tomcat中启动他们，但是与我们平时启动项目不一样，因为我们不想再让这两个项目在默认的tomcat端口中部署了。那需要怎样部署呢？</p>
<p>我是使用Eclipse里的Tomcat来进行部署的，也就是需要对servers这个项目的server.xml进行更改。</p>
<p>添加以下内容。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Service</span> <span class="attr">name</span>=<span class="string">"Catalina1"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;<span class="name">Connector</span> <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span> <span class="attr">port</span>=<span class="string">"8081"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag">			<span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8001"</span> <span class="attr">protocol</span>=<span class="string">"AJP/1.3"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;<span class="name">Engine</span> <span class="attr">defaultHost</span>=<span class="string">"localhost"</span> <span class="attr">name</span>=<span class="string">"Catalina1"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			<span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.realm.LockOutRealm"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">				<span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.realm.UserDatabaseRealm"</span></span></span><br><span class="line"><span class="tag">					<span class="attr">resourceName</span>=<span class="string">"UserDatabase"</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">Realm</span>&gt;</span></span><br><span class="line"></span><br><span class="line">			<span class="tag">&lt;<span class="name">Host</span> <span class="attr">appBase</span>=<span class="string">"wtpwebapps"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span> <span class="attr">name</span>=<span class="string">"localhost"</span></span></span><br><span class="line"><span class="tag">				<span class="attr">unpackWARs</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">				<span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.valves.AccessLogValve"</span></span></span><br><span class="line"><span class="tag">					<span class="attr">directory</span>=<span class="string">"logs"</span> <span class="attr">pattern</span>=<span class="string">"%h %l %u %t &amp;quot;%r&amp;quot; %s %b"</span> <span class="attr">prefix</span>=<span class="string">"localhost_access_log."</span></span></span><br><span class="line"><span class="tag">					<span class="attr">suffix</span>=<span class="string">".txt"</span> /&gt;</span></span><br><span class="line">		</span><br><span class="line">				<span class="tag">&lt;<span class="name">Context</span> <span class="attr">docBase</span>=<span class="string">"testapp1"</span> <span class="attr">path</span>=<span class="string">"/testapp1"</span> <span class="attr">reloadable</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">					<span class="attr">source</span>=<span class="string">"org.eclipse.jst.j2ee.server:testapp1"</span> /&gt;</span></span><br><span class="line">			</span><br><span class="line">			<span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Service</span> <span class="attr">name</span>=<span class="string">"Catalina2"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;<span class="name">Connector</span> <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span> <span class="attr">port</span>=<span class="string">"8082"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag">			<span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8002"</span> <span class="attr">protocol</span>=<span class="string">"AJP/1.3"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;<span class="name">Engine</span> <span class="attr">defaultHost</span>=<span class="string">"localhost"</span> <span class="attr">name</span>=<span class="string">"Catalina2"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			<span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.realm.LockOutRealm"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">				<span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.realm.UserDatabaseRealm"</span></span></span><br><span class="line"><span class="tag">					<span class="attr">resourceName</span>=<span class="string">"UserDatabase"</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">Realm</span>&gt;</span></span><br><span class="line"></span><br><span class="line">			<span class="tag">&lt;<span class="name">Host</span> <span class="attr">appBase</span>=<span class="string">"wtpwebapps"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span> <span class="attr">name</span>=<span class="string">"localhost"</span></span></span><br><span class="line"><span class="tag">				<span class="attr">unpackWARs</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">				<span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.valves.AccessLogValve"</span></span></span><br><span class="line"><span class="tag">					<span class="attr">directory</span>=<span class="string">"logs"</span> <span class="attr">pattern</span>=<span class="string">"%h %l %u %t &amp;quot;%r&amp;quot; %s %b"</span> <span class="attr">prefix</span>=<span class="string">"localhost_access_log."</span></span></span><br><span class="line"><span class="tag">					<span class="attr">suffix</span>=<span class="string">".txt"</span> /&gt;</span></span><br><span class="line">		</span><br><span class="line">				<span class="tag">&lt;<span class="name">Context</span> <span class="attr">docBase</span>=<span class="string">"testapp1"</span> <span class="attr">path</span>=<span class="string">"/testapp1"</span> <span class="attr">reloadable</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">					<span class="attr">source</span>=<span class="string">"org.eclipse.jst.j2ee.server:testapp2"</span> /&gt;</span></span><br><span class="line">			</span><br><span class="line">			<span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里我在第一次配置的时候出现了问题，当时是直接把已经部署好了的cas-server的配置粘过来改的。其中Host节点的appBase属性对应的值是webapps,然后我们更改了相应的端口号之后，我们启动Tomcat,发现报错，提示找到不到相应的文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\UM\.metadata\.plugins\org.eclipse.wst.server.core\tmp0\webapps\testapp1</span><br></pre></td></tr></table></figure>
<p>，然后到相应的位置找，确实是没有，但是却在wtpwebapps中找到了，然后把appBase的属性值改为wtpwebapps再运行，发现无误。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2018/02/05/CAS简单实例/" data-id="cjdab4v3n0002lkbzkqj0zfg1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CAS" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/05/CAS/" class="article-date">
  <time datetime="2018-02-05T14:22:29.690Z" itemprop="datePublished">2018-02-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CAS/">CAS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/05/CAS/">CAS</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>转载：<a href="http://blog.csdn.net/javaloveiphone/article/details/52439613" target="_blank" rel="noopener">http://blog.csdn.net/javaloveiphone/article/details/52439613</a></p>
<h3 id="一-CAS是什么"><a href="#一-CAS是什么" class="headerlink" title="一.CAS是什么"></a>一.CAS是什么</h3><p>cas，全称：Central Authentication Service，是有耶鲁大学开发的一个开源的单点登录框架，目前代码放在github上托管。</p>
<ul>
<li><p>什么是单点登录</p>
<p>Single Sign On,简称SSO，SSO使得在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。即一个应用登录了，其他被授权的应用不用再登录。<br>应用例子为：淘宝登录了天猫不用再登录。</p>
</li>
<li><p>CAS的组成</p>
</li>
</ul>
<p>从结构上看，CAS包含两个部分：CAS Server 和CAS Client需要独立部署，主要负责对用户的认证工作；CAS<br>Client负责处理对客户端受保护资源的访问请求，需要登录时，重定向到CAS Server.图1是CAS最基本的协议过程：</p>
<p>CAS Client 与受保护的客户端应用部署在一起，以Filter方式保护 Web 应用的受保护资源，过滤从客户端过来的每一个 Web<br>请求，同时， CAS Client会分析HTTP 请求中是否包请求 Service Ticket( 上图中的 Ticket)<br>，如果没有，则说明该用户是没有经过认证的，于是，CAS Client会重定向用户请求到CAS Server（ Step 2 ）。 Step<br>3是用户认证过程，如果用户提供了正确的Credentials， CAS Server 会产生一个随机的 Service Ticket<br>，然后，缓存该 Ticket ，并且重定向用户到CAS Client（附带刚才产生的Service Ticket）， Service<br>Ticket 是不可以伪造的，最后， Step 5 和 Step6是 CAS Client 和 CAS<br>Server之间完成了一个对用户的身份核实，用Ticket查到 Username ，因为 Ticket是 CAS Server<br>产生的，因此，所以 CAS Server 的判断是毋庸置疑的。</p>
<p>该协议完成了一个很简单的任务，所有与CAS的交互均采用SSL协议，确保ST和TGC的安全性。协议工作过程会有2此重定向过程，但是CAS<br>Client与CAS Server之间进行ticket验证的过程对于用户是透明的。</p>
<p>总结一下，如下：</p>
<p>访问服务： SSO 客户端发送请求访问应用系统提供的服务资源。</p>
<p>定向认证： SSO 客户端会重定向用户请求到 SSO 服务器。</p>
<p>用户认证：用户身份认证。</p>
<p>发放票据： SSO 服务器会产生一个随机的 Service Ticket 。</p>
<p>验证票据： SSO 服务器验证票据 Service Ticket 的合法性，验证通过后，允许客户端访问服务。</p>
<p>传输用户信息： SSO 服务器验证票据通过后，传输用户认证结果信息给客户端。</p>
<h3 id="CAS流程分析"><a href="#CAS流程分析" class="headerlink" title="CAS流程分析"></a>CAS流程分析</h3><p><strong>用户首次登录时流程如下：</strong></p>
<p>1)、用户浏览器访问系统A需登录受限资源，此时进行登录检查，发现未登录，然后进行获取票据操作，发现没有票据。</p>
<p>2)、系统A发现该请求需要登录，将请求重定向到认证中心，获取全局票据操作，没有，进行登录。</p>
<p>3)、认证中心呈现登录页面，用户登录，登录成功后，认证中心重定向请求到系统A，并附上认证通过令牌，此时认证中心同时生成了全局票据。</p>
<p>4)、此时再次进行登录检查，发现未登录，然后再次获取票据操作，此时可以获得票据(令牌)，系统A与认证中心通信，验证令牌有效,证明用户已登录。</p>
<p>5)、系统A将受限资源返给用户。</p>
<p><strong>已登录用户首次访问应用群中系统B时：</strong></p>
<p>1)、浏览器访问另一应用B需登录受限资源，此时进行登录检查，发现未登录，然后进行获取票据操作，发现没有票据。</p>
<p>2)、系统B发现该请求需要登录，将请求重定向到认证中心，获取全局票据操作，获取全局票据，可以获得，认证中心发现已经登录。</p>
<p>3)、认证中心发放临时票据(令牌)，并携带该令牌重定向到系统B。</p>
<p>4)、此时再次进行登录检查，发现未登录，然后再次获取票据操作，此时可以获得票据(令牌)，系统B与认证中心通信，验证令牌有效,证明用户已登录。</p>
<p>5)、系统B将受限资源返回给客户端。</p>
<p>1)、问：系统A是如何发现该请求需要登录重定向到认证中心的？<br>答：用户通过浏览器地址栏访问系统A，系统A(也可以称为CAS客户端)去Cookie中拿JSESSION，即在Cookie中维护的当前回话session的id，如果拿到了，说明用户已经登录，如果未拿到，说明用户未登录。</p>
<p>2)、问：系统A重定向到认证中心，发送了什么信息或者地址变成了什么？<br>答：假如系统A的地址为<code>http://a:8080/</code>，CAS认证中心的服务地址为<code>http://cas.server:8080/</code>，那么重点向前后地址变化为：<code>http://a:8080/</code>————&gt;<code>ttp://cas.server:8080/?service=http://a:8080/</code>，由此可知，重点向到认证中心，认证中心拿到了当前访问客户端的地址。</p>
<p>3)、问：登录成功后，认证中心重定向请求到系统A，认证通过令牌是如何附加发送给系统A的？<br>答：重定向之后的地址栏变成：<code>http://a:8080/?ticket=ST-XXXX-XXX</code>，将票据以ticket为参数名的方式通过地址栏发送给系统A</p>
<p>4)、问：系统A验证令牌，怎样操作证明用户登录的？<br>答：系统A通过地址栏获取ticket的参数值ST票据，然后从后台将ST发送给CAS server认证中心验证，验证ST有效后，CAS server返回当前用户登录的相关信息，系统A接收到返回的用户信息，并为该用户创建session会话，会话id由cookie维护，来证明其已登录。</p>
<p>5)、问：登录B系统，认证中心是如何判断用户已经登录的？<br>答：在系统A登录成功后，用户和认证中心之间建立起了全局会话，这个全局会话就是TGT(Ticket Granting Ticket)，TGT位于CAS服务器端，TGT并没有放在Session中，也就是说，CAS全局会话的实现并没有直接使用Session机制，而是利用了Cookie自己实现的，这个Cookie叫做TGC(Ticket Granting Cookie)，它存放了TGT的id,保存在用户浏览器上。 </p>
<p>用户发送登录系统B的请求，首先会去Cookie中拿JSESSION，因为系统B并未登录过，session会话还未创建，JSESSION的值是拿不到的，然后将请求重定向到CAS认证中心，CAS认证中心先去用户浏览器中拿TGC的值，也就是全局会话id，如果存在则代表用户在认证中心已经登录，附带上认证令牌重定向到系统B。</p>
<p>上面登录状态判断也是这个逻辑。</p>
<p>6)、问：登出的过程，各个系统对当前用户都做了什么？<br>答：认证中心清除当前用户的全局会话TGT，同时清掉cookie中TGT的id：TGC；<br>然后是各个客户端系统，比如系统A、系统B，清除局部会话session，同时清掉cookie中session会话id：jsession</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2018/02/05/CAS/" data-id="cjdab4v3k0001lkbzt3zjk9j1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-数据库基础知识" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/05/数据库基础知识/" class="article-date">
  <time datetime="2018-02-05T14:22:29.689Z" itemprop="datePublished">2018-02-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据库/">数据库</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/05/数据库基础知识/">数据库基础知识</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h3><p>B树，B+树<a href="http://blog.csdn.net/endlu/article/details/51720299" target="_blank" rel="noopener">http://blog.csdn.net/endlu/article/details/51720299</a></p>
<p>索引：<a href="https://www.cnblogs.com/aspwebchh/p/6652855.html" target="_blank" rel="noopener">https://www.cnblogs.com/aspwebchh/p/6652855.html</a></p>
<h3 id="主从表"><a href="#主从表" class="headerlink" title="主从表"></a>主从表</h3><ul>
<li><p><strong>主表</strong></p>
<p>在数据库中建立的表格即Table，其中存在主键(primary key)用于与其它表相关联，并且作为在主表中的唯一性标识。</p>
</li>
<li><p><strong>从表</strong></p>
<p>以主表的主键（primary key）值为外键 (Foreign Key)的表，可以通过外键与主表进行关联查询。从表与主表通过外键进行关联查询。</p>
<p>A表中的一个字段，是B表的主键，那他就可以是A表的外键。</p>
</li>
</ul>
<p>从表数据依赖于主表，一般最后查询数据时把主表与从表进行关联查询。主表可用于存储主要信息，如客户资料（客户编号，客户名称，客户公司，客户单位等），从表用来存储客户扩展信息（客户订单信息，客户地址信息，客户联系方式信息等）</p>
<h3 id="JOIN"><a href="#JOIN" class="headerlink" title="JOIN"></a>JOIN</h3><ul>
<li><p><strong>left join（左连接）</strong></p>
<p>默认加上了outer ，即全名为left outer join</p>
<p>select * from A<br>left join B<br>on A.aID = B.bID</p>
<p>left join是以A表的记录为基础的,A可以看成左表,B可以看成右表,left join是以左表为准的.<br>换句话说,左表(A)的记录将会全部表示出来,而右表(B)只会显示符合搜索条件的记录(例子中为: A.aID = B.bID).<br>B表记录不足的地方均为NULL.</p>
</li>
<li><p><strong>right join(右连接)</strong></p>
<p>select * from A<br>right join B<br>on A.aID = B.bID</p>
<p>以右表(B)为基础的,A表不足的地方用NULL填充.</p>
</li>
<li><p><strong>inner join(等值连接)</strong></p>
<p>select * from A<br>innerjoin B<br>on A.aID = B.bID</p>
</li>
</ul>
<p>只显示出了 A.aID = B.bID的记录.这说明inner join并不以谁为基础,它只显示符合条件的记录.</p>
<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p><strong>outer join一旦加上where条件会变成inner join</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.*,b.*</span><br><span class="line"><span class="keyword">from</span> table1 a</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> table2 b <span class="keyword">on</span> b.X=a.X</span><br><span class="line"><span class="keyword">where</span> XXX</span><br></pre></td></tr></table></figure>
<p>数据库在通过连接两张或多张表来返回记录时，都会生成一张中间的临时表，然后再将这张临时表返回给用户；</p>
<p><strong>where条件是在临时表生成好后，再对临时表进行过滤的条件；</strong></p>
<p>因此：where 条件加上，已经没有left join的含义（必须返回左边表的记录）了，条件不为真的就全部过滤掉。 </p>
<p>需要做如下更改：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.*,tmp.*</span><br><span class="line"><span class="keyword">from</span> table1 a</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span>(</span><br><span class="line">    <span class="keyword">select</span> a.*,b.*</span><br><span class="line">    <span class="keyword">from</span> table1 a</span><br><span class="line">    <span class="keyword">left</span> <span class="keyword">join</span> table2 b <span class="keyword">on</span> b.X=a.X</span><br><span class="line">    <span class="keyword">where</span> XXX</span><br><span class="line">)tmp</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.*,b.*</span><br><span class="line"><span class="keyword">from</span> table1 a</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> table2 b <span class="keyword">on</span> b.X=a.X <span class="keyword">and</span> XX</span><br></pre></td></tr></table></figure>
<p>注意：where XXX去掉，改为链接条件on后面的 and XXX</p>
<p><strong>on条件是在生成临时表时使用的条件，它不管on中的条件是否为真，都会返回左边表的记录</strong></p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><ul>
<li><p><strong>平衡树</strong></p>
<ul>
<li><p><strong>B Tree</strong></p>
<p>B 树是为了磁盘或其它存储设备而设计的一种多叉平衡查找树。</p>
<p>B 树又叫平衡多路查找树。一棵m阶的B 树 (m叉树)的特性如下：</p>
<ol>
<li>树中每个结点最多含有m个孩子（m&gt;=2）；</li>
<li>除根结点和叶子结点外，其它每个结点至少有[ceil(m / 2)]个孩子（其中ceil(x)是一个取上限的函数）；</li>
<li>若根结点不是叶子结点，则至少有2个孩子（特殊情况：没有孩子的根结点，即根结点为叶子结点，整棵树只有一个根节点）；</li>
<li>所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息(可以看做是外部接点或查询失败的接点，实际上这些结点不存在，指向这些结点的指针都为null)；</li>
<li>每个非终端结点中包含有n个关键字信息： (P1，K1，P2，K2，P3，……，Kn，Pn+1)。其中：<br>​       a)   Ki (i=1…n)为关键字，且关键字按顺序升序排序K(i-1)&lt; Ki。<br>​       b)   Pi为指向子树根的接点，且指针P(i)指向子树种所有结点的关键字均小于Ki，但都大于K(i-1)。<br>​       c)   关键字的个数n必须满足： [ceil(m / 2)-1]&lt;= n &lt;= m-1。</li>
</ol>
<p>索引为什么选用B树这种数据结构？<br>因为使用B树查找时，所用的磁盘IO操作次数比平衡二叉树更少，效率也更高。<br>为什么使用B树查找所用的磁盘IO操作次数比平衡二叉树更少？<br>大规模数据存储中，树节点存储的元素数量是有限的（如果元素数量非常多的话，查找就退化成节点内部的线性查找了），这样导致二叉查找树结构由于树的高度过大而造成磁盘I/O读写过于频繁，进而导致查询效率低下。那么我们就需要减少树的高度以提高查找效率。而平衡多路查找树结构B树就满足这样的要求。B树的各种操作能使B树保持较低的高度，从而达到有效减少磁盘IO操作次数。</p>
</li>
<li><p><strong>B+ Tree</strong></p>
<p>B+Tree是应文件系统所需而出的一种B-Tree的变型树，一棵m阶的B+树和m阶的B-树的差异在于:<br>1.有n棵子树的结点中含有n个关键字；<br>2.所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字的记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接；<br>3.所有的非终端结点可以看成是索引部分，结点中仅含有其子树(根结点)中的最大（或最小）关键字；</p>
</li>
<li><p><strong>区别</strong></p>
<p>1) B+-tree的磁盘读写代价更低</p>
<p>B+-tree的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</p>
<p>   举个例子，假设磁盘中的一个盘块容纳16bytes，而一个关键字2bytes，一个关键字具体信息指针2bytes。一棵9阶B-tree(一个结点最多8个关键字)的内部结点需要2个盘快。而B+ 树内部结点只需要1个盘快。当需要把内部结点读入内存中的时候，B 树就比B+ 树多一次盘块查找时间(在磁盘中就是盘片旋转的时间)。</p>
<p>2) B+-tree的查询效率更加稳定</p>
<p>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p>
</li>
</ul>
</li>
<li><p><strong>聚集索引</strong></p>
<p>聚集索引也称为聚簇索引（Clustered Index），聚类索引，簇集索引。</p>
<p>聚集索引是指数据库表行中数据的物理顺序与键值的逻辑（索引）顺序相同。一个表只能有一个聚集索引，因为一个表的物理顺序只有一种情况，所以，对应的聚集索引只能有一个。如果某索引不是聚集索引，则表中的行物理顺序与索引顺序不匹配，与非聚集索引相比，聚集索引有着更快的检索速度。</p>
<p>聚集索引确定表中数据的物理顺序。聚集索引类似于电话簿，按姓氏排列数据。由于聚集索引规定数据在表中的物理存储顺序，因此一个表只能包含一个聚集索引。但该索引可以包含多个列（组合索引），就像电话簿按姓氏和名字进行组织一样。</p>
<p>聚集索引对于那些经常要搜索范围值的列特别有效。使用聚集索引找到包含第一个值的行后，便可以确保包含后续索引值的行在物理相邻。例如，如果应用程序执行的一个查询经常检索某一日期范围内的记录，则使用聚集索引可以迅速找到包含开始日期的行，然后检索表中所有相邻的行，直到到达结束日期。这样有助于提高此类查询的性能。同样，如果对从表中检索的数据进行排序时经常要用到某一列，则可以将该表在该列上聚集（物理排序），避免每次查询该列时都进行排序，从而节省成本。</p>
<p>当索引值唯一时，使用聚集索引查找特定的行也很有效率。例如，使用唯一雇员 ID 列 emp_id 查找特定雇员的最快速的方法，是在 emp_id 列上创建聚集索引或 PRIMARY KEY 约束。</p>
<p>1、含有大量非重复值的列。</p>
<p>2、使用BETWEEN,&gt;,&gt;=,&lt;或&lt;=返回一个范围值的列</p>
<p>3、被连续访问的列</p>
<p>4、返回大型结果集的查询</p>
<p>5、经常被使用连接或GROUP BY子句的查询访问的列</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>动作描述</th>
<th>使用聚集索引</th>
<th>使用非聚集索引</th>
</tr>
</thead>
<tbody>
<tr>
<td>列经常被分组排序</td>
<td>应</td>
<td>应</td>
</tr>
<tr>
<td>返回某范围内的数据</td>
<td>应</td>
<td>不应</td>
</tr>
<tr>
<td>一个或极少不同值</td>
<td>不应</td>
<td>不应</td>
</tr>
<tr>
<td>小数目的不同值</td>
<td>应</td>
<td>不应</td>
</tr>
<tr>
<td>大数目的不同值</td>
<td>不应</td>
<td>应</td>
</tr>
<tr>
<td>频繁更新的列</td>
<td>不应</td>
<td>应</td>
</tr>
<tr>
<td>外键列</td>
<td>应</td>
<td>应</td>
</tr>
<tr>
<td>主键列</td>
<td>应</td>
<td>应</td>
</tr>
<tr>
<td>频繁修改索引列</td>
<td>不应</td>
<td>应</td>
</tr>
</tbody>
</table>
<h3 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h3><p>我们平时建表的时候都会为表加上主键， 在某些关系数据库中， 如果建表时不指定主键，数据库会拒绝建表的语句执行。 事实上， 一个加了主键的表，并不能被称之为「表」。一个没加主键的表，它的数据无序的放置在磁盘存储器上，一行一行的排列的很整齐， 跟我认知中的「表」很接近。如果给表上了主键，那么表在磁盘上的存储结构就由整齐排列的结构转变成了树状结构，也就是上面说的「平衡树」结构，换句话说，就是整个表就变成了一个索引。整个表变成了一个索引，也就是所谓的「聚集索引」。 这就是为什么一个表只能有一个主键， 一个表只能有一个「聚集索引」，因为主键的作用就是把「表」的数据格式转换成「索引（平衡树）」的格式放置。</p>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>当并发事务同时访问一个资源时，有可能导致数据不一致，因此需要一种机制来将数据访问顺序化，以保证数据库数据的一致性。锁就是其中的一种机制。</p>
<p>在计算机科学中，锁是在执行多线程时用于强行限制资源访问的同步机制，即用于在并发控制中保证对互斥要求的满足。</p>
<ul>
<li><p><strong>锁的分类(oracle)</strong></p>
<p>​</p>
</li>
</ul>
<p>一、按操作划分，可分为<code>DML锁</code>、<code>DDL锁</code></p>
<p>二、按锁的粒度划分，可分为表级锁, 页级锁, 行级锁（mysql）</p>
<p>三、按锁级别划分，可分为共享锁、排它锁</p>
<p>四、按加锁方式划分，可分为<code>自动锁</code>、<code>显示锁</code></p>
<p>五、按使用方式划分，可分为乐观锁, 悲观锁<a href="http://www.hollischuang.com/archives/934" target="_blank" rel="noopener">``</a></p>
<p>DML锁（data locks，数据锁），用于保护数据的完整性，其中包括行级锁(Row Locks (TX锁))、表级锁(table lock(TM锁))。 DDL锁（dictionary locks，数据字典锁），用于保护数据库对象的结构，如表、索引等的结构定义。其中包排他DDL锁（Exclusive DDL lock）、共享DDL锁（Share DDL lock）、可中断解析锁（Breakable parse locks）</p>
<h3 id="MySql"><a href="#MySql" class="headerlink" title="MySql"></a>MySql</h3><p>MyISAM是<a href="http://lib.csdn.net/base/mysql" target="_blank" rel="noopener">MySQL</a> 5.5之前版本默认的存储引擎，从5.5之后，InnoDB开始成为MySQL默认的存储引擎。</p>
<p>MyISAM使用B-Tree实现主键索引、唯一索引和非主键索引。</p>
<p>InnoDB中非主键索引使用的是B-Tree数据结构，而主键索引使用的是B+Tree。</p>
<p>在DBMS中，可以按照锁的粒度把数据库锁分为行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎 )。</p>
<ul>
<li><p><strong>MySQL中的行级锁，表级锁，页级锁</strong></p>
<ul>
<li><p><strong>行级锁</strong></p>
<p>行级锁是MySQL中锁粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁和排他锁。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p>
</li>
<li><p><strong>表级锁</strong></p>
<p>表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为<code>表共享读锁</code>（共享锁）与<code>表独占写锁</code>（排他锁）</p>
<p>####特点</p>
<p>开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。</p>
</li>
<li><p><strong>页级锁</strong></p>
<p>页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB支持页级锁</p>
<p>####特点</p>
<p>开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</p>
</li>
</ul>
</li>
<li><p><strong>MySQL中常用存储引擎的锁机制</strong></p>
<p>MyISAM和MEMORY采用表级锁(table-level locking)</p>
<p>BDB采用页面锁(page-level locking)或表级锁，默认为页面锁</p>
<p>InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁</p>
</li>
<li><p><strong>InnoDB中的行锁和表锁</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</span><br></pre></td></tr></table></figure>
<p>​</p>
<p>前面提到过，在Innodb引擎中既支持行锁也支持表锁，那么什么时候会锁住整张表，什么时候或只锁住一行呢？</p>
<p>InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：<strong>只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</strong></p>
<p>在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。</p>
<p><strong>行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁。行级锁的缺点是：由于需要请求大量的锁资源，所以速度慢，内存消耗大。</strong></p>
</li>
<li><p><strong>行级锁与死锁</strong></p>
<p>MyISAM中是不会产生死锁的，因为MyISAM总是一次性获得所需的全部锁，要么全部满足，要么全部等待。而在InnoDB中，锁是逐步获得的，就造成了死锁的可能。</p>
<p>在MySQL中，行级锁并不是直接锁记录，而是锁索引。索引分为主键索引和非主键索引两种，如果一条sql语句操作了主键索引，MySQL就会锁定这条主键索引；如果一条语句操作了非主键索引，MySQL会先锁定该非主键索引，再锁定相关的主键索引。 在UPDATE、DELETE操作时，MySQL不仅锁定WHERE条件扫描过的所有索引记录，而且会锁定相邻的键值，即所谓的next-key locking(防止幻读)。</p>
<p><strong>当两个事务同时执行，一个锁住了主键索引，在等待其他相关索引。另一个锁定了非主键索引，在等待主键索引。这样就会发生死锁。</strong></p>
<p>发生死锁后，InnoDB一般都可以检测到，并使一个事务释放锁回退，另一个获取锁完成事务。</p>
<p>有多种方法可以避免死锁，这里只介绍常见的三种</p>
<p>1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。</p>
<p>2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；</p>
<p>3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2018/02/05/数据库基础知识/" data-id="cjdab4v4i000blkbzd15zw2pl" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CAS结合openldap" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/05/CAS结合openldap/" class="article-date">
  <time datetime="2018-02-05T14:22:29.687Z" itemprop="datePublished">2018-02-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CAS/">CAS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/05/CAS结合openldap/">CAS结合openldap</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="CAS与openldap的结合"><a href="#CAS与openldap的结合" class="headerlink" title="CAS与openldap的结合"></a>CAS与openldap的结合</h3><p>openldap通常会在企业中用来进行用户验证，具体关于openldap的介绍，请看相应的openldap系列的文章，这篇文章只会介绍如何将cas-server4.0版本与openldap结合起来，即让openldap来充当登陆验证的工具。</p>
<p><strong>0.修改配置</strong></p>
<p>想要cas和openldap结合，只需要修改配置即可，当然前提是你已经有了相应的openldap服务器。</p>
<p>在网上对cas与openldap结合的文章很少，有的也是对cas-4.0以前的版本cas-3.x版本与openldap的结合。</p>
<p>所以对于cas-server-4.0与openldap的结合，虽然并不复杂，但是还是值得记下来的。</p>
<p>依旧是修改WEB-INF/deployerConfigContext.xml</p>
<ul>
<li>找到id为authenticationManager的bean，加入ldap验证入口，初始配置如下</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"authenticationManager"</span> <span class="attr">class</span>=<span class="string">"org.jasig.cas.authentication.PolicyBasedAuthenticationManager"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">              <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key-ref</span>=<span class="string">"proxyAuthenticationHandler"</span> <span class="attr">value-ref</span>=<span class="string">"proxyPrincipalResolver"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">                              <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key-ref</span>=<span class="string">"primaryAuthenticationHandler"</span> <span class="attr">value-ref</span>=<span class="string">"primaryPrincipalResolver"</span> /&gt;</span></span><br><span class="line">              </span><br><span class="line">              </span><br><span class="line">          <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"authenticationPolicy"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.jasig.cas.authentication.AnyAuthenticationPolicy"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里构造方法是由一个Map结构配置，就是配置登陆验证的形式，包括对于密码的配置等。</p>
<p>其中的primaryAuthenticationHandler这个key对应着就是我们之前讲过的cas-server-4.0之后，不再是用户名和密码相同即可登陆，而是设置了默认用户名密码，这个默认的用户名密码就是用primaryAuthenticationHandler配置的。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"primaryAuthenticationHandler"</span></span><br><span class="line">      <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.jasig.cas.authentication.AcceptUsersAuthenticationHandler"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"users"</span>&gt;</span><br><span class="line">        &lt;map&gt;</span><br><span class="line">            &lt;entry key=<span class="string">"casuser"</span> value=<span class="string">"Mellon"</span>/&gt;</span><br><span class="line">        &lt;/map&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>所以，如果我们还是想用单纯的用户名密码验证，可以在这里添加值，但是这样无疑显得过于笨拙。</p>
<p>那么我们如果要想添加ldap的验证方式，那么毫无疑问我们要在authenticationManager中的构造方法中注册ldap验证形式。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"authenticationManager"</span> <span class="attr">class</span>=<span class="string">"org.jasig.cas.authentication.PolicyBasedAuthenticationManager"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">               <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">                  | IMPORTANT</span></span><br><span class="line"><span class="comment">                  | Every handler requires a unique name.</span></span><br><span class="line"><span class="comment">                  | If more than one instance of the same handler class is configured, you must explicitly</span></span><br><span class="line"><span class="comment">                  | set its name to something other than its default name (typically the simple class name).</span></span><br><span class="line"><span class="comment">                  --&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key-ref</span>=<span class="string">"proxyAuthenticationHandler"</span> <span class="attr">value-ref</span>=<span class="string">"proxyPrincipalResolver"</span> /&gt;</span></span><br><span class="line">               <span class="comment">&lt;!-- 注释掉默认用户名密码方式</span></span><br><span class="line"><span class="comment">                               &lt;entry key-ref="primaryAuthenticationHandler" value-ref="primaryPrincipalResolver" /&gt;</span></span><br><span class="line"><span class="comment">               </span></span><br><span class="line"><span class="comment">               </span></span><br><span class="line"><span class="comment">                --&gt;</span></span><br><span class="line">               <span class="comment">&lt;!--新增ldap认证的入口 --&gt;</span></span><br><span class="line">       		<span class="tag">&lt;<span class="name">entry</span> <span class="attr">key-ref</span>=<span class="string">"ldapAuthenticationHandler"</span> <span class="attr">value-ref</span>=<span class="string">"proxyPrincipalResolver"</span>/&gt;</span> </span><br><span class="line">           <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"authenticationPolicy"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.jasig.cas.authentication.AnyAuthenticationPolicy"</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>完善ldap验证入口的相关必要配置。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"ldapAuthenticationHandler"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.jasig.cas.authentication.LdapAuthenticationHandler"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">p:principalIdAttribute</span>=<span class="string">"uid"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">c:authenticator-ref</span>=<span class="string">"authenticator"</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"principalAttributeMap"</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;<span class="name">map</span>&gt;</span>  </span><br><span class="line">              <span class="comment">&lt;!--  </span></span><br><span class="line"><span class="comment">                 | This map provides a simple attribute resolution mechanism.  </span></span><br><span class="line"><span class="comment">                 | Keys are LDAP attribute names, values are CAS attribute names.  </span></span><br><span class="line"><span class="comment">                 | Use this facility instead of a PrincipalResolver if LDAP is  </span></span><br><span class="line"><span class="comment">                 | the only attribute source.  </span></span><br><span class="line"><span class="comment">                 --&gt;</span>  </span><br><span class="line">			<span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"uid"</span> <span class="attr">value</span>=<span class="string">"uid"</span> /&gt;</span>  </span><br><span class="line">              <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"mail"</span> <span class="attr">value</span>=<span class="string">"mail"</span> /&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;/<span class="name">map</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"authenticator"</span> <span class="attr">class</span>=<span class="string">"org.ldaptive.auth.Authenticator"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">c:resolver-ref</span>=<span class="string">"dnResolver"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">c:handler-ref</span>=<span class="string">"authHandler"</span> /&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- 配置baseDn  以及指定属性uid--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dnResolver"</span> <span class="attr">class</span>=<span class="string">"org.ldaptive.auth.PooledSearchDnResolver"</span>  </span></span><br><span class="line"><span class="tag">       <span class="attr">p:baseDn</span>=<span class="string">"dc=ulic,dc=com,dc=cn"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">p:allowMultipleDns</span>=<span class="string">"false"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">p:subtreeSearch</span>=<span class="string">"true"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">p:connectionFactory-ref</span>=<span class="string">"searchPooledLdapConnectionFactory"</span>  </span></span><br><span class="line"><span class="tag">      <span class="attr">p:userFilter</span>=<span class="string">"uid=&#123;user&#125;"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"searchPooledLdapConnectionFactory"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.ldaptive.pool.PooledConnectionFactory"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">p:connectionPool-ref</span>=<span class="string">"searchConnectionPool"</span> /&gt;</span>  </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"searchConnectionPool"</span> <span class="attr">parent</span>=<span class="string">"abstractConnectionPool"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">p:connectionFactory-ref</span>=<span class="string">"searchConnectionFactory"</span> /&gt;</span>  </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"searchConnectionFactory"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.ldaptive.DefaultConnectionFactory"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">p:connectionConfig-ref</span>=<span class="string">"searchConnectionConfig"</span> /&gt;</span>  </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"searchConnectionConfig"</span> <span class="attr">parent</span>=<span class="string">"abstractConnectionConfig"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">p:connectionInitializer-ref</span>=<span class="string">"bindConnectionInitializer"</span> /&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--配置userDn和密码 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bindConnectionInitializer"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.ldaptive.BindConnectionInitializer"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">p:bindDn</span>=<span class="string">"cn=Manager,dc=ulic,dc=com,dc=cn"</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"bindCredential"</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.ldaptive.Credential"</span>  </span></span><br><span class="line"><span class="tag">              <span class="attr">c:password</span>=<span class="string">"redhat"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"abstractConnectionPool"</span> <span class="attr">abstract</span>=<span class="string">"true"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.ldaptive.pool.BlockingConnectionPool"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">init-method</span>=<span class="string">"initialize"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">p:poolConfig-ref</span>=<span class="string">"ldapPoolConfig"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">p:blockWaitTime</span>=<span class="string">"3000"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">p:validator-ref</span>=<span class="string">"searchValidator"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">p:pruneStrategy-ref</span>=<span class="string">"pruneStrategy"</span> /&gt;</span>  </span><br><span class="line">  <span class="comment">&lt;!--  不使用https p:useSSL="false"  使用https  p:sslConfig-ref="sslConfig" --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置连接地址等与链接相关的信息--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"abstractConnectionConfig"</span> <span class="attr">abstract</span>=<span class="string">"true"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.ldaptive.ConnectionConfig"</span>  </span></span><br><span class="line"><span class="tag">  	  <span class="attr">p:ldapUrl</span>=<span class="string">"ldap://10.18.8.66:389"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">p:useStartTLS</span>=<span class="string">"false"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">p:useSSL</span>=<span class="string">"false"</span> </span></span><br><span class="line"><span class="tag">        /&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"ldapPoolConfig"</span> <span class="attr">class</span>=<span class="string">"org.ldaptive.pool.PoolConfig"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">p:minPoolSize</span>=<span class="string">"300"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">p:maxPoolSize</span>=<span class="string">"600"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">p:validateOnCheckOut</span>=<span class="string">"false"</span>    </span></span><br><span class="line"><span class="tag">        <span class="attr">p:validatePeriodically</span>=<span class="string">"true"</span>    </span></span><br><span class="line"><span class="tag">        <span class="attr">p:validatePeriod</span>=<span class="string">"300"</span> /&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--   支持http ssl时使用</span></span><br><span class="line"><span class="comment">  &lt;bean id="sslConfig" class="org.ldaptive.ssl.SslConfig"&gt;  </span></span><br><span class="line"><span class="comment">      &lt;property name="credentialConfig"&gt;  </span></span><br><span class="line"><span class="comment">          &lt;bean class="org.ldaptive.ssl.X509CredentialConfig"  </span></span><br><span class="line"><span class="comment">          p:trustCertificates="file:/E:/sso/wzyb.crt" /&gt; </span></span><br><span class="line"><span class="comment">      &lt;/property&gt;  </span></span><br><span class="line"><span class="comment">  &lt;/bean&gt;  </span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"pruneStrategy"</span> <span class="attr">class</span>=<span class="string">"org.ldaptive.pool.IdlePruneStrategy"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">p:prunePeriod</span>=<span class="string">"300"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">p:idleTime</span>=<span class="string">"600"</span> /&gt;</span>  </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"searchValidator"</span> <span class="attr">class</span>=<span class="string">"org.ldaptive.pool.SearchValidator"</span> /&gt;</span>  </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"authHandler"</span> <span class="attr">class</span>=<span class="string">"org.ldaptive.auth.PooledBindAuthenticationHandler"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">p:connectionFactory-ref</span>=<span class="string">"bindPooledLdapConnectionFactory"</span> /&gt;</span>  </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bindPooledLdapConnectionFactory"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.ldaptive.pool.PooledConnectionFactory"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">p:connectionPool-ref</span>=<span class="string">"bindConnectionPool"</span> /&gt;</span>  </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bindConnectionPool"</span> <span class="attr">parent</span>=<span class="string">"abstractConnectionPool"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">p:connectionFactory-ref</span>=<span class="string">"bindConnectionFactory"</span> /&gt;</span>  </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bindConnectionFactory"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.ldaptive.DefaultConnectionFactory"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">p:connectionConfig-ref</span>=<span class="string">"bindConnectionConfig"</span> /&gt;</span>  </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bindConnectionConfig"</span> <span class="attr">parent</span>=<span class="string">"abstractConnectionConfig"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
<p>我们这里没有配置https，用的是简单的http方式访问，所以相关的https的配置注释掉了。</p>
<p>这里还有一点需要注意，如果我们在abstractConnectionConfig这个bean的配置中配置了如下属性：</p>
<p>​              p:connectTimeout=”3000”    </p>
<p>配置了超时时间的话，程序依旧可以稳定运行，但是到了设置时间后，后台日志就会疯狂报错，一直报错，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDAP response read timed out, timeout used:3000ms</span><br></pre></td></tr></table></figure>
<p>但是丝毫不影响程序的运行，登陆还是可以登陆的。为了解决这个问题，我也是试了好久，因为网上是真的没有相关资料呀。给我气的，后来发现，我只需要注释掉这个配置就不会报错了，而且程序还是会稳定运行，至少到现在为止还没发现有任何的异常。</p>
<p>对于具体的配置目前还没有研究，先用这把，后续如果要加新的功能，那么肯定是需要深入研究配置的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2018/02/05/CAS结合openldap/" data-id="cjdab4v450004lkbzvqgdcdxw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-DelegatingFilterProxy" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/31/DelegatingFilterProxy/" class="article-date">
  <time datetime="2018-01-30T16:05:54.859Z" itemprop="datePublished">2018-01-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/31/DelegatingFilterProxy/">DelegatingFilterProxy</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近可算把一个项目整完了，然后最近打算来消化下项目中不懂的地方。项目中用到了spring-security来做验证授权，这一块是自己的知识盲区。所以先就来攻克这一块。</p>
<p>我们都知道在使用spring-security的时候都需要在web.xml做如下配置，这样的配置就表明了spring-security实际上是通过过滤器来实现的，很显然利用Filter确实是最好的选择。那么到底是如何通过以下配置，让过滤器和spring-security联系起来的呢，我们就来探讨一下，找到执行这一块的过程，接着，我们就使用spring-security的官方文档来一边学习一边看源码。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>springSecurityFilterChain<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>springSecurityFilterChain<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="DelegatingFilterProxy"><a href="#DelegatingFilterProxy" class="headerlink" title="DelegatingFilterProxy"></a>DelegatingFilterProxy</h3><p>这个类的作用就和他的名字一样，他就是一个起代理作用的过滤器，而真正的拦截器当然就是是spring-security里面的配置咯。但是我们知道，过滤器是由Tomcat来解析加载的，跟Spring容器是没有关系的。</p>
<p>所以我们就带着两个问题来看看这个类：</p>
<p>0.该类是如何完成代理。</p>
<p>1.是如何将过滤器和Spring容器结合起来的。</p>
<p>我们看源码：</p>
<p>先看父类GenericFilterBean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericFilterBean</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">		<span class="title">Filter</span>, <span class="title">BeanNameAware</span>, <span class="title">EnvironmentAware</span>, <span class="title">ServletContextAware</span>, <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<p>他的父类GenericFilterBean实现了很多接口，其中我们最熟悉的就是InitializingBean了。我们知道注入到Spring的Bean，在实例化之后，如果有实现InitializingBean接口的，会调用他的afterPropertiesSet方法。</p>
<p>而我们也注意到虽然GenericFilterBean是一个抽象类，但是他显式的实现了Filter的init方法，而子类DelegatingFilterProxy并没有显式的实现init方法，所以，也就是说当我们向tomcat注册了DelegatingFilterProxy过滤器后，会调用该监过滤器的init方法，而实际上调用的是父类的init方法，我们来看看这个方法做了什么。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">	Assert.notNull(filterConfig, <span class="string">"FilterConfig must not be null"</span>);</span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(<span class="string">"Initializing filter '"</span> + filterConfig.getFilterName() + <span class="string">"'"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>.filterConfig = filterConfig;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set bean properties from init parameters.</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		PropertyValues pvs = <span class="keyword">new</span> FilterConfigPropertyValues(filterConfig, <span class="keyword">this</span>.requiredProperties);</span><br><span class="line">		BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(<span class="keyword">this</span>);</span><br><span class="line">		ResourceLoader resourceLoader = <span class="keyword">new</span> ServletContextResourceLoader(filterConfig.getServletContext());</span><br><span class="line">		bw.registerCustomEditor(Resource.class, <span class="keyword">new</span> ResourceEditor(resourceLoader, <span class="keyword">this</span>.environment));</span><br><span class="line">		initBeanWrapper(bw);</span><br><span class="line">		bw.setPropertyValues(pvs, <span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">		String msg = <span class="string">"Failed to set bean properties on filter '"</span> +</span><br><span class="line">			filterConfig.getFilterName() + <span class="string">"': "</span> + ex.getMessage();</span><br><span class="line">		logger.error(msg, ex);</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> NestedServletException(msg, ex);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Let subclasses do whatever initialization they like.</span></span><br><span class="line">	initFilterBean();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(<span class="string">"Filter '"</span> + filterConfig.getFilterName() + <span class="string">"' configured successfully"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个init()方法主要前面很长一段代码，直到        initFilterBean();之前，都是用来获取Filter配置中的参数即init-param value的配置。我们需要关注的就是initFilterBean();方法，这个方法在父类中是一个抽象方法，具体的实现在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initFilterBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>.delegateMonitor) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.delegate == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// If no target bean name specified, use filter name.</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.targetBeanName == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">this</span>.targetBeanName = getFilterName();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Fetch Spring root application context and initialize the delegate early,</span></span><br><span class="line">			<span class="comment">// if possible. If the root application context will be started after this</span></span><br><span class="line">			<span class="comment">// filter proxy, we'll have to resort to lazy initialization.</span></span><br><span class="line">			WebApplicationContext wac = findWebApplicationContext();</span><br><span class="line">			<span class="keyword">if</span> (wac != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">this</span>.delegate = initDelegate(wac);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们分析下这个方法</p>
<p>0.首先要做一个同步操作。</p>
<p>1.然后进入同步块，如果当前的代理对象为null，查看targetBeanName对象是否为null，targetBeanName属性可以通过在web.xml中的filter中的init-param中配置。一般我们不显式的配置。</p>
<p>2.如果我们没有显式的配置的话，就调用getFilterName方法来得到targetBeanName:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> String <span class="title">getFilterName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">this</span>.filterConfig != <span class="keyword">null</span> ? <span class="keyword">this</span>.filterConfig.getFilterName() : <span class="keyword">this</span>.beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法很简单，如果这时我们没有在filter初始化参数中配置beanName的话，我们就取当前filterName，filterName是filter配置中必须要配置的。</p>
<p>3.得到当前的spring上下文，因为当我们通过ContextLoaderListener这个监听器去初始化Spring容器的时候，会把根上下文当做一个attribute注入到servletContext（即servlet上下文）中，key为WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE，value为根上下文，而我们在过滤器中又能通过FIlterConfig.getServletContext去得到ServletContext，所以我们也就顺理成章的能得到spring上下文了。</p>
<p>4.当前上下文不为空的时候，调用initDelegate(wac);来得到真正用来执行的过滤器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Filter <span class="title">initDelegate</span><span class="params">(WebApplicationContext wac)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">	Filter delegate = wac.getBean(getTargetBeanName(), Filter.class);</span><br><span class="line">	<span class="keyword">if</span> (isTargetFilterLifecycle()) &#123;</span><br><span class="line">		delegate.init(getFilterConfig());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> delegate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法很简单，就是通过限定BeanName以及Bean的类型为Filter来获取bean，而这里的BeanName就是targetName,当没有在filter配置中配置的时候，我们直接用的是filterName，而我们这里的配置的filterName是springSecurityFilterChain。看到这里，你肯定能得出一个结论，<strong>那就是如果你不在filter里配置targetBeanName或者beanName的时候，你的filterName就必须是springSecurityFilterChain</strong>，否则，肯定就无法在Spring找到delegate对象了，而BeanName为springSecurityFilterChain的Bean对象肯定在我们配置spring-security配置的时候以默认的方式注入到了spring，只有这样才说的通。</p>
<p>而对于DelegatingFilterProxy的dofilter方法，我们不用多看，猜也猜得到内部是调用delegate.dofilter方法。</p>
<p>那文章的最后，我们就来找一下到底这个BeanName为springSecurityFilterChain的Bean对象是哪个把，也算为我们之后阅读spring-security模块的代码开个头。</p>
<p>我们知道spring-security的配置是如下的形式：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:security</span>=<span class="string">"http://www.springframework.org/schema/security"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/security</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/security/spring-security.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">http</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/**"</span> <span class="attr">access</span>=<span class="string">"hasRole('USER')"</span>&gt;</span><span class="tag">&lt;/<span class="name">intercept-url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">http</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>而且会使用spring-security命名空间。很明显又是使用了命名空间来解析xml配置。这里我们不赘述整个过程了，我们直接找到解析http节点的BeanDefinitionParser实现类。</p>
<p>这个类就是org.springframework.security.config.http.HttpSecurityBeanDefinitionParser,我们直接看他的parse方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext pc)</span> </span>&#123;</span><br><span class="line">	CompositeComponentDefinition compositeDef = <span class="keyword">new</span> CompositeComponentDefinition(</span><br><span class="line">			element.getTagName(), pc.extractSource(element));</span><br><span class="line">	pc.pushContainingComponent(compositeDef);</span><br><span class="line"></span><br><span class="line">	registerFilterChainProxyIfNecessary(pc, pc.extractSource(element));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Obtain the filter chains and add the new chain to it</span></span><br><span class="line">	BeanDefinition listFactoryBean = pc.getRegistry().getBeanDefinition(</span><br><span class="line">			BeanIds.FILTER_CHAINS);</span><br><span class="line">	List&lt;BeanReference&gt; filterChains = (List&lt;BeanReference&gt;) listFactoryBean</span><br><span class="line">			.getPropertyValues().getPropertyValue(<span class="string">"sourceList"</span>).getValue();</span><br><span class="line"></span><br><span class="line">	filterChains.add(createFilterChain(element, pc));</span><br><span class="line"></span><br><span class="line">	pc.popAndRegisterContainingComponent();</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的具体实现我们先不分析，我们看到他的一个子方法</p>
<p><strong>registerFilterChainProxyIfNecessary</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerFilterChainProxyIfNecessary</span><span class="params">(ParserContext pc, Object source)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (pc.getRegistry().containsBeanDefinition(BeanIds.FILTER_CHAIN_PROXY)) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Not already registered, so register the list of filter chains and the</span></span><br><span class="line">		<span class="comment">// FilterChainProxy</span></span><br><span class="line">		BeanDefinition listFactoryBean = <span class="keyword">new</span> RootBeanDefinition(ListFactoryBean.class);</span><br><span class="line">		listFactoryBean.getPropertyValues().add(<span class="string">"sourceList"</span>, <span class="keyword">new</span> ManagedList());</span><br><span class="line">		pc.registerBeanComponent(<span class="keyword">new</span> BeanComponentDefinition(listFactoryBean,</span><br><span class="line">				BeanIds.FILTER_CHAINS));</span><br><span class="line"></span><br><span class="line">		BeanDefinitionBuilder fcpBldr = BeanDefinitionBuilder</span><br><span class="line">				.rootBeanDefinition(FilterChainProxy.class);</span><br><span class="line">		fcpBldr.getRawBeanDefinition().setSource(source);</span><br><span class="line">		fcpBldr.addConstructorArgReference(BeanIds.FILTER_CHAINS);</span><br><span class="line">		fcpBldr.addPropertyValue(<span class="string">"filterChainValidator"</span>, <span class="keyword">new</span> RootBeanDefinition(</span><br><span class="line">				DefaultFilterChainValidator.class));</span><br><span class="line">		BeanDefinition fcpBean = fcpBldr.getBeanDefinition();</span><br><span class="line">		pc.registerBeanComponent(<span class="keyword">new</span> BeanComponentDefinition(fcpBean,</span><br><span class="line">				BeanIds.FILTER_CHAIN_PROXY));</span><br><span class="line">		pc.getRegistry().registerAlias(BeanIds.FILTER_CHAIN_PROXY,</span><br><span class="line">				BeanIds.SPRING_SECURITY_FILTER_CHAIN);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到倒数第二行代码，将一个Bean注入到spring中，名字为BeanIds.FILTER_CHAIN_PROXY。</p>
<p>接着我们看到方法的最后一行代码，给这个Bean赋一个别名BeanIds.SPRING_SECURITY_FILTER_CHAIN，而对应的值就是springSecurityFilterChain</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** External alias for FilterChainProxy bean, for use in web.xml files */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SPRING_SECURITY_FILTER_CHAIN = <span class="string">"springSecurityFilterChain"</span>;</span><br></pre></td></tr></table></figure>
<p>所以这里也就完成了DelegatingFilterProxy中delegate对象注入到spring容器的过程。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2018/01/31/DelegatingFilterProxy/" data-id="cjd1u5hfp0000ggbz32cguiy9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post---Java中的值传递" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/31/--Java中的值传递/" class="article-date">
  <time datetime="2018-01-30T16:00:55.618Z" itemprop="datePublished">2018-01-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java基础/">Java基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/31/--Java中的值传递/">Java中的引用传递</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近每天都在做面试题，发现还是有很多题是很注重基础的，趁着有点空，就抓紧把一些典型的题目记录下来。</p>
<h3 id="Java中的值传递"><a href="#Java中的值传递" class="headerlink" title="Java中的值传递"></a>Java中的值传递</h3><p>Example 0</p>
<p>我们来看与Java引用传递有关的第一个题目，也是多次出现的一题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wangcc.MyJavaSE.jmm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangeTest</span> </span>&#123;</span><br><span class="line">	String str = <span class="string">"kobe"</span>;</span><br><span class="line">	<span class="keyword">char</span>[] ch = &#123; <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ExchangeTest ex = <span class="keyword">new</span> ExchangeTest();</span><br><span class="line">		ex.change(ex.str, ex.ch);</span><br><span class="line">		System.out.print(ex.str + <span class="string">"and"</span>);</span><br><span class="line">		System.out.println(ex.ch);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String str, <span class="keyword">char</span>[] ch)</span> </span>&#123;</span><br><span class="line">		str = <span class="string">"james"</span>;</span><br><span class="line">		ch[<span class="number">0</span>] = <span class="string">'g'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个程序的输出结果是多少？</p>
<p>答案是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kobeandgbc</span><br></pre></td></tr></table></figure>
<p>这个答案与你的预期相符合吗？</p>
<p>为什么字符串类型的str没有改变而char数组类型的改变了呢？</p>
<p><strong>造成这个的原因，其实就是因为一句话，Java中都是值传递而不是引用传递。</strong></p>
<p>不过如果只是跟你说这句话的，肯定会很蒙。</p>
<p>我们好好的来解析这句话，<strong>在Java中，我们把参数传到方法中的时候，我们都是将当前引用的副本传递到方法中，注意不是引用本身，而是引用的副本。</strong></p>
<p>我们回到当前的方法，当调用ex.change方法时，在虚拟机栈中会创建change方法的栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从执行到调用完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。虚拟机栈是描述Java方法执行的内存模型。局部变量表包括基本数据类型，对象引用和returnAddress，在方法执行前已经确定大小。</p>
<p>这个时候我们把str的引用的副本传递给方法形参str，把ch的引用副本传递给形参ch，再一次强调是副本。</p>
<p>然后执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str = &quot;james&quot;;</span><br></pre></td></tr></table></figure>
<p>这行代码就直接把局部变量表中的str的指向从指向字符串常量池的kobe字符串变成了指向james这个字符串。也就是说，已经把str里的值改变了，原来里面的值是指向kobe的引用，但是现在已经被改成指向james的引用了。</p>
<p>接着执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch[0] = &apos;g&apos;;</span><br></pre></td></tr></table></figure>
<p>我们知道数组对象也是在堆中创建的，而ch[0]=’g’;</p>
<p>这句代码并没有改变局部变量表中ch的指向，他依旧还是那个外部的ch引用的副本。他仅仅是找到ch[0]这个数组对象第一个元素的位置，然后改变其对应的值。可能这样说还是不清楚，换一种说法就是说，你依旧是在同一块堆空间里进行的替换数组第一个元素的值，局部变量表的ch和外部的ch都是指向的同一个堆空间。也就是说外部的ch指向的堆空间的数组第一个元素改变了。所以得到了上述答案。</p>
<p><strong>其实主要的就是要看方法到底有没有更改引用副本的指向，方法里到底是不是还是对同一块堆空间进行操作。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2018/01/31/--Java中的值传递/" data-id="cjdab4v3d0000lkbzkvi7wxhr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post---装饰者模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/31/--装饰者模式/" class="article-date">
  <time datetime="2018-01-30T16:00:55.615Z" itemprop="datePublished">2018-01-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/设计模式/">设计模式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/31/--装饰者模式/">装饰者模式(一)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在复习之前写过的博客，看到Mybatis缓存的部分，想起了Cache的设计用到了装饰者模式，那么刚好我们就来好好看看装饰者模式。</p>
<h3 id="从Mybatis的Cache设计说起"><a href="#从Mybatis的Cache设计说起" class="headerlink" title="从Mybatis的Cache设计说起"></a>从Mybatis的Cache设计说起</h3><p>我们之前已经说过了，要想让Mybatis的二级缓存生效，需要在Mapper文件中加入如下配置。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于这个配置的作用，我们直接引用mybatis官方文档。</p>
<p>这个简单语句的效果如下:</p>
<ul>
<li>映射语句文件中的所有 select 语句将会被缓存。</li>
<li>映射语句文件中的所有 insert,update 和 delete 语句会刷新缓存。</li>
<li>缓存会使用 Least Recently Used(LRU,最近最少使用的)算法来收回。</li>
<li>根据时间表(比如 no Flush Interval,没有刷新间隔), 缓存不会以任何时间顺序 来刷新。</li>
<li>缓存会存储列表集合或对象(无论查询方法返回什么)的 1024 个引用。</li>
<li>缓存会被视为是 read/write(可读/可写)的缓存,意味着对象检索不是共享的,而 且可以安全地被调用者修改,而不干扰其他调用者或线程所做的潜在修改。</li>
</ul>
<p>所有的这些属性都可以通过缓存元素的属性来修改。比如:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span></span></span><br><span class="line"><span class="tag">  <span class="attr">eviction</span>=<span class="string">"FIFO"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">flushInterval</span>=<span class="string">"60000"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">size</span>=<span class="string">"512"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">readOnly</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个更高级的配置创建了一个 FIFO 缓存,并每隔 60 秒刷新,存数结果对象或列表的 512 个引用,而且返回的对象被认为是只读的,因此在不同线程中的调用者之间修改它们会 导致冲突。</p>
<p>可用的收回策略有:</p>
<ul>
<li>LRU – 最近最少使用的:移除最长时间不被使用的对象。</li>
<li>FIFO – 先进先出:按对象进入缓存的顺序来移除它们。</li>
<li>SOFT – 软引用:移除基于垃圾回收器状态和软引用规则的对象。</li>
<li>WEAK – 弱引用:更积极地移除基于垃圾收集器状态和弱引用规则的对象。</li>
</ul>
<p>默认的是 LRU。</p>
<p>flushInterval(刷新间隔)可以被设置为任意的正整数,而且它们代表一个合理的毫秒 形式的时间段。默认情况是不设置,也就是没有刷新间隔,缓存仅仅调用语句时刷新。</p>
<p>size(引用数目)可以被设置为任意正整数,要记住你缓存的对象数目和你运行环境的 可用内存资源数目。默认值是 1024。</p>
<p>readOnly(只读)属性可以被设置为 true 或 false。只读的缓存会给所有调用者返回缓 存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。可读写的缓存 会返回缓存对象的拷贝(通过序列化) 。这会慢一些,但是安全,因此默认是 false。</p>
<h4 id="Mybatis是如何加载Cache配置的"><a href="#Mybatis是如何加载Cache配置的" class="headerlink" title="Mybatis是如何加载Cache配置的"></a>Mybatis是如何加载Cache配置的</h4><p>在Mybatis中，对Mapper配置文件的解析由XMLMapperBuilder来完成。</p>
<p>configurationElement</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configurationElement</span><span class="params">(XNode context)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     String namespace = context.getStringAttribute(<span class="string">"namespace"</span>);</span><br><span class="line">     <span class="keyword">if</span> (namespace.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">   	  <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Mapper's namespace cannot be empty"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     builderAssistant.setCurrentNamespace(namespace);</span><br><span class="line">     cacheRefElement(context.evalNode(<span class="string">"cache-ref"</span>));</span><br><span class="line">     cacheElement(context.evalNode(<span class="string">"cache"</span>));</span><br><span class="line">     parameterMapElement(context.evalNodes(<span class="string">"/mapper/parameterMap"</span>));</span><br><span class="line">     resultMapElements(context.evalNodes(<span class="string">"/mapper/resultMap"</span>));</span><br><span class="line">     sqlElement(context.evalNodes(<span class="string">"/mapper/sql"</span>));</span><br><span class="line">     buildStatementFromContext(context.evalNodes(<span class="string">"select|insert|update|delete"</span>));</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error parsing Mapper XML. Cause: "</span> + e, e);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>我们先看使用默认配置情况下的解析</p>
<pre><code>cacheElement(context.evalNode(&quot;cache&quot;));
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cacheElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">     String type = context.getStringAttribute(<span class="string">"type"</span>, <span class="string">"PERPETUAL"</span>);</span><br><span class="line">     Class&lt;? extends Cache&gt; typeClass = typeAliasRegistry.resolveAlias(type);</span><br><span class="line">     String eviction = context.getStringAttribute(<span class="string">"eviction"</span>, <span class="string">"LRU"</span>);</span><br><span class="line">     Class&lt;? extends Cache&gt; evictionClass = typeAliasRegistry.resolveAlias(eviction);</span><br><span class="line">     Long flushInterval = context.getLongAttribute(<span class="string">"flushInterval"</span>);</span><br><span class="line">     Integer size = context.getIntAttribute(<span class="string">"size"</span>);</span><br><span class="line">     <span class="keyword">boolean</span> readWrite = !context.getBooleanAttribute(<span class="string">"readOnly"</span>, <span class="keyword">false</span>);</span><br><span class="line">     Properties props = context.getChildrenAsProperties();</span><br><span class="line">     builderAssistant.useNewCache(typeClass, evictionClass, flushInterval, size, readWrite, props);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到在cacheElement中，有对cache节点下的属性的值进行读取并作出相应的处理。</p>
<p>然后通过这些处理过的信息调用 builderAssistant.useNewCache方法来创建Cache实例并注册到Configuration中。</p>
<p>我们来看MapperBuilderAssistant中的useNewCache方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Cache <span class="title">useNewCache</span><span class="params">(Class&lt;? extends Cache&gt; typeClass,</span></span></span><br><span class="line"><span class="function"><span class="params">    Class&lt;? extends Cache&gt; evictionClass,</span></span></span><br><span class="line"><span class="function"><span class="params">    Long flushInterval,</span></span></span><br><span class="line"><span class="function"><span class="params">    Integer size,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> readWrite,</span></span></span><br><span class="line"><span class="function"><span class="params">    Properties props)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//如果在配置文件中没有显式指定 就使用PerpetualCache.class</span></span><br><span class="line">  typeClass = valueOrDefault(typeClass, PerpetualCache.class);</span><br><span class="line">  <span class="comment">//如果没有显式指定，LruCache.class</span></span><br><span class="line">  evictionClass = valueOrDefault(evictionClass, LruCache.class);</span><br><span class="line">  <span class="comment">//开始创建一个使用了层层装饰者模式包裹的Cache实例</span></span><br><span class="line">  Cache cache = <span class="keyword">new</span> CacheBuilder(currentNamespace)</span><br><span class="line">      .implementation(typeClass)</span><br><span class="line">      .addDecorator(evictionClass)</span><br><span class="line">      .clearInterval(flushInterval)</span><br><span class="line">      .size(size)</span><br><span class="line">      .readWrite(readWrite)</span><br><span class="line">      .properties(props)</span><br><span class="line">      .build();</span><br><span class="line">  <span class="comment">//将cache加入到configuration中</span></span><br><span class="line">  configuration.addCache(cache);</span><br><span class="line">  currentCache = cache;</span><br><span class="line">  <span class="keyword">return</span> cache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法不难理解，就是先创建一个使用了装饰者模式得到的Cache实例，然后将这个实例注入到configuration中。</p>
<p>所以我们主要看是怎么创建的。</p>
<p>CacheBuilder</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认情况下是PerpetualCache.class，这个一般不会在配置文件中更改</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CacheBuilder <span class="title">implementation</span><span class="params">(Class&lt;? extends Cache&gt; implementation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.implementation = implementation;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//默认的是LruCache 对应的属性是eviction 即设置回收策略</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">LRU – 最近最少使用的:移除最长时间不被使用的对象。</span></span><br><span class="line"><span class="comment">FIFO – 先进先出:按对象进入缓存的顺序来移除它们。</span></span><br><span class="line"><span class="comment">SOFT – 软引用:移除基于垃圾回收器状态和软引用规则的对象。</span></span><br><span class="line"><span class="comment">WEAK – 弱引用:更积极地移除基于垃圾收集器状态和弱引用规则的对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> CacheBuilder <span class="title">addDecorator</span><span class="params">(Class&lt;? extends Cache&gt; decorator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (decorator != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.decorators.add(decorator);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//设置缓存失效时间，默认是不设置  ，以毫秒为单位</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> CacheBuilder <span class="title">clearInterval</span><span class="params">(Long clearInterval)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.clearInterval = clearInterval;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//对应的size属性  默认是1024</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> CacheBuilder <span class="title">size</span><span class="params">(Integer size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.size = size;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125; </span><br><span class="line"><span class="comment">//对应readOnly属性 设置缓存是否为只读 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CacheBuilder <span class="title">readWrite</span><span class="params">(<span class="keyword">boolean</span> readWrite)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.readWrite = readWrite;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//设置相应的自定义配置，通过属性文件</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> CacheBuilder <span class="title">properties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.properties = properties;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Cache <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//使用单个String形参的构造方法来初始化PerpetualCache，构造方法的入参是namesapceName</span></span><br><span class="line">    setDefaultImplementations();</span><br><span class="line"> </span><br><span class="line">    Cache cache = newBaseCacheInstance(implementation, id);</span><br><span class="line">  <span class="comment">//如果有自定义的参数，带上</span></span><br><span class="line">    setCacheProperties(cache);</span><br><span class="line">  <span class="comment">//添加用于设置回收策略的Cache，这里开始了第一次封装Cache</span></span><br><span class="line">    <span class="keyword">if</span> (PerpetualCache.class.equals(cache.getClass())) &#123; <span class="comment">// issue #352, do not apply decorators to custom caches</span></span><br><span class="line">      <span class="keyword">for</span> (Class&lt;? extends Cache&gt; decorator : decorators) &#123;</span><br><span class="line">        cache = newCacheDecoratorInstance(decorator, cache);</span><br><span class="line">        setCacheProperties(cache);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//这里实现了cache装饰类的层层封装</span></span><br><span class="line">      cache = setStandardDecorators(cache);</span><br><span class="line">    &#125; </span><br><span class="line">  <span class="comment">//最后还是封装成一个LoggingCache类型的Cache，这个Cache已经经过层层装饰了</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!LoggingCache.class.isAssignableFrom(cache.getClass())) &#123;</span><br><span class="line">      cache = <span class="keyword">new</span> LoggingCache(cache);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cache;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>来稍微看一下具体的装饰步骤</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Cache <span class="title">newCacheDecoratorInstance</span><span class="params">(Class&lt;? extends Cache&gt; cacheClass, Cache base)</span> </span>&#123;</span><br><span class="line">  Constructor&lt;? extends Cache&gt; cacheConstructor = getCacheDecoratorConstructor(cacheClass);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cacheConstructor.newInstance(base);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">"Could not instantiate cache decorator ("</span> + cacheClass + <span class="string">"). Cause: "</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Cache <span class="title">setStandardDecorators</span><span class="params">(Cache cache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      MetaObject metaCache = SystemMetaObject.forObject(cache);</span><br><span class="line">      <span class="keyword">if</span> (size != <span class="keyword">null</span> &amp;&amp; metaCache.hasSetter(<span class="string">"size"</span>)) &#123;</span><br><span class="line">        metaCache.setValue(<span class="string">"size"</span>, size);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果设置了缓存失效时间,加一个ScheduledCache装饰类</span></span><br><span class="line">      <span class="keyword">if</span> (clearInterval != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cache = <span class="keyword">new</span> ScheduledCache(cache);</span><br><span class="line">        ((ScheduledCache) cache).setClearInterval(clearInterval);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果并不是只读，加一个SerializedCache装饰类</span></span><br><span class="line">      <span class="keyword">if</span> (readWrite) &#123;</span><br><span class="line">        cache = <span class="keyword">new</span> SerializedCache(cache);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//然后加上具有日志功能的装饰类</span></span><br><span class="line">      cache = <span class="keyword">new</span> LoggingCache(cache);</span><br><span class="line">      <span class="comment">//然后加上具有同步功能的装饰类</span></span><br><span class="line">      cache = <span class="keyword">new</span> SynchronizedCache(cache);</span><br><span class="line">      <span class="keyword">return</span> cache;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">"Error building standard cache decorators.  Cause: "</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>通过这个分析，我们可以得到基本的Cache的装饰链</p>
<p>LoggingCache-&gt; SynchronizedCache-&gt;SerializedCache-&gt;LoggingCache-&gt;ScheduledCache-&gt;LRUCache-&gt;PerpetualCache。</p>
<p>也就是说其实最后最终调用的还是PerpetualCache里的方法。</p>
<p>最后说一下：加入到configuration的过程。    configuration.addCache(cache);</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCache</span><span class="params">(Cache cache)</span> </span>&#123;</span><br><span class="line">  caches.put(cache.getId(), cache);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>cache.getId()，id是在初始化PerpetualCache这个Cache的时候通过构造方法传入的，id的值是这个Mapper的命名空间名。所以这样我们才能在MappedStatement中找对应的cache.</p>
<p>我们再回头看看我们曾经说过的Mybatis二级缓存。</p>
<p>我们直接看CacheExecutor的query方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">//获取该Mapper命名空间下的缓存</span></span><br><span class="line">  Cache cache = ms.getCache();</span><br><span class="line">  <span class="comment">//如果有，开始准备使用缓存了</span></span><br><span class="line">  <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//如果是select语句，默认情况下不清缓存，但是如果在Mapper文件中有在select配置中配置属性fluchCache为true的话，会执行缓存清理的动作。具体对这个是否需要请缓存配置的解析在XMLStatementBuilder类的parseStatementNode方法中。</span></span><br><span class="line">    flushCacheIfRequired(ms);</span><br><span class="line">    <span class="comment">//如果确定这个select语句使用了Cache并且方法参数中没有resultHandler类型的参数。就使用Cache了</span></span><br><span class="line">    <span class="keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">      ensureNoOutParams(ms, parameterObject, boundSql);</span><br><span class="line">      <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">      <span class="comment">//从缓存中找</span></span><br><span class="line">      List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</span><br><span class="line">      <span class="comment">//如果没找到，去查询</span></span><br><span class="line">      <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">        list = delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">        <span class="comment">//将查询的结果放入Cache中</span></span><br><span class="line">        tcm.putObject(cache, key, list); <span class="comment">// issue #578. Query must be not synchronized to prevent deadlocks</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//返回结果</span></span><br><span class="line">      <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法的大概流程已经在代码块中解释了。</p>
<p>我们主要看下这个过程中对缓存的使用。</p>
<p>先看是否执行缓存清理的方法</p>
<p><strong>flushCacheIfRequired</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushCacheIfRequired</span><span class="params">(MappedStatement ms)</span> </span>&#123;</span><br><span class="line">   Cache cache = ms.getCache();</span><br><span class="line">  <span class="comment">//如果需要清理缓存，update的时候默认清理缓存</span></span><br><span class="line">   <span class="keyword">if</span> (cache != <span class="keyword">null</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;      </span><br><span class="line">     tcm.clear(cache);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(Cache cache)</span> </span>&#123;</span><br><span class="line">   getTransactionalCache(cache).clear();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> TransactionalCache <span class="title">getTransactionalCache</span><span class="params">(Cache cache)</span> </span>&#123;</span><br><span class="line">   TransactionalCache txCache = transactionalCaches.get(cache);</span><br><span class="line">   <span class="keyword">if</span> (txCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">     txCache = <span class="keyword">new</span> TransactionalCache(cache);</span><br><span class="line">     transactionalCaches.put(cache, txCache);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> txCache;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>tcm对应的是一个TransactionalCacheManager对象，可以把他看做一个TransactionalCache池。在CachingExecutor中是这样初始化的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> TransactionalCacheManager tcm = <span class="keyword">new</span> TransactionalCacheManager();</span><br></pre></td></tr></table></figure>
<p>所以在初始化Executor执行器的时候，tcm也就存在了。</p>
<p>TransactionalCacheManager中的getTransactionalCache方法，这个方法很明显是构造一下cache和TransactionalCache的关系，存入Map中，而且TransactionalCache将cache作为构造方法的入参。</p>
<p>所以这里，每一个cache就对应着一个包含cache的TransactionalCache对象。</p>
<p>TransactionalCache的clear方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  reset();</span><br><span class="line">  clearOnCommit = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  clearOnCommit = <span class="keyword">false</span>;</span><br><span class="line">  entriesToRemoveOnCommit.clear();</span><br><span class="line">  entriesToAddOnCommit.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>clear方法最后把clearOnCommit置为true.</p>
<p>并且把entriesToRemoveOnCommit和entriesToAddOnCommit这两个Map中的元素都清空了、。</p>
<p><strong>tcm.putObject(cache, key, list);</strong></p>
<p>将结果放入到缓存的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Cache cache, CacheKey key, Object value)</span> </span>&#123;</span><br><span class="line">  getTransactionalCache(cache).putObject(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用的是TransactionalCache的putObject方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object object)</span> </span>&#123;</span><br><span class="line"><span class="comment">//移除entriesToRemoveOnCommit中key为当前的CacheKey的元素</span></span><br><span class="line">   entriesToRemoveOnCommit.remove(key);</span><br><span class="line">   <span class="comment">//将当前的CacheKey为keey，并且构造一个包含cache，CacheKey和查询结果的AddEntry为Value存进entriesToAddCommit</span></span><br><span class="line">   entriesToAddOnCommit.put(key, <span class="keyword">new</span> AddEntry(delegate, key, object));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>所以到这里呢，putObject方法呢，实际上只是把元素存在位于TranscationCache中的entriesToRemoveOnCommit这个Map中。</p>
<p><strong>注意，此时并没有将查询结果放入到我们之前说的装饰器模式构造的cache中。</strong></p>
<p><strong>tcm.getObject(cache, key);</strong></p>
<p>在缓存中查找是否有当前CacheKey对应的值。</p>
<p>调用的是ransactionalCache的getObject方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (clearOnCommit) <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// issue #146</span></span><br><span class="line">   <span class="keyword">return</span> delegate.getObject(key);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>当clearOnCommit为true的时候就直接返回了，即代表着如果是udpate语句或者设置了flushCache属性为true的话，就甭想着在cache里面找，赶紧再跟数据库做交互呀。</p>
<p>如果不为true，那么就要在cache中去寻找当前CacheKey对应的值了。</p>
<p>而你会发现，之前的putObject并没有把值存入到cache中呀，所以这里根本不用分析了，肯定是找不到的。是的，不信你做个试验，你会发现第二次查询的时候依然是直接跟数据库做交互，不会在缓存中取。</p>
<p><strong>事实上，如果你想要让Mybatis的二级缓存失效，你需要手动的在查询后执行session.commit操作。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    commit(<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">boolean</span> force)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      executor.commit(isCommitOrRollbackRequired(force));</span><br><span class="line">      dirty = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error committing transaction.  Cause: "</span> + e, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当调用无参的commit方法时，force指定是false</span></span><br><span class="line"><span class="comment">使用DefaultSqlSessionFactory的无参openSession()方法时，autoCommit为false</span></span><br><span class="line"><span class="comment">如果使用的是有参的openSession(boolean autoCommit)方法，那就取决于传入的参数了</span></span><br><span class="line"><span class="comment">所以也就是说，如果没有显式的将dirty设置为true的时候方法返回false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">***注意  在调用update方法的时候，会把dirty设置为true，这时候方法就会返回true了。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isCommitOrRollbackRequired</span><span class="params">(<span class="keyword">boolean</span> force)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (!autoCommit &amp;&amp; dirty) || force;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，其实session.commit()实际上调用的是executor的commit方法。而具体传什么参数给executor的commit方法是由isCommitOrRollbackRequired方法决定的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">boolean</span> required)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    delegate.commit(required);</span><br><span class="line">    tcm.commit();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BaseExecutor</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">boolean</span> required)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (closed) <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Cannot commit, transaction is already closed"</span>);</span><br><span class="line">  <span class="comment">//清理一级缓存</span></span><br><span class="line">    clearLocalCache();</span><br><span class="line">  <span class="comment">//BatchExecutor有重写这个方法里的具体方法，目前没有用到，先不分析</span></span><br><span class="line">    flushStatements();</span><br><span class="line">  <span class="comment">//这里就执行      connection.commit();操作 非查询数据的时候会用到</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (required) &#123;</span><br><span class="line">      transaction.commit();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>我们这里不去过多的分析executor的commit()方法。</p>
<p>而是要分析</p>
<p><strong>tcm.commit();</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (TransactionalCache txCache : transactionalCaches.values()) &#123;</span><br><span class="line">     txCache.commit();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>调用这个会话中的TransactionalCache池里的所有TransactionalCache的commit()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//如果clearOnCommit为true，那么就清理掉所有的放在cache里的数据</span></span><br><span class="line">  <span class="keyword">if</span> (clearOnCommit) &#123;</span><br><span class="line">    delegate.clear();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//将要从cache中要移除的元素移除了</span></span><br><span class="line">    <span class="keyword">for</span> (RemoveEntry entry : entriesToRemoveOnCommit.values()) &#123;</span><br><span class="line">      entry.commit();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//将要添加到cache中的元素添加到cache中</span></span><br><span class="line">  <span class="keyword">for</span> (AddEntry entry : entriesToAddOnCommit.values()) &#123;</span><br><span class="line">    entry.commit();</span><br><span class="line">  &#125;</span><br><span class="line">  reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AddEntry是TransactionalCache的一个静态内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddEntry</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Cache cache;</span><br><span class="line">  <span class="keyword">private</span> Object key;</span><br><span class="line">  <span class="keyword">private</span> Object value;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AddEntry</span><span class="params">(Cache cache, Object key, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cache = cache;</span><br><span class="line">    <span class="keyword">this</span>.key = key;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cache.putObject(key, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显他的commit方法就是在调用cache的putObject方法。</p>
<p>那么这个putObject方法就是我们要看的。</p>
<p>LoggingCache</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object object)</span> </span>&#123;</span><br><span class="line">   delegate.putObject(key, object);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>我们一开始说了，我们得到的cache是一个LoggingCache实例。他的delegate属性是SynchronizedCache,他保证放入数据时候的线程安全。而如果没有设置readOnly为true的时候，会接着调用SerializedCache来做一个序列化的操作。如果设置了缓存过时时间，会调用ScheduledCache来做一个查看是否缓存失效的判断。接着就到了设置回收策略的Cache，我们这里默认是LRUCache，即最近最少使用，内部是使用LinkedHashMap实现的，并不复杂，回收策略是必须的，因为缓存不可能无限大，一定要设置一个max值。然后才到PerpetualCache，这才到了我们把CacheKey和查询结果存放起来的类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">private</span> Map&lt;Object, Object&gt; cache = <span class="keyword">new</span> HashMap&lt;Object, Object&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">   cache.put(key, value);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>很简单，就是把键值对放到cache这个Map中。</p>
<p>而对于delegate.getObject(key);的具体过程，当然是和delegate.putObject(key, object);相似的，就不细说了。</p>
<p>这里我们看到了每一个Cache都有自己的功能，而PerpetualCache只有最原始的存放数据和得到数据的功能。为了让Cache的功能更强大，我们使用了装饰者模式来一步步的丰富Cache的功能。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2018/01/31/--装饰者模式/" data-id="cjd1tzd2h0001d0bzx76nysvv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CAS/">CAS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java-WEB/">Java WEB</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaWEB/">JavaWEB</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java基础/">Java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mybatis/">Mybatis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringMVC/">SpringMVC</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js-css/">js&&css</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/02/06/Spring事务实现的四种方式/">Spring事务实现之编程式事务</a>
          </li>
        
          <li>
            <a href="/2018/02/06/Spring事务管理/">Spring事务管理</a>
          </li>
        
          <li>
            <a href="/2018/02/06/使用代理代理技术完成Spring事务管理/">Spring事务管理之AOP方法</a>
          </li>
        
          <li>
            <a href="/2018/02/05/CAS简单实例/">CAS简单实例</a>
          </li>
        
          <li>
            <a href="/2018/02/05/CAS/">CAS</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>