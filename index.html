<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>迷途书童的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="厚积薄发">
<meta property="og:type" content="website">
<meta property="og:title" content="迷途书童的博客">
<meta property="og:url" content="https://cong96.github.io/index.html">
<meta property="og:site_name" content="迷途书童的博客">
<meta property="og:description" content="厚积薄发">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="迷途书童的博客">
<meta name="twitter:description" content="厚积薄发">
  
    <link rel="alternate" href="/atom.xml" title="迷途书童的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">迷途书童的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">一天进步一点</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://cong96.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-CAS简单实例" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/05/CAS简单实例/" class="article-date">
  <time datetime="2018-02-05T14:22:29.691Z" itemprop="datePublished">2018-02-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CAS/">CAS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/05/CAS简单实例/">CAS简单实例</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="CAS-Server部署"><a href="#CAS-Server部署" class="headerlink" title="CAS Server部署"></a>CAS Server部署</h3><p>在了解了CAS是什么以及CAS的作用之后，我们可以开始体验对CAS的使用了。</p>
<p>首先下载CAS Server，下载路径：<a href="http://developer.jasig.org/cas/" target="_blank" rel="noopener">http://developer.jasig.org/cas/</a></p>
<p>当然也可以在github上下载cas server,但是放在github上的版本不再是用maven部署的项目了。</p>
<p>所以，如果你习惯使用maven，然后对版本没有太高的要求，可以在上面的网站下载，我们这里选用cas server 4.0版本。</p>
<p>然后我们将cas-server解压，将多模块maven项目导入到Eclipse。</p>
<p>cas server默认支持的请求方式是https ssl，所以如果我们想要使用简单的http请求来测试，那么我们需要对cas-server-webapp这个Maven项目里面的配置文件进行更改。</p>
<p><strong>修改配置</strong></p>
<p>0.修改 WEB-INF/deployerConfigContext.xml </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"proxyAuthenticationHandler"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"org.jasig.cas.authentication.handler.support.HttpBasedServiceCredentialsAuthenticationHandler"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:httpClient-ref</span>=<span class="string">"httpClient"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>中添加 p:requireSecure=”false”</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"proxyAuthenticationHandler"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"org.jasig.cas.authentication.handler.support.HttpBasedServiceCredentialsAuthenticationHandler"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:httpClient-ref</span>=<span class="string">"httpClient"</span> <span class="attr">p:requireSecure</span>=<span class="string">"false"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>1.修改WEB-INF/spring-configuration/ticketGrantingTicketCookieGenerator.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"ticketGrantingTicketCookieGenerator"</span> <span class="attr">class</span>=<span class="string">"org.jasig.cas.web.support.CookieRetrievingCookieGenerator"</span></span></span><br><span class="line"><span class="tag">		<span class="attr">p:cookieSecure</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">		<span class="attr">p:cookieMaxAge</span>=<span class="string">"-1"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">p:cookieName</span>=<span class="string">"CASTGC"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">p:cookiePath</span>=<span class="string">"/cas"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>将p:cookieSecure=”true”修改为p:cookieSecure=”false”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;ticketGrantingTicketCookieGenerator&quot; class=&quot;org.jasig.cas.web.support.CookieRetrievingCookieGenerator&quot;</span><br><span class="line">		p:cookieSecure=&quot;false&quot;</span><br><span class="line">		p:cookieMaxAge=&quot;-1&quot;</span><br><span class="line">	p:cookieName=&quot;CASTGC&quot;</span><br><span class="line">	p:cookiePath=&quot;/cas&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>2.修改WEB-INF/spring-configuration/warnCookieGenerator.xml </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"warnCookieGenerator"</span> <span class="attr">class</span>=<span class="string">"org.jasig.cas.web.support.CookieRetrievingCookieGenerator"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">p:cookieSecure</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">p:cookieMaxAge</span>=<span class="string">"-1"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">p:cookieName</span>=<span class="string">"CASPRIVACY"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">p:cookiePath</span>=<span class="string">"/cas"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>也是将p:cookieSecure=”true”修改为p:cookieSecure=”false”</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"warnCookieGenerator"</span> <span class="attr">class</span>=<span class="string">"org.jasig.cas.web.support.CookieRetrievingCookieGenerator"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">p:cookieSecure</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">p:cookieMaxAge</span>=<span class="string">"-1"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">p:cookieName</span>=<span class="string">"CASPRIVACY"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">p:cookiePath</span>=<span class="string">"/cas"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>3.如果该程序所在的tomcat服务器端口不是默认的8080，那么就需要修改WEB-INF/cas.properties</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.name=http://localhost:8080</span><br></pre></td></tr></table></figure>
<p>将端口修改，当然如果有在hosts里配置域名的话，也可以把localhost替换成域名。</p>
<p>完成了这些后，我们就可以用tomcat来启动cas-server-webapp这个项目了。</p>
<h3 id="访问CAS"><a href="#访问CAS" class="headerlink" title="访问CAS"></a>访问CAS</h3><p>我并没有更改tomcat端口，也咩有使用域名，这个时候我们访问10.18.1.132:9060/cas/</p>
<p>我们会来到默认的登陆页面。</p>
<p><strong>注意</strong>：在某些教程中，你会看到说我们只需要输入相同的用户名和密码就可以通过校验，但是在cas server 4.0及以后的版本中，用户名和密码不再是简单的相同就可以通过验证了，而是给出了一个配置文件用来配置默认的登陆用户名和密码，系统默认设置的只有一个  casuser/Mellon。这个配置在deployerConfigContext.xml，primaryAuthenticationHandler这个bean中。</p>
<h3 id="CAS-Client部署"><a href="#CAS-Client部署" class="headerlink" title="CAS Client部署"></a>CAS Client部署</h3><p>我们现在已经把Server端部署好了，接下来就需要部署client端了。</p>
<p>0.新建两个Maven web app项目:testapp1,testapp2。</p>
<p>1.对两个项目就行简单配置。</p>
<p>首先我们需要引入cas-client的相关包。</p>
<p>在pom.xml中加入</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jasig.cas.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cas-client-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后我们需要在web.xml中配置一些过滤器以及监听器。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.jasig.cas.client.session.SingleSignOutHttpSessionListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CAS Single Sign Out Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.jasig.cas.client.session.SingleSignOutFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CAS Single Sign Out Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CAS Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.jasig.cas.client.authentication.AuthenticationFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>casServerLoginUrl<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>http://localhost:8080/cas/login<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>serverName<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>http://localhost:8081/<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CAS Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CAS Validation Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        org.jasig.cas.client.validation.Cas20ProxyReceivingTicketValidationFilter</span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>casServerUrlPrefix<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>http://localhost:8080/cas<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>serverName<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>http://localhost:8081<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CAS Validation Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CAS HttpServletRequest Wrapper Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        org.jasig.cas.client.util.HttpServletRequestWrapperFilter</span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CAS HttpServletRequest Wrapper Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CAS Assertion Thread Local Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.jasig.cas.client.util.AssertionThreadLocalFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CAS Assertion Thread Local Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：CAS FIlter和CAS Validation Filter中对serverName这个init-param的value是不一样的，具体不同看配置。</p>
<p>还有这里我们使用了不同的端口，这里的tomcat端口已经不是8080了，而是8081。</p>
<p>而对于testapp2的配置，我们只需要做下相应的更改就好了，testapp2对应的tomcat端口为8082。</p>
<h3 id="如何在不同的tomcat端口中部署项目"><a href="#如何在不同的tomcat端口中部署项目" class="headerlink" title="如何在不同的tomcat端口中部署项目"></a>如何在不同的tomcat端口中部署项目</h3><p>当我们对testapp1和testapp2都部署好了之后。我们就需要在tomcat中启动他们，但是与我们平时启动项目不一样，因为我们不想再让这两个项目在默认的tomcat端口中部署了。那需要怎样部署呢？</p>
<p>我是使用Eclipse里的Tomcat来进行部署的，也就是需要对servers这个项目的server.xml进行更改。</p>
<p>添加以下内容。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Service</span> <span class="attr">name</span>=<span class="string">"Catalina1"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;<span class="name">Connector</span> <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span> <span class="attr">port</span>=<span class="string">"8081"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag">			<span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8001"</span> <span class="attr">protocol</span>=<span class="string">"AJP/1.3"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;<span class="name">Engine</span> <span class="attr">defaultHost</span>=<span class="string">"localhost"</span> <span class="attr">name</span>=<span class="string">"Catalina1"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			<span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.realm.LockOutRealm"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">				<span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.realm.UserDatabaseRealm"</span></span></span><br><span class="line"><span class="tag">					<span class="attr">resourceName</span>=<span class="string">"UserDatabase"</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">Realm</span>&gt;</span></span><br><span class="line"></span><br><span class="line">			<span class="tag">&lt;<span class="name">Host</span> <span class="attr">appBase</span>=<span class="string">"wtpwebapps"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span> <span class="attr">name</span>=<span class="string">"localhost"</span></span></span><br><span class="line"><span class="tag">				<span class="attr">unpackWARs</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">				<span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.valves.AccessLogValve"</span></span></span><br><span class="line"><span class="tag">					<span class="attr">directory</span>=<span class="string">"logs"</span> <span class="attr">pattern</span>=<span class="string">"%h %l %u %t &amp;quot;%r&amp;quot; %s %b"</span> <span class="attr">prefix</span>=<span class="string">"localhost_access_log."</span></span></span><br><span class="line"><span class="tag">					<span class="attr">suffix</span>=<span class="string">".txt"</span> /&gt;</span></span><br><span class="line">		</span><br><span class="line">				<span class="tag">&lt;<span class="name">Context</span> <span class="attr">docBase</span>=<span class="string">"testapp1"</span> <span class="attr">path</span>=<span class="string">"/testapp1"</span> <span class="attr">reloadable</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">					<span class="attr">source</span>=<span class="string">"org.eclipse.jst.j2ee.server:testapp1"</span> /&gt;</span></span><br><span class="line">			</span><br><span class="line">			<span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Service</span> <span class="attr">name</span>=<span class="string">"Catalina2"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;<span class="name">Connector</span> <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span> <span class="attr">port</span>=<span class="string">"8082"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag">			<span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8002"</span> <span class="attr">protocol</span>=<span class="string">"AJP/1.3"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;<span class="name">Engine</span> <span class="attr">defaultHost</span>=<span class="string">"localhost"</span> <span class="attr">name</span>=<span class="string">"Catalina2"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			<span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.realm.LockOutRealm"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">				<span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.realm.UserDatabaseRealm"</span></span></span><br><span class="line"><span class="tag">					<span class="attr">resourceName</span>=<span class="string">"UserDatabase"</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">Realm</span>&gt;</span></span><br><span class="line"></span><br><span class="line">			<span class="tag">&lt;<span class="name">Host</span> <span class="attr">appBase</span>=<span class="string">"wtpwebapps"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span> <span class="attr">name</span>=<span class="string">"localhost"</span></span></span><br><span class="line"><span class="tag">				<span class="attr">unpackWARs</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">				<span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.valves.AccessLogValve"</span></span></span><br><span class="line"><span class="tag">					<span class="attr">directory</span>=<span class="string">"logs"</span> <span class="attr">pattern</span>=<span class="string">"%h %l %u %t &amp;quot;%r&amp;quot; %s %b"</span> <span class="attr">prefix</span>=<span class="string">"localhost_access_log."</span></span></span><br><span class="line"><span class="tag">					<span class="attr">suffix</span>=<span class="string">".txt"</span> /&gt;</span></span><br><span class="line">		</span><br><span class="line">				<span class="tag">&lt;<span class="name">Context</span> <span class="attr">docBase</span>=<span class="string">"testapp1"</span> <span class="attr">path</span>=<span class="string">"/testapp1"</span> <span class="attr">reloadable</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">					<span class="attr">source</span>=<span class="string">"org.eclipse.jst.j2ee.server:testapp2"</span> /&gt;</span></span><br><span class="line">			</span><br><span class="line">			<span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里我在第一次配置的时候出现了问题，当时是直接把已经部署好了的cas-server的配置粘过来改的。其中Host节点的appBase属性对应的值是webapps,然后我们更改了相应的端口号之后，我们启动Tomcat,发现报错，提示找到不到相应的文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\UM\.metadata\.plugins\org.eclipse.wst.server.core\tmp0\webapps\testapp1</span><br></pre></td></tr></table></figure>
<p>，然后到相应的位置找，确实是没有，但是却在wtpwebapps中找到了，然后把appBase的属性值改为wtpwebapps再运行，发现无误。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2018/02/05/CAS简单实例/" data-id="cjdab4v3n0002lkbzkqj0zfg1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CAS" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/05/CAS/" class="article-date">
  <time datetime="2018-02-05T14:22:29.690Z" itemprop="datePublished">2018-02-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CAS/">CAS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/05/CAS/">CAS</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>转载：<a href="http://blog.csdn.net/javaloveiphone/article/details/52439613" target="_blank" rel="noopener">http://blog.csdn.net/javaloveiphone/article/details/52439613</a></p>
<h3 id="一-CAS是什么"><a href="#一-CAS是什么" class="headerlink" title="一.CAS是什么"></a>一.CAS是什么</h3><p>cas，全称：Central Authentication Service，是有耶鲁大学开发的一个开源的单点登录框架，目前代码放在github上托管。</p>
<ul>
<li><p>什么是单点登录</p>
<p>Single Sign On,简称SSO，SSO使得在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。即一个应用登录了，其他被授权的应用不用再登录。<br>应用例子为：淘宝登录了天猫不用再登录。</p>
</li>
<li><p>CAS的组成</p>
</li>
</ul>
<p>从结构上看，CAS包含两个部分：CAS Server 和CAS Client需要独立部署，主要负责对用户的认证工作；CAS<br>Client负责处理对客户端受保护资源的访问请求，需要登录时，重定向到CAS Server.图1是CAS最基本的协议过程：</p>
<p>CAS Client 与受保护的客户端应用部署在一起，以Filter方式保护 Web 应用的受保护资源，过滤从客户端过来的每一个 Web<br>请求，同时， CAS Client会分析HTTP 请求中是否包请求 Service Ticket( 上图中的 Ticket)<br>，如果没有，则说明该用户是没有经过认证的，于是，CAS Client会重定向用户请求到CAS Server（ Step 2 ）。 Step<br>3是用户认证过程，如果用户提供了正确的Credentials， CAS Server 会产生一个随机的 Service Ticket<br>，然后，缓存该 Ticket ，并且重定向用户到CAS Client（附带刚才产生的Service Ticket）， Service<br>Ticket 是不可以伪造的，最后， Step 5 和 Step6是 CAS Client 和 CAS<br>Server之间完成了一个对用户的身份核实，用Ticket查到 Username ，因为 Ticket是 CAS Server<br>产生的，因此，所以 CAS Server 的判断是毋庸置疑的。</p>
<p>该协议完成了一个很简单的任务，所有与CAS的交互均采用SSL协议，确保ST和TGC的安全性。协议工作过程会有2此重定向过程，但是CAS<br>Client与CAS Server之间进行ticket验证的过程对于用户是透明的。</p>
<p>总结一下，如下：</p>
<p>访问服务： SSO 客户端发送请求访问应用系统提供的服务资源。</p>
<p>定向认证： SSO 客户端会重定向用户请求到 SSO 服务器。</p>
<p>用户认证：用户身份认证。</p>
<p>发放票据： SSO 服务器会产生一个随机的 Service Ticket 。</p>
<p>验证票据： SSO 服务器验证票据 Service Ticket 的合法性，验证通过后，允许客户端访问服务。</p>
<p>传输用户信息： SSO 服务器验证票据通过后，传输用户认证结果信息给客户端。</p>
<h3 id="CAS流程分析"><a href="#CAS流程分析" class="headerlink" title="CAS流程分析"></a>CAS流程分析</h3><p><strong>用户首次登录时流程如下：</strong></p>
<p>1)、用户浏览器访问系统A需登录受限资源，此时进行登录检查，发现未登录，然后进行获取票据操作，发现没有票据。</p>
<p>2)、系统A发现该请求需要登录，将请求重定向到认证中心，获取全局票据操作，没有，进行登录。</p>
<p>3)、认证中心呈现登录页面，用户登录，登录成功后，认证中心重定向请求到系统A，并附上认证通过令牌，此时认证中心同时生成了全局票据。</p>
<p>4)、此时再次进行登录检查，发现未登录，然后再次获取票据操作，此时可以获得票据(令牌)，系统A与认证中心通信，验证令牌有效,证明用户已登录。</p>
<p>5)、系统A将受限资源返给用户。</p>
<p><strong>已登录用户首次访问应用群中系统B时：</strong></p>
<p>1)、浏览器访问另一应用B需登录受限资源，此时进行登录检查，发现未登录，然后进行获取票据操作，发现没有票据。</p>
<p>2)、系统B发现该请求需要登录，将请求重定向到认证中心，获取全局票据操作，获取全局票据，可以获得，认证中心发现已经登录。</p>
<p>3)、认证中心发放临时票据(令牌)，并携带该令牌重定向到系统B。</p>
<p>4)、此时再次进行登录检查，发现未登录，然后再次获取票据操作，此时可以获得票据(令牌)，系统B与认证中心通信，验证令牌有效,证明用户已登录。</p>
<p>5)、系统B将受限资源返回给客户端。</p>
<p>1)、问：系统A是如何发现该请求需要登录重定向到认证中心的？<br>答：用户通过浏览器地址栏访问系统A，系统A(也可以称为CAS客户端)去Cookie中拿JSESSION，即在Cookie中维护的当前回话session的id，如果拿到了，说明用户已经登录，如果未拿到，说明用户未登录。</p>
<p>2)、问：系统A重定向到认证中心，发送了什么信息或者地址变成了什么？<br>答：假如系统A的地址为<code>http://a:8080/</code>，CAS认证中心的服务地址为<code>http://cas.server:8080/</code>，那么重点向前后地址变化为：<code>http://a:8080/</code>————&gt;<code>ttp://cas.server:8080/?service=http://a:8080/</code>，由此可知，重点向到认证中心，认证中心拿到了当前访问客户端的地址。</p>
<p>3)、问：登录成功后，认证中心重定向请求到系统A，认证通过令牌是如何附加发送给系统A的？<br>答：重定向之后的地址栏变成：<code>http://a:8080/?ticket=ST-XXXX-XXX</code>，将票据以ticket为参数名的方式通过地址栏发送给系统A</p>
<p>4)、问：系统A验证令牌，怎样操作证明用户登录的？<br>答：系统A通过地址栏获取ticket的参数值ST票据，然后从后台将ST发送给CAS server认证中心验证，验证ST有效后，CAS server返回当前用户登录的相关信息，系统A接收到返回的用户信息，并为该用户创建session会话，会话id由cookie维护，来证明其已登录。</p>
<p>5)、问：登录B系统，认证中心是如何判断用户已经登录的？<br>答：在系统A登录成功后，用户和认证中心之间建立起了全局会话，这个全局会话就是TGT(Ticket Granting Ticket)，TGT位于CAS服务器端，TGT并没有放在Session中，也就是说，CAS全局会话的实现并没有直接使用Session机制，而是利用了Cookie自己实现的，这个Cookie叫做TGC(Ticket Granting Cookie)，它存放了TGT的id,保存在用户浏览器上。 </p>
<p>用户发送登录系统B的请求，首先会去Cookie中拿JSESSION，因为系统B并未登录过，session会话还未创建，JSESSION的值是拿不到的，然后将请求重定向到CAS认证中心，CAS认证中心先去用户浏览器中拿TGC的值，也就是全局会话id，如果存在则代表用户在认证中心已经登录，附带上认证令牌重定向到系统B。</p>
<p>上面登录状态判断也是这个逻辑。</p>
<p>6)、问：登出的过程，各个系统对当前用户都做了什么？<br>答：认证中心清除当前用户的全局会话TGT，同时清掉cookie中TGT的id：TGC；<br>然后是各个客户端系统，比如系统A、系统B，清除局部会话session，同时清掉cookie中session会话id：jsession</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2018/02/05/CAS/" data-id="cjdab4v3k0001lkbzt3zjk9j1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-数据库基础知识" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/05/数据库基础知识/" class="article-date">
  <time datetime="2018-02-05T14:22:29.689Z" itemprop="datePublished">2018-02-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据库/">数据库</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/05/数据库基础知识/">数据库基础知识</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h3><p>B树，B+树<a href="http://blog.csdn.net/endlu/article/details/51720299" target="_blank" rel="noopener">http://blog.csdn.net/endlu/article/details/51720299</a></p>
<p>索引：<a href="https://www.cnblogs.com/aspwebchh/p/6652855.html" target="_blank" rel="noopener">https://www.cnblogs.com/aspwebchh/p/6652855.html</a></p>
<h3 id="主从表"><a href="#主从表" class="headerlink" title="主从表"></a>主从表</h3><ul>
<li><p><strong>主表</strong></p>
<p>在数据库中建立的表格即Table，其中存在主键(primary key)用于与其它表相关联，并且作为在主表中的唯一性标识。</p>
</li>
<li><p><strong>从表</strong></p>
<p>以主表的主键（primary key）值为外键 (Foreign Key)的表，可以通过外键与主表进行关联查询。从表与主表通过外键进行关联查询。</p>
<p>A表中的一个字段，是B表的主键，那他就可以是A表的外键。</p>
</li>
</ul>
<p>从表数据依赖于主表，一般最后查询数据时把主表与从表进行关联查询。主表可用于存储主要信息，如客户资料（客户编号，客户名称，客户公司，客户单位等），从表用来存储客户扩展信息（客户订单信息，客户地址信息，客户联系方式信息等）</p>
<h3 id="JOIN"><a href="#JOIN" class="headerlink" title="JOIN"></a>JOIN</h3><ul>
<li><p><strong>left join（左连接）</strong></p>
<p>默认加上了outer ，即全名为left outer join</p>
<p>select * from A<br>left join B<br>on A.aID = B.bID</p>
<p>left join是以A表的记录为基础的,A可以看成左表,B可以看成右表,left join是以左表为准的.<br>换句话说,左表(A)的记录将会全部表示出来,而右表(B)只会显示符合搜索条件的记录(例子中为: A.aID = B.bID).<br>B表记录不足的地方均为NULL.</p>
</li>
<li><p><strong>right join(右连接)</strong></p>
<p>select * from A<br>right join B<br>on A.aID = B.bID</p>
<p>以右表(B)为基础的,A表不足的地方用NULL填充.</p>
</li>
<li><p><strong>inner join(等值连接)</strong></p>
<p>select * from A<br>innerjoin B<br>on A.aID = B.bID</p>
</li>
</ul>
<p>只显示出了 A.aID = B.bID的记录.这说明inner join并不以谁为基础,它只显示符合条件的记录.</p>
<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p><strong>outer join一旦加上where条件会变成inner join</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.*,b.*</span><br><span class="line"><span class="keyword">from</span> table1 a</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> table2 b <span class="keyword">on</span> b.X=a.X</span><br><span class="line"><span class="keyword">where</span> XXX</span><br></pre></td></tr></table></figure>
<p>数据库在通过连接两张或多张表来返回记录时，都会生成一张中间的临时表，然后再将这张临时表返回给用户；</p>
<p><strong>where条件是在临时表生成好后，再对临时表进行过滤的条件；</strong></p>
<p>因此：where 条件加上，已经没有left join的含义（必须返回左边表的记录）了，条件不为真的就全部过滤掉。 </p>
<p>需要做如下更改：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.*,tmp.*</span><br><span class="line"><span class="keyword">from</span> table1 a</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span>(</span><br><span class="line">    <span class="keyword">select</span> a.*,b.*</span><br><span class="line">    <span class="keyword">from</span> table1 a</span><br><span class="line">    <span class="keyword">left</span> <span class="keyword">join</span> table2 b <span class="keyword">on</span> b.X=a.X</span><br><span class="line">    <span class="keyword">where</span> XXX</span><br><span class="line">)tmp</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.*,b.*</span><br><span class="line"><span class="keyword">from</span> table1 a</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> table2 b <span class="keyword">on</span> b.X=a.X <span class="keyword">and</span> XX</span><br></pre></td></tr></table></figure>
<p>注意：where XXX去掉，改为链接条件on后面的 and XXX</p>
<p><strong>on条件是在生成临时表时使用的条件，它不管on中的条件是否为真，都会返回左边表的记录</strong></p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><ul>
<li><p><strong>平衡树</strong></p>
<ul>
<li><p><strong>B Tree</strong></p>
<p>B 树是为了磁盘或其它存储设备而设计的一种多叉平衡查找树。</p>
<p>B 树又叫平衡多路查找树。一棵m阶的B 树 (m叉树)的特性如下：</p>
<ol>
<li>树中每个结点最多含有m个孩子（m&gt;=2）；</li>
<li>除根结点和叶子结点外，其它每个结点至少有[ceil(m / 2)]个孩子（其中ceil(x)是一个取上限的函数）；</li>
<li>若根结点不是叶子结点，则至少有2个孩子（特殊情况：没有孩子的根结点，即根结点为叶子结点，整棵树只有一个根节点）；</li>
<li>所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息(可以看做是外部接点或查询失败的接点，实际上这些结点不存在，指向这些结点的指针都为null)；</li>
<li>每个非终端结点中包含有n个关键字信息： (P1，K1，P2，K2，P3，……，Kn，Pn+1)。其中：<br>​       a)   Ki (i=1…n)为关键字，且关键字按顺序升序排序K(i-1)&lt; Ki。<br>​       b)   Pi为指向子树根的接点，且指针P(i)指向子树种所有结点的关键字均小于Ki，但都大于K(i-1)。<br>​       c)   关键字的个数n必须满足： [ceil(m / 2)-1]&lt;= n &lt;= m-1。</li>
</ol>
<p>索引为什么选用B树这种数据结构？<br>因为使用B树查找时，所用的磁盘IO操作次数比平衡二叉树更少，效率也更高。<br>为什么使用B树查找所用的磁盘IO操作次数比平衡二叉树更少？<br>大规模数据存储中，树节点存储的元素数量是有限的（如果元素数量非常多的话，查找就退化成节点内部的线性查找了），这样导致二叉查找树结构由于树的高度过大而造成磁盘I/O读写过于频繁，进而导致查询效率低下。那么我们就需要减少树的高度以提高查找效率。而平衡多路查找树结构B树就满足这样的要求。B树的各种操作能使B树保持较低的高度，从而达到有效减少磁盘IO操作次数。</p>
</li>
<li><p><strong>B+ Tree</strong></p>
<p>B+Tree是应文件系统所需而出的一种B-Tree的变型树，一棵m阶的B+树和m阶的B-树的差异在于:<br>1.有n棵子树的结点中含有n个关键字；<br>2.所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字的记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接；<br>3.所有的非终端结点可以看成是索引部分，结点中仅含有其子树(根结点)中的最大（或最小）关键字；</p>
</li>
<li><p><strong>区别</strong></p>
<p>1) B+-tree的磁盘读写代价更低</p>
<p>B+-tree的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</p>
<p>   举个例子，假设磁盘中的一个盘块容纳16bytes，而一个关键字2bytes，一个关键字具体信息指针2bytes。一棵9阶B-tree(一个结点最多8个关键字)的内部结点需要2个盘快。而B+ 树内部结点只需要1个盘快。当需要把内部结点读入内存中的时候，B 树就比B+ 树多一次盘块查找时间(在磁盘中就是盘片旋转的时间)。</p>
<p>2) B+-tree的查询效率更加稳定</p>
<p>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p>
</li>
</ul>
</li>
<li><p><strong>聚集索引</strong></p>
<p>聚集索引也称为聚簇索引（Clustered Index），聚类索引，簇集索引。</p>
<p>聚集索引是指数据库表行中数据的物理顺序与键值的逻辑（索引）顺序相同。一个表只能有一个聚集索引，因为一个表的物理顺序只有一种情况，所以，对应的聚集索引只能有一个。如果某索引不是聚集索引，则表中的行物理顺序与索引顺序不匹配，与非聚集索引相比，聚集索引有着更快的检索速度。</p>
<p>聚集索引确定表中数据的物理顺序。聚集索引类似于电话簿，按姓氏排列数据。由于聚集索引规定数据在表中的物理存储顺序，因此一个表只能包含一个聚集索引。但该索引可以包含多个列（组合索引），就像电话簿按姓氏和名字进行组织一样。</p>
<p>聚集索引对于那些经常要搜索范围值的列特别有效。使用聚集索引找到包含第一个值的行后，便可以确保包含后续索引值的行在物理相邻。例如，如果应用程序执行的一个查询经常检索某一日期范围内的记录，则使用聚集索引可以迅速找到包含开始日期的行，然后检索表中所有相邻的行，直到到达结束日期。这样有助于提高此类查询的性能。同样，如果对从表中检索的数据进行排序时经常要用到某一列，则可以将该表在该列上聚集（物理排序），避免每次查询该列时都进行排序，从而节省成本。</p>
<p>当索引值唯一时，使用聚集索引查找特定的行也很有效率。例如，使用唯一雇员 ID 列 emp_id 查找特定雇员的最快速的方法，是在 emp_id 列上创建聚集索引或 PRIMARY KEY 约束。</p>
<p>1、含有大量非重复值的列。</p>
<p>2、使用BETWEEN,&gt;,&gt;=,&lt;或&lt;=返回一个范围值的列</p>
<p>3、被连续访问的列</p>
<p>4、返回大型结果集的查询</p>
<p>5、经常被使用连接或GROUP BY子句的查询访问的列</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>动作描述</th>
<th>使用聚集索引</th>
<th>使用非聚集索引</th>
</tr>
</thead>
<tbody>
<tr>
<td>列经常被分组排序</td>
<td>应</td>
<td>应</td>
</tr>
<tr>
<td>返回某范围内的数据</td>
<td>应</td>
<td>不应</td>
</tr>
<tr>
<td>一个或极少不同值</td>
<td>不应</td>
<td>不应</td>
</tr>
<tr>
<td>小数目的不同值</td>
<td>应</td>
<td>不应</td>
</tr>
<tr>
<td>大数目的不同值</td>
<td>不应</td>
<td>应</td>
</tr>
<tr>
<td>频繁更新的列</td>
<td>不应</td>
<td>应</td>
</tr>
<tr>
<td>外键列</td>
<td>应</td>
<td>应</td>
</tr>
<tr>
<td>主键列</td>
<td>应</td>
<td>应</td>
</tr>
<tr>
<td>频繁修改索引列</td>
<td>不应</td>
<td>应</td>
</tr>
</tbody>
</table>
<h3 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h3><p>我们平时建表的时候都会为表加上主键， 在某些关系数据库中， 如果建表时不指定主键，数据库会拒绝建表的语句执行。 事实上， 一个加了主键的表，并不能被称之为「表」。一个没加主键的表，它的数据无序的放置在磁盘存储器上，一行一行的排列的很整齐， 跟我认知中的「表」很接近。如果给表上了主键，那么表在磁盘上的存储结构就由整齐排列的结构转变成了树状结构，也就是上面说的「平衡树」结构，换句话说，就是整个表就变成了一个索引。整个表变成了一个索引，也就是所谓的「聚集索引」。 这就是为什么一个表只能有一个主键， 一个表只能有一个「聚集索引」，因为主键的作用就是把「表」的数据格式转换成「索引（平衡树）」的格式放置。</p>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>当并发事务同时访问一个资源时，有可能导致数据不一致，因此需要一种机制来将数据访问顺序化，以保证数据库数据的一致性。锁就是其中的一种机制。</p>
<p>在计算机科学中，锁是在执行多线程时用于强行限制资源访问的同步机制，即用于在并发控制中保证对互斥要求的满足。</p>
<ul>
<li><p><strong>锁的分类(oracle)</strong></p>
<p>​</p>
</li>
</ul>
<p>一、按操作划分，可分为<code>DML锁</code>、<code>DDL锁</code></p>
<p>二、按锁的粒度划分，可分为表级锁, 页级锁, 行级锁（mysql）</p>
<p>三、按锁级别划分，可分为共享锁、排它锁</p>
<p>四、按加锁方式划分，可分为<code>自动锁</code>、<code>显示锁</code></p>
<p>五、按使用方式划分，可分为乐观锁, 悲观锁<a href="http://www.hollischuang.com/archives/934" target="_blank" rel="noopener">``</a></p>
<p>DML锁（data locks，数据锁），用于保护数据的完整性，其中包括行级锁(Row Locks (TX锁))、表级锁(table lock(TM锁))。 DDL锁（dictionary locks，数据字典锁），用于保护数据库对象的结构，如表、索引等的结构定义。其中包排他DDL锁（Exclusive DDL lock）、共享DDL锁（Share DDL lock）、可中断解析锁（Breakable parse locks）</p>
<h3 id="MySql"><a href="#MySql" class="headerlink" title="MySql"></a>MySql</h3><p>MyISAM是<a href="http://lib.csdn.net/base/mysql" target="_blank" rel="noopener">MySQL</a> 5.5之前版本默认的存储引擎，从5.5之后，InnoDB开始成为MySQL默认的存储引擎。</p>
<p>MyISAM使用B-Tree实现主键索引、唯一索引和非主键索引。</p>
<p>InnoDB中非主键索引使用的是B-Tree数据结构，而主键索引使用的是B+Tree。</p>
<p>在DBMS中，可以按照锁的粒度把数据库锁分为行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎 )。</p>
<ul>
<li><p><strong>MySQL中的行级锁，表级锁，页级锁</strong></p>
<ul>
<li><p><strong>行级锁</strong></p>
<p>行级锁是MySQL中锁粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁和排他锁。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p>
</li>
<li><p><strong>表级锁</strong></p>
<p>表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为<code>表共享读锁</code>（共享锁）与<code>表独占写锁</code>（排他锁）</p>
<p>####特点</p>
<p>开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。</p>
</li>
<li><p><strong>页级锁</strong></p>
<p>页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB支持页级锁</p>
<p>####特点</p>
<p>开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</p>
</li>
</ul>
</li>
<li><p><strong>MySQL中常用存储引擎的锁机制</strong></p>
<p>MyISAM和MEMORY采用表级锁(table-level locking)</p>
<p>BDB采用页面锁(page-level locking)或表级锁，默认为页面锁</p>
<p>InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁</p>
</li>
<li><p><strong>InnoDB中的行锁和表锁</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</span><br></pre></td></tr></table></figure>
<p>​</p>
<p>前面提到过，在Innodb引擎中既支持行锁也支持表锁，那么什么时候会锁住整张表，什么时候或只锁住一行呢？</p>
<p>InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：<strong>只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</strong></p>
<p>在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。</p>
<p><strong>行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁。行级锁的缺点是：由于需要请求大量的锁资源，所以速度慢，内存消耗大。</strong></p>
</li>
<li><p><strong>行级锁与死锁</strong></p>
<p>MyISAM中是不会产生死锁的，因为MyISAM总是一次性获得所需的全部锁，要么全部满足，要么全部等待。而在InnoDB中，锁是逐步获得的，就造成了死锁的可能。</p>
<p>在MySQL中，行级锁并不是直接锁记录，而是锁索引。索引分为主键索引和非主键索引两种，如果一条sql语句操作了主键索引，MySQL就会锁定这条主键索引；如果一条语句操作了非主键索引，MySQL会先锁定该非主键索引，再锁定相关的主键索引。 在UPDATE、DELETE操作时，MySQL不仅锁定WHERE条件扫描过的所有索引记录，而且会锁定相邻的键值，即所谓的next-key locking(防止幻读)。</p>
<p><strong>当两个事务同时执行，一个锁住了主键索引，在等待其他相关索引。另一个锁定了非主键索引，在等待主键索引。这样就会发生死锁。</strong></p>
<p>发生死锁后，InnoDB一般都可以检测到，并使一个事务释放锁回退，另一个获取锁完成事务。</p>
<p>有多种方法可以避免死锁，这里只介绍常见的三种</p>
<p>1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。</p>
<p>2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；</p>
<p>3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2018/02/05/数据库基础知识/" data-id="cjdab4v4i000blkbzd15zw2pl" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CAS结合openldap" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/05/CAS结合openldap/" class="article-date">
  <time datetime="2018-02-05T14:22:29.687Z" itemprop="datePublished">2018-02-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CAS/">CAS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/05/CAS结合openldap/">CAS结合openldap</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="CAS与openldap的结合"><a href="#CAS与openldap的结合" class="headerlink" title="CAS与openldap的结合"></a>CAS与openldap的结合</h3><p>openldap通常会在企业中用来进行用户验证，具体关于openldap的介绍，请看相应的openldap系列的文章，这篇文章只会介绍如何将cas-server4.0版本与openldap结合起来，即让openldap来充当登陆验证的工具。</p>
<p><strong>0.修改配置</strong></p>
<p>想要cas和openldap结合，只需要修改配置即可，当然前提是你已经有了相应的openldap服务器。</p>
<p>在网上对cas与openldap结合的文章很少，有的也是对cas-4.0以前的版本cas-3.x版本与openldap的结合。</p>
<p>所以对于cas-server-4.0与openldap的结合，虽然并不复杂，但是还是值得记下来的。</p>
<p>依旧是修改WEB-INF/deployerConfigContext.xml</p>
<ul>
<li>找到id为authenticationManager的bean，加入ldap验证入口，初始配置如下</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"authenticationManager"</span> <span class="attr">class</span>=<span class="string">"org.jasig.cas.authentication.PolicyBasedAuthenticationManager"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">              <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key-ref</span>=<span class="string">"proxyAuthenticationHandler"</span> <span class="attr">value-ref</span>=<span class="string">"proxyPrincipalResolver"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">                              <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key-ref</span>=<span class="string">"primaryAuthenticationHandler"</span> <span class="attr">value-ref</span>=<span class="string">"primaryPrincipalResolver"</span> /&gt;</span></span><br><span class="line">              </span><br><span class="line">              </span><br><span class="line">          <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"authenticationPolicy"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.jasig.cas.authentication.AnyAuthenticationPolicy"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里构造方法是由一个Map结构配置，就是配置登陆验证的形式，包括对于密码的配置等。</p>
<p>其中的primaryAuthenticationHandler这个key对应着就是我们之前讲过的cas-server-4.0之后，不再是用户名和密码相同即可登陆，而是设置了默认用户名密码，这个默认的用户名密码就是用primaryAuthenticationHandler配置的。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"primaryAuthenticationHandler"</span></span><br><span class="line">      <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.jasig.cas.authentication.AcceptUsersAuthenticationHandler"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"users"</span>&gt;</span><br><span class="line">        &lt;map&gt;</span><br><span class="line">            &lt;entry key=<span class="string">"casuser"</span> value=<span class="string">"Mellon"</span>/&gt;</span><br><span class="line">        &lt;/map&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>所以，如果我们还是想用单纯的用户名密码验证，可以在这里添加值，但是这样无疑显得过于笨拙。</p>
<p>那么我们如果要想添加ldap的验证方式，那么毫无疑问我们要在authenticationManager中的构造方法中注册ldap验证形式。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"authenticationManager"</span> <span class="attr">class</span>=<span class="string">"org.jasig.cas.authentication.PolicyBasedAuthenticationManager"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">               <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">                  | IMPORTANT</span></span><br><span class="line"><span class="comment">                  | Every handler requires a unique name.</span></span><br><span class="line"><span class="comment">                  | If more than one instance of the same handler class is configured, you must explicitly</span></span><br><span class="line"><span class="comment">                  | set its name to something other than its default name (typically the simple class name).</span></span><br><span class="line"><span class="comment">                  --&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key-ref</span>=<span class="string">"proxyAuthenticationHandler"</span> <span class="attr">value-ref</span>=<span class="string">"proxyPrincipalResolver"</span> /&gt;</span></span><br><span class="line">               <span class="comment">&lt;!-- 注释掉默认用户名密码方式</span></span><br><span class="line"><span class="comment">                               &lt;entry key-ref="primaryAuthenticationHandler" value-ref="primaryPrincipalResolver" /&gt;</span></span><br><span class="line"><span class="comment">               </span></span><br><span class="line"><span class="comment">               </span></span><br><span class="line"><span class="comment">                --&gt;</span></span><br><span class="line">               <span class="comment">&lt;!--新增ldap认证的入口 --&gt;</span></span><br><span class="line">       		<span class="tag">&lt;<span class="name">entry</span> <span class="attr">key-ref</span>=<span class="string">"ldapAuthenticationHandler"</span> <span class="attr">value-ref</span>=<span class="string">"proxyPrincipalResolver"</span>/&gt;</span> </span><br><span class="line">           <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"authenticationPolicy"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.jasig.cas.authentication.AnyAuthenticationPolicy"</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>完善ldap验证入口的相关必要配置。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"ldapAuthenticationHandler"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.jasig.cas.authentication.LdapAuthenticationHandler"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">p:principalIdAttribute</span>=<span class="string">"uid"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">c:authenticator-ref</span>=<span class="string">"authenticator"</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"principalAttributeMap"</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;<span class="name">map</span>&gt;</span>  </span><br><span class="line">              <span class="comment">&lt;!--  </span></span><br><span class="line"><span class="comment">                 | This map provides a simple attribute resolution mechanism.  </span></span><br><span class="line"><span class="comment">                 | Keys are LDAP attribute names, values are CAS attribute names.  </span></span><br><span class="line"><span class="comment">                 | Use this facility instead of a PrincipalResolver if LDAP is  </span></span><br><span class="line"><span class="comment">                 | the only attribute source.  </span></span><br><span class="line"><span class="comment">                 --&gt;</span>  </span><br><span class="line">			<span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"uid"</span> <span class="attr">value</span>=<span class="string">"uid"</span> /&gt;</span>  </span><br><span class="line">              <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"mail"</span> <span class="attr">value</span>=<span class="string">"mail"</span> /&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;/<span class="name">map</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"authenticator"</span> <span class="attr">class</span>=<span class="string">"org.ldaptive.auth.Authenticator"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">c:resolver-ref</span>=<span class="string">"dnResolver"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">c:handler-ref</span>=<span class="string">"authHandler"</span> /&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- 配置baseDn  以及指定属性uid--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dnResolver"</span> <span class="attr">class</span>=<span class="string">"org.ldaptive.auth.PooledSearchDnResolver"</span>  </span></span><br><span class="line"><span class="tag">       <span class="attr">p:baseDn</span>=<span class="string">"dc=ulic,dc=com,dc=cn"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">p:allowMultipleDns</span>=<span class="string">"false"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">p:subtreeSearch</span>=<span class="string">"true"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">p:connectionFactory-ref</span>=<span class="string">"searchPooledLdapConnectionFactory"</span>  </span></span><br><span class="line"><span class="tag">      <span class="attr">p:userFilter</span>=<span class="string">"uid=&#123;user&#125;"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"searchPooledLdapConnectionFactory"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.ldaptive.pool.PooledConnectionFactory"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">p:connectionPool-ref</span>=<span class="string">"searchConnectionPool"</span> /&gt;</span>  </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"searchConnectionPool"</span> <span class="attr">parent</span>=<span class="string">"abstractConnectionPool"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">p:connectionFactory-ref</span>=<span class="string">"searchConnectionFactory"</span> /&gt;</span>  </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"searchConnectionFactory"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.ldaptive.DefaultConnectionFactory"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">p:connectionConfig-ref</span>=<span class="string">"searchConnectionConfig"</span> /&gt;</span>  </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"searchConnectionConfig"</span> <span class="attr">parent</span>=<span class="string">"abstractConnectionConfig"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">p:connectionInitializer-ref</span>=<span class="string">"bindConnectionInitializer"</span> /&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--配置userDn和密码 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bindConnectionInitializer"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.ldaptive.BindConnectionInitializer"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">p:bindDn</span>=<span class="string">"cn=Manager,dc=ulic,dc=com,dc=cn"</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"bindCredential"</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.ldaptive.Credential"</span>  </span></span><br><span class="line"><span class="tag">              <span class="attr">c:password</span>=<span class="string">"redhat"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"abstractConnectionPool"</span> <span class="attr">abstract</span>=<span class="string">"true"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.ldaptive.pool.BlockingConnectionPool"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">init-method</span>=<span class="string">"initialize"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">p:poolConfig-ref</span>=<span class="string">"ldapPoolConfig"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">p:blockWaitTime</span>=<span class="string">"3000"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">p:validator-ref</span>=<span class="string">"searchValidator"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">p:pruneStrategy-ref</span>=<span class="string">"pruneStrategy"</span> /&gt;</span>  </span><br><span class="line">  <span class="comment">&lt;!--  不使用https p:useSSL="false"  使用https  p:sslConfig-ref="sslConfig" --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置连接地址等与链接相关的信息--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"abstractConnectionConfig"</span> <span class="attr">abstract</span>=<span class="string">"true"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.ldaptive.ConnectionConfig"</span>  </span></span><br><span class="line"><span class="tag">  	  <span class="attr">p:ldapUrl</span>=<span class="string">"ldap://10.18.8.66:389"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">p:useStartTLS</span>=<span class="string">"false"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">p:useSSL</span>=<span class="string">"false"</span> </span></span><br><span class="line"><span class="tag">        /&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"ldapPoolConfig"</span> <span class="attr">class</span>=<span class="string">"org.ldaptive.pool.PoolConfig"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">p:minPoolSize</span>=<span class="string">"300"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">p:maxPoolSize</span>=<span class="string">"600"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">p:validateOnCheckOut</span>=<span class="string">"false"</span>    </span></span><br><span class="line"><span class="tag">        <span class="attr">p:validatePeriodically</span>=<span class="string">"true"</span>    </span></span><br><span class="line"><span class="tag">        <span class="attr">p:validatePeriod</span>=<span class="string">"300"</span> /&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--   支持http ssl时使用</span></span><br><span class="line"><span class="comment">  &lt;bean id="sslConfig" class="org.ldaptive.ssl.SslConfig"&gt;  </span></span><br><span class="line"><span class="comment">      &lt;property name="credentialConfig"&gt;  </span></span><br><span class="line"><span class="comment">          &lt;bean class="org.ldaptive.ssl.X509CredentialConfig"  </span></span><br><span class="line"><span class="comment">          p:trustCertificates="file:/E:/sso/wzyb.crt" /&gt; </span></span><br><span class="line"><span class="comment">      &lt;/property&gt;  </span></span><br><span class="line"><span class="comment">  &lt;/bean&gt;  </span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"pruneStrategy"</span> <span class="attr">class</span>=<span class="string">"org.ldaptive.pool.IdlePruneStrategy"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">p:prunePeriod</span>=<span class="string">"300"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">p:idleTime</span>=<span class="string">"600"</span> /&gt;</span>  </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"searchValidator"</span> <span class="attr">class</span>=<span class="string">"org.ldaptive.pool.SearchValidator"</span> /&gt;</span>  </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"authHandler"</span> <span class="attr">class</span>=<span class="string">"org.ldaptive.auth.PooledBindAuthenticationHandler"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">p:connectionFactory-ref</span>=<span class="string">"bindPooledLdapConnectionFactory"</span> /&gt;</span>  </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bindPooledLdapConnectionFactory"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.ldaptive.pool.PooledConnectionFactory"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">p:connectionPool-ref</span>=<span class="string">"bindConnectionPool"</span> /&gt;</span>  </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bindConnectionPool"</span> <span class="attr">parent</span>=<span class="string">"abstractConnectionPool"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">p:connectionFactory-ref</span>=<span class="string">"bindConnectionFactory"</span> /&gt;</span>  </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bindConnectionFactory"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.ldaptive.DefaultConnectionFactory"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">p:connectionConfig-ref</span>=<span class="string">"bindConnectionConfig"</span> /&gt;</span>  </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bindConnectionConfig"</span> <span class="attr">parent</span>=<span class="string">"abstractConnectionConfig"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
<p>我们这里没有配置https，用的是简单的http方式访问，所以相关的https的配置注释掉了。</p>
<p>这里还有一点需要注意，如果我们在abstractConnectionConfig这个bean的配置中配置了如下属性：</p>
<p>​              p:connectTimeout=”3000”    </p>
<p>配置了超时时间的话，程序依旧可以稳定运行，但是到了设置时间后，后台日志就会疯狂报错，一直报错，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDAP response read timed out, timeout used:3000ms</span><br></pre></td></tr></table></figure>
<p>但是丝毫不影响程序的运行，登陆还是可以登陆的。为了解决这个问题，我也是试了好久，因为网上是真的没有相关资料呀。给我气的，后来发现，我只需要注释掉这个配置就不会报错了，而且程序还是会稳定运行，至少到现在为止还没发现有任何的异常。</p>
<p>对于具体的配置目前还没有研究，先用这把，后续如果要加新的功能，那么肯定是需要深入研究配置的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2018/02/05/CAS结合openldap/" data-id="cjdab4v450004lkbzvqgdcdxw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-DelegatingFilterProxy" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/31/DelegatingFilterProxy/" class="article-date">
  <time datetime="2018-01-30T16:05:54.859Z" itemprop="datePublished">2018-01-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/31/DelegatingFilterProxy/">DelegatingFilterProxy</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近可算把一个项目整完了，然后最近打算来消化下项目中不懂的地方。项目中用到了spring-security来做验证授权，这一块是自己的知识盲区。所以先就来攻克这一块。</p>
<p>我们都知道在使用spring-security的时候都需要在web.xml做如下配置，这样的配置就表明了spring-security实际上是通过过滤器来实现的，很显然利用Filter确实是最好的选择。那么到底是如何通过以下配置，让过滤器和spring-security联系起来的呢，我们就来探讨一下，找到执行这一块的过程，接着，我们就使用spring-security的官方文档来一边学习一边看源码。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>springSecurityFilterChain<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>springSecurityFilterChain<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="DelegatingFilterProxy"><a href="#DelegatingFilterProxy" class="headerlink" title="DelegatingFilterProxy"></a>DelegatingFilterProxy</h3><p>这个类的作用就和他的名字一样，他就是一个起代理作用的过滤器，而真正的拦截器当然就是是spring-security里面的配置咯。但是我们知道，过滤器是由Tomcat来解析加载的，跟Spring容器是没有关系的。</p>
<p>所以我们就带着两个问题来看看这个类：</p>
<p>0.该类是如何完成代理。</p>
<p>1.是如何将过滤器和Spring容器结合起来的。</p>
<p>我们看源码：</p>
<p>先看父类GenericFilterBean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericFilterBean</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">		<span class="title">Filter</span>, <span class="title">BeanNameAware</span>, <span class="title">EnvironmentAware</span>, <span class="title">ServletContextAware</span>, <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<p>他的父类GenericFilterBean实现了很多接口，其中我们最熟悉的就是InitializingBean了。我们知道注入到Spring的Bean，在实例化之后，如果有实现InitializingBean接口的，会调用他的afterPropertiesSet方法。</p>
<p>而我们也注意到虽然GenericFilterBean是一个抽象类，但是他显式的实现了Filter的init方法，而子类DelegatingFilterProxy并没有显式的实现init方法，所以，也就是说当我们向tomcat注册了DelegatingFilterProxy过滤器后，会调用该监过滤器的init方法，而实际上调用的是父类的init方法，我们来看看这个方法做了什么。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">	Assert.notNull(filterConfig, <span class="string">"FilterConfig must not be null"</span>);</span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(<span class="string">"Initializing filter '"</span> + filterConfig.getFilterName() + <span class="string">"'"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>.filterConfig = filterConfig;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set bean properties from init parameters.</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		PropertyValues pvs = <span class="keyword">new</span> FilterConfigPropertyValues(filterConfig, <span class="keyword">this</span>.requiredProperties);</span><br><span class="line">		BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(<span class="keyword">this</span>);</span><br><span class="line">		ResourceLoader resourceLoader = <span class="keyword">new</span> ServletContextResourceLoader(filterConfig.getServletContext());</span><br><span class="line">		bw.registerCustomEditor(Resource.class, <span class="keyword">new</span> ResourceEditor(resourceLoader, <span class="keyword">this</span>.environment));</span><br><span class="line">		initBeanWrapper(bw);</span><br><span class="line">		bw.setPropertyValues(pvs, <span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">		String msg = <span class="string">"Failed to set bean properties on filter '"</span> +</span><br><span class="line">			filterConfig.getFilterName() + <span class="string">"': "</span> + ex.getMessage();</span><br><span class="line">		logger.error(msg, ex);</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> NestedServletException(msg, ex);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Let subclasses do whatever initialization they like.</span></span><br><span class="line">	initFilterBean();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(<span class="string">"Filter '"</span> + filterConfig.getFilterName() + <span class="string">"' configured successfully"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个init()方法主要前面很长一段代码，直到        initFilterBean();之前，都是用来获取Filter配置中的参数即init-param value的配置。我们需要关注的就是initFilterBean();方法，这个方法在父类中是一个抽象方法，具体的实现在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initFilterBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>.delegateMonitor) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.delegate == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// If no target bean name specified, use filter name.</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.targetBeanName == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">this</span>.targetBeanName = getFilterName();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Fetch Spring root application context and initialize the delegate early,</span></span><br><span class="line">			<span class="comment">// if possible. If the root application context will be started after this</span></span><br><span class="line">			<span class="comment">// filter proxy, we'll have to resort to lazy initialization.</span></span><br><span class="line">			WebApplicationContext wac = findWebApplicationContext();</span><br><span class="line">			<span class="keyword">if</span> (wac != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">this</span>.delegate = initDelegate(wac);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们分析下这个方法</p>
<p>0.首先要做一个同步操作。</p>
<p>1.然后进入同步块，如果当前的代理对象为null，查看targetBeanName对象是否为null，targetBeanName属性可以通过在web.xml中的filter中的init-param中配置。一般我们不显式的配置。</p>
<p>2.如果我们没有显式的配置的话，就调用getFilterName方法来得到targetBeanName:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> String <span class="title">getFilterName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">this</span>.filterConfig != <span class="keyword">null</span> ? <span class="keyword">this</span>.filterConfig.getFilterName() : <span class="keyword">this</span>.beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法很简单，如果这时我们没有在filter初始化参数中配置beanName的话，我们就取当前filterName，filterName是filter配置中必须要配置的。</p>
<p>3.得到当前的spring上下文，因为当我们通过ContextLoaderListener这个监听器去初始化Spring容器的时候，会把根上下文当做一个attribute注入到servletContext（即servlet上下文）中，key为WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE，value为根上下文，而我们在过滤器中又能通过FIlterConfig.getServletContext去得到ServletContext，所以我们也就顺理成章的能得到spring上下文了。</p>
<p>4.当前上下文不为空的时候，调用initDelegate(wac);来得到真正用来执行的过滤器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Filter <span class="title">initDelegate</span><span class="params">(WebApplicationContext wac)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">	Filter delegate = wac.getBean(getTargetBeanName(), Filter.class);</span><br><span class="line">	<span class="keyword">if</span> (isTargetFilterLifecycle()) &#123;</span><br><span class="line">		delegate.init(getFilterConfig());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> delegate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法很简单，就是通过限定BeanName以及Bean的类型为Filter来获取bean，而这里的BeanName就是targetName,当没有在filter配置中配置的时候，我们直接用的是filterName，而我们这里的配置的filterName是springSecurityFilterChain。看到这里，你肯定能得出一个结论，<strong>那就是如果你不在filter里配置targetBeanName或者beanName的时候，你的filterName就必须是springSecurityFilterChain</strong>，否则，肯定就无法在Spring找到delegate对象了，而BeanName为springSecurityFilterChain的Bean对象肯定在我们配置spring-security配置的时候以默认的方式注入到了spring，只有这样才说的通。</p>
<p>而对于DelegatingFilterProxy的dofilter方法，我们不用多看，猜也猜得到内部是调用delegate.dofilter方法。</p>
<p>那文章的最后，我们就来找一下到底这个BeanName为springSecurityFilterChain的Bean对象是哪个把，也算为我们之后阅读spring-security模块的代码开个头。</p>
<p>我们知道spring-security的配置是如下的形式：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:security</span>=<span class="string">"http://www.springframework.org/schema/security"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/security</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/security/spring-security.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">http</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/**"</span> <span class="attr">access</span>=<span class="string">"hasRole('USER')"</span>&gt;</span><span class="tag">&lt;/<span class="name">intercept-url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">http</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>而且会使用spring-security命名空间。很明显又是使用了命名空间来解析xml配置。这里我们不赘述整个过程了，我们直接找到解析http节点的BeanDefinitionParser实现类。</p>
<p>这个类就是org.springframework.security.config.http.HttpSecurityBeanDefinitionParser,我们直接看他的parse方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext pc)</span> </span>&#123;</span><br><span class="line">	CompositeComponentDefinition compositeDef = <span class="keyword">new</span> CompositeComponentDefinition(</span><br><span class="line">			element.getTagName(), pc.extractSource(element));</span><br><span class="line">	pc.pushContainingComponent(compositeDef);</span><br><span class="line"></span><br><span class="line">	registerFilterChainProxyIfNecessary(pc, pc.extractSource(element));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Obtain the filter chains and add the new chain to it</span></span><br><span class="line">	BeanDefinition listFactoryBean = pc.getRegistry().getBeanDefinition(</span><br><span class="line">			BeanIds.FILTER_CHAINS);</span><br><span class="line">	List&lt;BeanReference&gt; filterChains = (List&lt;BeanReference&gt;) listFactoryBean</span><br><span class="line">			.getPropertyValues().getPropertyValue(<span class="string">"sourceList"</span>).getValue();</span><br><span class="line"></span><br><span class="line">	filterChains.add(createFilterChain(element, pc));</span><br><span class="line"></span><br><span class="line">	pc.popAndRegisterContainingComponent();</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的具体实现我们先不分析，我们看到他的一个子方法</p>
<p><strong>registerFilterChainProxyIfNecessary</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerFilterChainProxyIfNecessary</span><span class="params">(ParserContext pc, Object source)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (pc.getRegistry().containsBeanDefinition(BeanIds.FILTER_CHAIN_PROXY)) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Not already registered, so register the list of filter chains and the</span></span><br><span class="line">		<span class="comment">// FilterChainProxy</span></span><br><span class="line">		BeanDefinition listFactoryBean = <span class="keyword">new</span> RootBeanDefinition(ListFactoryBean.class);</span><br><span class="line">		listFactoryBean.getPropertyValues().add(<span class="string">"sourceList"</span>, <span class="keyword">new</span> ManagedList());</span><br><span class="line">		pc.registerBeanComponent(<span class="keyword">new</span> BeanComponentDefinition(listFactoryBean,</span><br><span class="line">				BeanIds.FILTER_CHAINS));</span><br><span class="line"></span><br><span class="line">		BeanDefinitionBuilder fcpBldr = BeanDefinitionBuilder</span><br><span class="line">				.rootBeanDefinition(FilterChainProxy.class);</span><br><span class="line">		fcpBldr.getRawBeanDefinition().setSource(source);</span><br><span class="line">		fcpBldr.addConstructorArgReference(BeanIds.FILTER_CHAINS);</span><br><span class="line">		fcpBldr.addPropertyValue(<span class="string">"filterChainValidator"</span>, <span class="keyword">new</span> RootBeanDefinition(</span><br><span class="line">				DefaultFilterChainValidator.class));</span><br><span class="line">		BeanDefinition fcpBean = fcpBldr.getBeanDefinition();</span><br><span class="line">		pc.registerBeanComponent(<span class="keyword">new</span> BeanComponentDefinition(fcpBean,</span><br><span class="line">				BeanIds.FILTER_CHAIN_PROXY));</span><br><span class="line">		pc.getRegistry().registerAlias(BeanIds.FILTER_CHAIN_PROXY,</span><br><span class="line">				BeanIds.SPRING_SECURITY_FILTER_CHAIN);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到倒数第二行代码，将一个Bean注入到spring中，名字为BeanIds.FILTER_CHAIN_PROXY。</p>
<p>接着我们看到方法的最后一行代码，给这个Bean赋一个别名BeanIds.SPRING_SECURITY_FILTER_CHAIN，而对应的值就是springSecurityFilterChain</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** External alias for FilterChainProxy bean, for use in web.xml files */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SPRING_SECURITY_FILTER_CHAIN = <span class="string">"springSecurityFilterChain"</span>;</span><br></pre></td></tr></table></figure>
<p>所以这里也就完成了DelegatingFilterProxy中delegate对象注入到spring容器的过程。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2018/01/31/DelegatingFilterProxy/" data-id="cjd1u5hfp0000ggbz32cguiy9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post---Java中的值传递" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/31/--Java中的值传递/" class="article-date">
  <time datetime="2018-01-30T16:00:55.618Z" itemprop="datePublished">2018-01-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java基础/">Java基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/31/--Java中的值传递/">Java中的引用传递</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近每天都在做面试题，发现还是有很多题是很注重基础的，趁着有点空，就抓紧把一些典型的题目记录下来。</p>
<h3 id="Java中的值传递"><a href="#Java中的值传递" class="headerlink" title="Java中的值传递"></a>Java中的值传递</h3><p>Example 0</p>
<p>我们来看与Java引用传递有关的第一个题目，也是多次出现的一题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wangcc.MyJavaSE.jmm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangeTest</span> </span>&#123;</span><br><span class="line">	String str = <span class="string">"kobe"</span>;</span><br><span class="line">	<span class="keyword">char</span>[] ch = &#123; <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ExchangeTest ex = <span class="keyword">new</span> ExchangeTest();</span><br><span class="line">		ex.change(ex.str, ex.ch);</span><br><span class="line">		System.out.print(ex.str + <span class="string">"and"</span>);</span><br><span class="line">		System.out.println(ex.ch);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String str, <span class="keyword">char</span>[] ch)</span> </span>&#123;</span><br><span class="line">		str = <span class="string">"james"</span>;</span><br><span class="line">		ch[<span class="number">0</span>] = <span class="string">'g'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个程序的输出结果是多少？</p>
<p>答案是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kobeandgbc</span><br></pre></td></tr></table></figure>
<p>这个答案与你的预期相符合吗？</p>
<p>为什么字符串类型的str没有改变而char数组类型的改变了呢？</p>
<p><strong>造成这个的原因，其实就是因为一句话，Java中都是值传递而不是引用传递。</strong></p>
<p>不过如果只是跟你说这句话的，肯定会很蒙。</p>
<p>我们好好的来解析这句话，<strong>在Java中，我们把参数传到方法中的时候，我们都是将当前引用的副本传递到方法中，注意不是引用本身，而是引用的副本。</strong></p>
<p>我们回到当前的方法，当调用ex.change方法时，在虚拟机栈中会创建change方法的栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从执行到调用完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。虚拟机栈是描述Java方法执行的内存模型。局部变量表包括基本数据类型，对象引用和returnAddress，在方法执行前已经确定大小。</p>
<p>这个时候我们把str的引用的副本传递给方法形参str，把ch的引用副本传递给形参ch，再一次强调是副本。</p>
<p>然后执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str = &quot;james&quot;;</span><br></pre></td></tr></table></figure>
<p>这行代码就直接把局部变量表中的str的指向从指向字符串常量池的kobe字符串变成了指向james这个字符串。也就是说，已经把str里的值改变了，原来里面的值是指向kobe的引用，但是现在已经被改成指向james的引用了。</p>
<p>接着执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch[0] = &apos;g&apos;;</span><br></pre></td></tr></table></figure>
<p>我们知道数组对象也是在堆中创建的，而ch[0]=’g’;</p>
<p>这句代码并没有改变局部变量表中ch的指向，他依旧还是那个外部的ch引用的副本。他仅仅是找到ch[0]这个数组对象第一个元素的位置，然后改变其对应的值。可能这样说还是不清楚，换一种说法就是说，你依旧是在同一块堆空间里进行的替换数组第一个元素的值，局部变量表的ch和外部的ch都是指向的同一个堆空间。也就是说外部的ch指向的堆空间的数组第一个元素改变了。所以得到了上述答案。</p>
<p><strong>其实主要的就是要看方法到底有没有更改引用副本的指向，方法里到底是不是还是对同一块堆空间进行操作。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2018/01/31/--Java中的值传递/" data-id="cjdab4v3d0000lkbzkvi7wxhr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post---装饰者模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/31/--装饰者模式/" class="article-date">
  <time datetime="2018-01-30T16:00:55.615Z" itemprop="datePublished">2018-01-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/设计模式/">设计模式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/31/--装饰者模式/">装饰者模式(一)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在复习之前写过的博客，看到Mybatis缓存的部分，想起了Cache的设计用到了装饰者模式，那么刚好我们就来好好看看装饰者模式。</p>
<h3 id="从Mybatis的Cache设计说起"><a href="#从Mybatis的Cache设计说起" class="headerlink" title="从Mybatis的Cache设计说起"></a>从Mybatis的Cache设计说起</h3><p>我们之前已经说过了，要想让Mybatis的二级缓存生效，需要在Mapper文件中加入如下配置。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于这个配置的作用，我们直接引用mybatis官方文档。</p>
<p>这个简单语句的效果如下:</p>
<ul>
<li>映射语句文件中的所有 select 语句将会被缓存。</li>
<li>映射语句文件中的所有 insert,update 和 delete 语句会刷新缓存。</li>
<li>缓存会使用 Least Recently Used(LRU,最近最少使用的)算法来收回。</li>
<li>根据时间表(比如 no Flush Interval,没有刷新间隔), 缓存不会以任何时间顺序 来刷新。</li>
<li>缓存会存储列表集合或对象(无论查询方法返回什么)的 1024 个引用。</li>
<li>缓存会被视为是 read/write(可读/可写)的缓存,意味着对象检索不是共享的,而 且可以安全地被调用者修改,而不干扰其他调用者或线程所做的潜在修改。</li>
</ul>
<p>所有的这些属性都可以通过缓存元素的属性来修改。比如:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span></span></span><br><span class="line"><span class="tag">  <span class="attr">eviction</span>=<span class="string">"FIFO"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">flushInterval</span>=<span class="string">"60000"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">size</span>=<span class="string">"512"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">readOnly</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个更高级的配置创建了一个 FIFO 缓存,并每隔 60 秒刷新,存数结果对象或列表的 512 个引用,而且返回的对象被认为是只读的,因此在不同线程中的调用者之间修改它们会 导致冲突。</p>
<p>可用的收回策略有:</p>
<ul>
<li>LRU – 最近最少使用的:移除最长时间不被使用的对象。</li>
<li>FIFO – 先进先出:按对象进入缓存的顺序来移除它们。</li>
<li>SOFT – 软引用:移除基于垃圾回收器状态和软引用规则的对象。</li>
<li>WEAK – 弱引用:更积极地移除基于垃圾收集器状态和弱引用规则的对象。</li>
</ul>
<p>默认的是 LRU。</p>
<p>flushInterval(刷新间隔)可以被设置为任意的正整数,而且它们代表一个合理的毫秒 形式的时间段。默认情况是不设置,也就是没有刷新间隔,缓存仅仅调用语句时刷新。</p>
<p>size(引用数目)可以被设置为任意正整数,要记住你缓存的对象数目和你运行环境的 可用内存资源数目。默认值是 1024。</p>
<p>readOnly(只读)属性可以被设置为 true 或 false。只读的缓存会给所有调用者返回缓 存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。可读写的缓存 会返回缓存对象的拷贝(通过序列化) 。这会慢一些,但是安全,因此默认是 false。</p>
<h4 id="Mybatis是如何加载Cache配置的"><a href="#Mybatis是如何加载Cache配置的" class="headerlink" title="Mybatis是如何加载Cache配置的"></a>Mybatis是如何加载Cache配置的</h4><p>在Mybatis中，对Mapper配置文件的解析由XMLMapperBuilder来完成。</p>
<p>configurationElement</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configurationElement</span><span class="params">(XNode context)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     String namespace = context.getStringAttribute(<span class="string">"namespace"</span>);</span><br><span class="line">     <span class="keyword">if</span> (namespace.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">   	  <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Mapper's namespace cannot be empty"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     builderAssistant.setCurrentNamespace(namespace);</span><br><span class="line">     cacheRefElement(context.evalNode(<span class="string">"cache-ref"</span>));</span><br><span class="line">     cacheElement(context.evalNode(<span class="string">"cache"</span>));</span><br><span class="line">     parameterMapElement(context.evalNodes(<span class="string">"/mapper/parameterMap"</span>));</span><br><span class="line">     resultMapElements(context.evalNodes(<span class="string">"/mapper/resultMap"</span>));</span><br><span class="line">     sqlElement(context.evalNodes(<span class="string">"/mapper/sql"</span>));</span><br><span class="line">     buildStatementFromContext(context.evalNodes(<span class="string">"select|insert|update|delete"</span>));</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error parsing Mapper XML. Cause: "</span> + e, e);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>我们先看使用默认配置情况下的解析</p>
<pre><code>cacheElement(context.evalNode(&quot;cache&quot;));
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cacheElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">     String type = context.getStringAttribute(<span class="string">"type"</span>, <span class="string">"PERPETUAL"</span>);</span><br><span class="line">     Class&lt;? extends Cache&gt; typeClass = typeAliasRegistry.resolveAlias(type);</span><br><span class="line">     String eviction = context.getStringAttribute(<span class="string">"eviction"</span>, <span class="string">"LRU"</span>);</span><br><span class="line">     Class&lt;? extends Cache&gt; evictionClass = typeAliasRegistry.resolveAlias(eviction);</span><br><span class="line">     Long flushInterval = context.getLongAttribute(<span class="string">"flushInterval"</span>);</span><br><span class="line">     Integer size = context.getIntAttribute(<span class="string">"size"</span>);</span><br><span class="line">     <span class="keyword">boolean</span> readWrite = !context.getBooleanAttribute(<span class="string">"readOnly"</span>, <span class="keyword">false</span>);</span><br><span class="line">     Properties props = context.getChildrenAsProperties();</span><br><span class="line">     builderAssistant.useNewCache(typeClass, evictionClass, flushInterval, size, readWrite, props);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到在cacheElement中，有对cache节点下的属性的值进行读取并作出相应的处理。</p>
<p>然后通过这些处理过的信息调用 builderAssistant.useNewCache方法来创建Cache实例并注册到Configuration中。</p>
<p>我们来看MapperBuilderAssistant中的useNewCache方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Cache <span class="title">useNewCache</span><span class="params">(Class&lt;? extends Cache&gt; typeClass,</span></span></span><br><span class="line"><span class="function"><span class="params">    Class&lt;? extends Cache&gt; evictionClass,</span></span></span><br><span class="line"><span class="function"><span class="params">    Long flushInterval,</span></span></span><br><span class="line"><span class="function"><span class="params">    Integer size,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> readWrite,</span></span></span><br><span class="line"><span class="function"><span class="params">    Properties props)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//如果在配置文件中没有显式指定 就使用PerpetualCache.class</span></span><br><span class="line">  typeClass = valueOrDefault(typeClass, PerpetualCache.class);</span><br><span class="line">  <span class="comment">//如果没有显式指定，LruCache.class</span></span><br><span class="line">  evictionClass = valueOrDefault(evictionClass, LruCache.class);</span><br><span class="line">  <span class="comment">//开始创建一个使用了层层装饰者模式包裹的Cache实例</span></span><br><span class="line">  Cache cache = <span class="keyword">new</span> CacheBuilder(currentNamespace)</span><br><span class="line">      .implementation(typeClass)</span><br><span class="line">      .addDecorator(evictionClass)</span><br><span class="line">      .clearInterval(flushInterval)</span><br><span class="line">      .size(size)</span><br><span class="line">      .readWrite(readWrite)</span><br><span class="line">      .properties(props)</span><br><span class="line">      .build();</span><br><span class="line">  <span class="comment">//将cache加入到configuration中</span></span><br><span class="line">  configuration.addCache(cache);</span><br><span class="line">  currentCache = cache;</span><br><span class="line">  <span class="keyword">return</span> cache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法不难理解，就是先创建一个使用了装饰者模式得到的Cache实例，然后将这个实例注入到configuration中。</p>
<p>所以我们主要看是怎么创建的。</p>
<p>CacheBuilder</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认情况下是PerpetualCache.class，这个一般不会在配置文件中更改</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CacheBuilder <span class="title">implementation</span><span class="params">(Class&lt;? extends Cache&gt; implementation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.implementation = implementation;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//默认的是LruCache 对应的属性是eviction 即设置回收策略</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">LRU – 最近最少使用的:移除最长时间不被使用的对象。</span></span><br><span class="line"><span class="comment">FIFO – 先进先出:按对象进入缓存的顺序来移除它们。</span></span><br><span class="line"><span class="comment">SOFT – 软引用:移除基于垃圾回收器状态和软引用规则的对象。</span></span><br><span class="line"><span class="comment">WEAK – 弱引用:更积极地移除基于垃圾收集器状态和弱引用规则的对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> CacheBuilder <span class="title">addDecorator</span><span class="params">(Class&lt;? extends Cache&gt; decorator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (decorator != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.decorators.add(decorator);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//设置缓存失效时间，默认是不设置  ，以毫秒为单位</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> CacheBuilder <span class="title">clearInterval</span><span class="params">(Long clearInterval)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.clearInterval = clearInterval;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//对应的size属性  默认是1024</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> CacheBuilder <span class="title">size</span><span class="params">(Integer size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.size = size;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125; </span><br><span class="line"><span class="comment">//对应readOnly属性 设置缓存是否为只读 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CacheBuilder <span class="title">readWrite</span><span class="params">(<span class="keyword">boolean</span> readWrite)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.readWrite = readWrite;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//设置相应的自定义配置，通过属性文件</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> CacheBuilder <span class="title">properties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.properties = properties;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Cache <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//使用单个String形参的构造方法来初始化PerpetualCache，构造方法的入参是namesapceName</span></span><br><span class="line">    setDefaultImplementations();</span><br><span class="line"> </span><br><span class="line">    Cache cache = newBaseCacheInstance(implementation, id);</span><br><span class="line">  <span class="comment">//如果有自定义的参数，带上</span></span><br><span class="line">    setCacheProperties(cache);</span><br><span class="line">  <span class="comment">//添加用于设置回收策略的Cache，这里开始了第一次封装Cache</span></span><br><span class="line">    <span class="keyword">if</span> (PerpetualCache.class.equals(cache.getClass())) &#123; <span class="comment">// issue #352, do not apply decorators to custom caches</span></span><br><span class="line">      <span class="keyword">for</span> (Class&lt;? extends Cache&gt; decorator : decorators) &#123;</span><br><span class="line">        cache = newCacheDecoratorInstance(decorator, cache);</span><br><span class="line">        setCacheProperties(cache);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//这里实现了cache装饰类的层层封装</span></span><br><span class="line">      cache = setStandardDecorators(cache);</span><br><span class="line">    &#125; </span><br><span class="line">  <span class="comment">//最后还是封装成一个LoggingCache类型的Cache，这个Cache已经经过层层装饰了</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!LoggingCache.class.isAssignableFrom(cache.getClass())) &#123;</span><br><span class="line">      cache = <span class="keyword">new</span> LoggingCache(cache);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cache;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>来稍微看一下具体的装饰步骤</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Cache <span class="title">newCacheDecoratorInstance</span><span class="params">(Class&lt;? extends Cache&gt; cacheClass, Cache base)</span> </span>&#123;</span><br><span class="line">  Constructor&lt;? extends Cache&gt; cacheConstructor = getCacheDecoratorConstructor(cacheClass);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cacheConstructor.newInstance(base);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">"Could not instantiate cache decorator ("</span> + cacheClass + <span class="string">"). Cause: "</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Cache <span class="title">setStandardDecorators</span><span class="params">(Cache cache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      MetaObject metaCache = SystemMetaObject.forObject(cache);</span><br><span class="line">      <span class="keyword">if</span> (size != <span class="keyword">null</span> &amp;&amp; metaCache.hasSetter(<span class="string">"size"</span>)) &#123;</span><br><span class="line">        metaCache.setValue(<span class="string">"size"</span>, size);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果设置了缓存失效时间,加一个ScheduledCache装饰类</span></span><br><span class="line">      <span class="keyword">if</span> (clearInterval != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cache = <span class="keyword">new</span> ScheduledCache(cache);</span><br><span class="line">        ((ScheduledCache) cache).setClearInterval(clearInterval);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果并不是只读，加一个SerializedCache装饰类</span></span><br><span class="line">      <span class="keyword">if</span> (readWrite) &#123;</span><br><span class="line">        cache = <span class="keyword">new</span> SerializedCache(cache);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//然后加上具有日志功能的装饰类</span></span><br><span class="line">      cache = <span class="keyword">new</span> LoggingCache(cache);</span><br><span class="line">      <span class="comment">//然后加上具有同步功能的装饰类</span></span><br><span class="line">      cache = <span class="keyword">new</span> SynchronizedCache(cache);</span><br><span class="line">      <span class="keyword">return</span> cache;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">"Error building standard cache decorators.  Cause: "</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>通过这个分析，我们可以得到基本的Cache的装饰链</p>
<p>LoggingCache-&gt; SynchronizedCache-&gt;SerializedCache-&gt;LoggingCache-&gt;ScheduledCache-&gt;LRUCache-&gt;PerpetualCache。</p>
<p>也就是说其实最后最终调用的还是PerpetualCache里的方法。</p>
<p>最后说一下：加入到configuration的过程。    configuration.addCache(cache);</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCache</span><span class="params">(Cache cache)</span> </span>&#123;</span><br><span class="line">  caches.put(cache.getId(), cache);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>cache.getId()，id是在初始化PerpetualCache这个Cache的时候通过构造方法传入的，id的值是这个Mapper的命名空间名。所以这样我们才能在MappedStatement中找对应的cache.</p>
<p>我们再回头看看我们曾经说过的Mybatis二级缓存。</p>
<p>我们直接看CacheExecutor的query方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">//获取该Mapper命名空间下的缓存</span></span><br><span class="line">  Cache cache = ms.getCache();</span><br><span class="line">  <span class="comment">//如果有，开始准备使用缓存了</span></span><br><span class="line">  <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//如果是select语句，默认情况下不清缓存，但是如果在Mapper文件中有在select配置中配置属性fluchCache为true的话，会执行缓存清理的动作。具体对这个是否需要请缓存配置的解析在XMLStatementBuilder类的parseStatementNode方法中。</span></span><br><span class="line">    flushCacheIfRequired(ms);</span><br><span class="line">    <span class="comment">//如果确定这个select语句使用了Cache并且方法参数中没有resultHandler类型的参数。就使用Cache了</span></span><br><span class="line">    <span class="keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">      ensureNoOutParams(ms, parameterObject, boundSql);</span><br><span class="line">      <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">      <span class="comment">//从缓存中找</span></span><br><span class="line">      List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</span><br><span class="line">      <span class="comment">//如果没找到，去查询</span></span><br><span class="line">      <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">        list = delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">        <span class="comment">//将查询的结果放入Cache中</span></span><br><span class="line">        tcm.putObject(cache, key, list); <span class="comment">// issue #578. Query must be not synchronized to prevent deadlocks</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//返回结果</span></span><br><span class="line">      <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法的大概流程已经在代码块中解释了。</p>
<p>我们主要看下这个过程中对缓存的使用。</p>
<p>先看是否执行缓存清理的方法</p>
<p><strong>flushCacheIfRequired</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushCacheIfRequired</span><span class="params">(MappedStatement ms)</span> </span>&#123;</span><br><span class="line">   Cache cache = ms.getCache();</span><br><span class="line">  <span class="comment">//如果需要清理缓存，update的时候默认清理缓存</span></span><br><span class="line">   <span class="keyword">if</span> (cache != <span class="keyword">null</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;      </span><br><span class="line">     tcm.clear(cache);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(Cache cache)</span> </span>&#123;</span><br><span class="line">   getTransactionalCache(cache).clear();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> TransactionalCache <span class="title">getTransactionalCache</span><span class="params">(Cache cache)</span> </span>&#123;</span><br><span class="line">   TransactionalCache txCache = transactionalCaches.get(cache);</span><br><span class="line">   <span class="keyword">if</span> (txCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">     txCache = <span class="keyword">new</span> TransactionalCache(cache);</span><br><span class="line">     transactionalCaches.put(cache, txCache);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> txCache;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>tcm对应的是一个TransactionalCacheManager对象，可以把他看做一个TransactionalCache池。在CachingExecutor中是这样初始化的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> TransactionalCacheManager tcm = <span class="keyword">new</span> TransactionalCacheManager();</span><br></pre></td></tr></table></figure>
<p>所以在初始化Executor执行器的时候，tcm也就存在了。</p>
<p>TransactionalCacheManager中的getTransactionalCache方法，这个方法很明显是构造一下cache和TransactionalCache的关系，存入Map中，而且TransactionalCache将cache作为构造方法的入参。</p>
<p>所以这里，每一个cache就对应着一个包含cache的TransactionalCache对象。</p>
<p>TransactionalCache的clear方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  reset();</span><br><span class="line">  clearOnCommit = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  clearOnCommit = <span class="keyword">false</span>;</span><br><span class="line">  entriesToRemoveOnCommit.clear();</span><br><span class="line">  entriesToAddOnCommit.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>clear方法最后把clearOnCommit置为true.</p>
<p>并且把entriesToRemoveOnCommit和entriesToAddOnCommit这两个Map中的元素都清空了、。</p>
<p><strong>tcm.putObject(cache, key, list);</strong></p>
<p>将结果放入到缓存的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Cache cache, CacheKey key, Object value)</span> </span>&#123;</span><br><span class="line">  getTransactionalCache(cache).putObject(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用的是TransactionalCache的putObject方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object object)</span> </span>&#123;</span><br><span class="line"><span class="comment">//移除entriesToRemoveOnCommit中key为当前的CacheKey的元素</span></span><br><span class="line">   entriesToRemoveOnCommit.remove(key);</span><br><span class="line">   <span class="comment">//将当前的CacheKey为keey，并且构造一个包含cache，CacheKey和查询结果的AddEntry为Value存进entriesToAddCommit</span></span><br><span class="line">   entriesToAddOnCommit.put(key, <span class="keyword">new</span> AddEntry(delegate, key, object));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>所以到这里呢，putObject方法呢，实际上只是把元素存在位于TranscationCache中的entriesToRemoveOnCommit这个Map中。</p>
<p><strong>注意，此时并没有将查询结果放入到我们之前说的装饰器模式构造的cache中。</strong></p>
<p><strong>tcm.getObject(cache, key);</strong></p>
<p>在缓存中查找是否有当前CacheKey对应的值。</p>
<p>调用的是ransactionalCache的getObject方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (clearOnCommit) <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// issue #146</span></span><br><span class="line">   <span class="keyword">return</span> delegate.getObject(key);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>当clearOnCommit为true的时候就直接返回了，即代表着如果是udpate语句或者设置了flushCache属性为true的话，就甭想着在cache里面找，赶紧再跟数据库做交互呀。</p>
<p>如果不为true，那么就要在cache中去寻找当前CacheKey对应的值了。</p>
<p>而你会发现，之前的putObject并没有把值存入到cache中呀，所以这里根本不用分析了，肯定是找不到的。是的，不信你做个试验，你会发现第二次查询的时候依然是直接跟数据库做交互，不会在缓存中取。</p>
<p><strong>事实上，如果你想要让Mybatis的二级缓存失效，你需要手动的在查询后执行session.commit操作。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    commit(<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">boolean</span> force)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      executor.commit(isCommitOrRollbackRequired(force));</span><br><span class="line">      dirty = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error committing transaction.  Cause: "</span> + e, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当调用无参的commit方法时，force指定是false</span></span><br><span class="line"><span class="comment">使用DefaultSqlSessionFactory的无参openSession()方法时，autoCommit为false</span></span><br><span class="line"><span class="comment">如果使用的是有参的openSession(boolean autoCommit)方法，那就取决于传入的参数了</span></span><br><span class="line"><span class="comment">所以也就是说，如果没有显式的将dirty设置为true的时候方法返回false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">***注意  在调用update方法的时候，会把dirty设置为true，这时候方法就会返回true了。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isCommitOrRollbackRequired</span><span class="params">(<span class="keyword">boolean</span> force)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (!autoCommit &amp;&amp; dirty) || force;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，其实session.commit()实际上调用的是executor的commit方法。而具体传什么参数给executor的commit方法是由isCommitOrRollbackRequired方法决定的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">boolean</span> required)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    delegate.commit(required);</span><br><span class="line">    tcm.commit();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BaseExecutor</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">boolean</span> required)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (closed) <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Cannot commit, transaction is already closed"</span>);</span><br><span class="line">  <span class="comment">//清理一级缓存</span></span><br><span class="line">    clearLocalCache();</span><br><span class="line">  <span class="comment">//BatchExecutor有重写这个方法里的具体方法，目前没有用到，先不分析</span></span><br><span class="line">    flushStatements();</span><br><span class="line">  <span class="comment">//这里就执行      connection.commit();操作 非查询数据的时候会用到</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (required) &#123;</span><br><span class="line">      transaction.commit();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>我们这里不去过多的分析executor的commit()方法。</p>
<p>而是要分析</p>
<p><strong>tcm.commit();</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (TransactionalCache txCache : transactionalCaches.values()) &#123;</span><br><span class="line">     txCache.commit();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>调用这个会话中的TransactionalCache池里的所有TransactionalCache的commit()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//如果clearOnCommit为true，那么就清理掉所有的放在cache里的数据</span></span><br><span class="line">  <span class="keyword">if</span> (clearOnCommit) &#123;</span><br><span class="line">    delegate.clear();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//将要从cache中要移除的元素移除了</span></span><br><span class="line">    <span class="keyword">for</span> (RemoveEntry entry : entriesToRemoveOnCommit.values()) &#123;</span><br><span class="line">      entry.commit();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//将要添加到cache中的元素添加到cache中</span></span><br><span class="line">  <span class="keyword">for</span> (AddEntry entry : entriesToAddOnCommit.values()) &#123;</span><br><span class="line">    entry.commit();</span><br><span class="line">  &#125;</span><br><span class="line">  reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AddEntry是TransactionalCache的一个静态内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddEntry</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Cache cache;</span><br><span class="line">  <span class="keyword">private</span> Object key;</span><br><span class="line">  <span class="keyword">private</span> Object value;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AddEntry</span><span class="params">(Cache cache, Object key, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cache = cache;</span><br><span class="line">    <span class="keyword">this</span>.key = key;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cache.putObject(key, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显他的commit方法就是在调用cache的putObject方法。</p>
<p>那么这个putObject方法就是我们要看的。</p>
<p>LoggingCache</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object object)</span> </span>&#123;</span><br><span class="line">   delegate.putObject(key, object);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>我们一开始说了，我们得到的cache是一个LoggingCache实例。他的delegate属性是SynchronizedCache,他保证放入数据时候的线程安全。而如果没有设置readOnly为true的时候，会接着调用SerializedCache来做一个序列化的操作。如果设置了缓存过时时间，会调用ScheduledCache来做一个查看是否缓存失效的判断。接着就到了设置回收策略的Cache，我们这里默认是LRUCache，即最近最少使用，内部是使用LinkedHashMap实现的，并不复杂，回收策略是必须的，因为缓存不可能无限大，一定要设置一个max值。然后才到PerpetualCache，这才到了我们把CacheKey和查询结果存放起来的类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">private</span> Map&lt;Object, Object&gt; cache = <span class="keyword">new</span> HashMap&lt;Object, Object&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">   cache.put(key, value);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>很简单，就是把键值对放到cache这个Map中。</p>
<p>而对于delegate.getObject(key);的具体过程，当然是和delegate.putObject(key, object);相似的，就不细说了。</p>
<p>这里我们看到了每一个Cache都有自己的功能，而PerpetualCache只有最原始的存放数据和得到数据的功能。为了让Cache的功能更强大，我们使用了装饰者模式来一步步的丰富Cache的功能。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2018/01/31/--装饰者模式/" data-id="cjd1tzd2h0001d0bzx76nysvv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post---CSS笔记（一）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/24/--CSS笔记（一）/" class="article-date">
  <time datetime="2018-01-24T15:02:28.061Z" itemprop="datePublished">2018-01-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/js-css/">js&&css</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/24/--CSS笔记（一）/">CSS笔记（一）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在客串前端，哎，那真是基本不会呀，全都忘光了，所以很多东西都相当于重新开始学。所以就把每天新学到的前知识都记录下来吧。</p>
<h3 id="CSS笔记"><a href="#CSS笔记" class="headerlink" title="CSS笔记"></a>CSS笔记</h3><ul>
<li><p>当一个元素由这种class=”A B”，A B中间有空格分开的时候，就代表这个元素既有A的属性，</p>
<p>也有B的属性。那么为什么当要表示一个元素由多个class的属性需要用空格分开呢，那就要问问浏览器的渲染原理了，据说webkit是用c++写的，我们就不深究了。</p>
</li>
<li><p>对于!important</p>
<p>css属性的优先级</p>
<p>1)  !important &gt; 行内样式 &gt;head中style标签定义的样式 &gt; 外部CSS文件中的样式<br>2)  而在这几者内部，写在后面的CSS样式会覆盖前边的（越靠后优先级越高）</p>
</li>
</ul>
<ul>
<li><p>CSS伪类</p>
<p> CSS 伪类用于向某些选择器添加特殊的效果。</p>
<p>a:link {color: #FF0000}        /<em> 未访问的链接 </em>/<br>a:visited {color: #00FF00}    /<em> 已访问的链接 </em>/<br>a:hover {color: #FF00FF}    /<em> 鼠标移动到链接上 </em>/<br>a:active {color: #0000FF}    /<em> 选定的链接 </em>/<br>提示：在 CSS 定义中，a:hover 必须被置于 a:link 和 a:visited 之后，才是有效的。</p>
<p>提示：在 CSS 定义中，a:active 必须被置于 a:hover 之后，才是有效的。</p>
<p>提示：伪类名称对大小写不敏感。</p>
<p>focus伪类<br>:focus 选择器用于选取获得焦点的元素。</p>
<p>提示：接收键盘事件或其他用户输入的元素都允许 :focus 选择器。<br>接收键盘输入事件</p>
</li>
<li><p>&lt;!DOCTYPE&gt;<br>定义和用法<br>&lt;!DOCTYPE&gt; 声明必须是 HTML 文档的第一行，位于 \<html> 标签之前。</html></p>
<p>&lt;!DOCTYPE&gt; 声明不是 HTML 标签；它是指示 web 浏览器关于页面使用哪个 HTML 版本进行编写的指令。</p>
<p>在 HTML 4.01 中，&lt;!DOCTYPE&gt; 声明引用 DTD，因为 HTML 4.01 基于 SGML。DTD 规定了标记语言的规则，这样浏览器才能正确地呈现内容。</p>
<p>HTML5 不基于 SGML，所以不需要引用 DTD。</p>
<p>提示：请始终向 HTML 文档添加 &lt;!DOCTYPE&gt; 声明，这样浏览器才能获知文档类型。</p>
</li>
</ul>
<ul>
<li><p>target属性</p>
<p>\<a> 标签的 target 属性规定在何处打开链接文档。</a></p>
<p>如果在一个 \<a> 标签内包含一个 target 属性，浏览器将会载入和显示用这个标签的 href 属性命名的、名称与这个目标吻合的框架或者窗口中的文档。如果这个指定名称或 id 的框架或者窗口不存在，浏览器将打开一个新的窗口，给这个窗口一个指定的标记，然后将新的文档载入那个窗口。从此以后，超链接文档就可以指向这个新的窗口。</a></p>
<p>_blank</p>
<p>浏览器总在一个新打开、未命名的窗口中载入目标文档。</p>
<p>_self<br>这个目标的值对所有没有指定目标的 <a> 标签是默认目标，它使得目标文档载入并显示在相同的框架或者窗口中作为源文档。这个目标是多余且不必要的，除非和文档标题 <base> 标签中的 target 属性一起使用。</a></p>
<p>_parent<br>这个目标使得文档载入父窗口或者包含来超链接引用的框架的框架集。如果这个引用是在窗口或者在顶级框架中，那么它与目标 _self 等效。</p>
<p>_top<br>这个目标使得文档载入包含这个超链接的窗口，用 _top 目标将会清除所有被包含的框架并将文档载入整个浏览器窗口。</p>
<p>​</p>
</li>
</ul>
<p>这里多说一句，使用鼠标中键点击链接就会自动在新窗口打开。估计有很多人都不知道鼠标滚轮是可以按的，也就是传说中的鼠标中键。</p>
<ul>
<li><p>overflow-x 属性规定是否对内容的左/右边缘进行裁剪 - 如果溢出元素内容区域的话。</p>
<p>overflow-y 属性规定是否对内容的上/下边缘进行裁剪 - 如果溢出元素内容区域的话。</p>
<p>无法在IE8及以下<br>visible    不裁剪内容，可能会显示在内容框之外。<br>hidden    裁剪内容 - 不提供滚动机制。<br>scroll    裁剪内容 - 提供滚动机制。<br>auto    如果溢出框，则应该提供滚动机制。<br>no-display    如果内容不适合内容框，则删除整个框。<br>no-content    如果内容不适合内容框，则隐藏整个内容。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2018/01/24/--CSS笔记（一）/" data-id="cjct7q5nh0000hsbzi6mcs3qv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post---JDK1.8中接口的新特性" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/24/--JDK1.8中接口的新特性/" class="article-date">
  <time datetime="2018-01-24T14:54:35.265Z" itemprop="datePublished">2018-01-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java基础/">Java基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/24/--JDK1.8中接口的新特性/">JDK1.8中接口的新特性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>昨天在牛客网做题，有一道题叫做在JDK8的环境下，接口能不能有具体的方法实现还是只能有抽象方法。</p>
<p>当然原题是个选择题，问法也不是这样问的。如果是这样问的，大家肯定都会想着是不是JDK8有更改了，接口里不只是可以有抽象方法了，也可以有具体的实现了，是的，确实是这样。我们今天就来看看下JDK8中接口的新特性。</p>
<h3 id="JDK8中接口的新特性"><a href="#JDK8中接口的新特性" class="headerlink" title="JDK8中接口的新特性"></a>JDK8中接口的新特性</h3><p>在JDK8环境中，接口中的方法不再是只能有抽象方法，他可以有静态方法和default方法。</p>
<p>我们来看一个例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wangcc.MyJavaSE.jdk8interface;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NewInterface</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"staticMethod"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">defaultMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"defaultMethod"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给出一个接口，在JDK8的环境下，他可以拥有静态方法和default方法，所谓default方法既是使用default关键字来修饰的方法。一个接口可以有多个静态方法和default方法，没有个数限制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wangcc.MyJavaSE.jdk8interface;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleImpl</span> <span class="keyword">implements</span> <span class="title">NewInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"INFO"</span>);</span><br><span class="line">		defaultMethod();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现类只需要实现它的抽象方法即可，JDK8中的接口愈发的像抽象类靠拢的感觉。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wangcc.MyJavaSE.jdk8interface;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewInterfaceTest</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		NewInterface.staticMethod();</span><br><span class="line">		<span class="keyword">new</span> SimpleImpl().defaultMethod();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于静态方法和default方法的调用。</p>
<p>对于静态方法，并没有特殊的地方，在接口中直接由接口名调用，不需要由接口实现类对象来调用。</p>
<p>而对于default方法，很明显是需要实力对象来调用的。而且有一点需要特别注意。</p>
<p>我们知道在Java中是单继承的，但是是可以实现多个接口的，所以，当一个类实现了多个接口之后，如果多个接口有着相同的default方法，即方法名和参数列表相同。那么此时就会出现问题，无法识别到底是调用的哪个接口的方法，这个时候就必须要在实现类里面显式重写default的方法，而关于default的方法的重写,我们在实现类中不需要继续出现default关键字也不能出现default关键字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wangcc.MyJavaSE.jdk8interface;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleImpl</span> <span class="keyword">implements</span> <span class="title">NewInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"INFO"</span>);</span><br><span class="line">		defaultMethod();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">defaultMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Impl default Method"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重写的default方法必须的访问权限必须是public，因为default方法除了没有显式的访问修饰符外，只能用public访问限定符来修饰，而我们知道在Java中，要重写一个方法，访问限定符一定要大于父类或者接口指定的访问限定符范围，而且方法声明处抛出的异常也要大于后者。所以访问权限必须是public。</p>
<p>最后，当default方法和实现类继承的父类的方法同名时，优先调用父类的方法。</p>
<h3 id="strictfp关键字"><a href="#strictfp关键字" class="headerlink" title="strictfp关键字"></a>strictfp关键字</h3><p>今天在看default关键字的时候无意中发现了还有一个名为strictfp的关键字，这个关键字可是之前从来都没有看过额。那今天碰到了就记录一下吧，目前的场景还没有用到过。</p>
<p>自Java2以来，Java语言增加了一个关键字strictfp</p>
<p>strictfp 的意思是FP-strict，也就是说精确浮点的意思。在Java虚拟机进行浮点运算时，如果没有指定strictfp关键字时，Java的编译器以及运 行环境在对浮点运算的表达式是采取一种近似于我行我素的行为来完成这些操作，以致于得到的结果往往无法令你满意。而一旦使用了strictfp来声明一个 类、接口或者方法时，那么所声明的范围内Java的编译器以及运行环境会完全依照浮点规范IEEE-754来执行。因此如果你想让你的浮点运算更加精确， 而且不会因为不同的硬件平台所执行的结果不一致的话，那就请用关键字strictfp。</p>
<p>你可以将一个类、接口以及方法声明为strictfp，但是不允许对接口中的方法以及构造函数声明strictfp关键字。现在这句话就需要更改了，是不允许对接口中的抽象方法使用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2018/01/24/--JDK1.8中接口的新特性/" data-id="cjct6yxxe000044bzpl8htft7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Spring AOP源码​" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/21/Spring AOP源码​/" class="article-date">
  <time datetime="2018-01-21T14:07:52.843Z" itemprop="datePublished">2018-01-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/21/Spring AOP源码​/">Spring AOP源码（一）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>上一篇我们讲解了Spring对aop配置的处理，但是还没有讲Spring中是怎么运用这些配置的。今天我们就俩看下Spring是怎么让这些东西起作用的。</p>
<h3 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h3><p>在讲解之前，我们需要先认识一下BeanPostProcessor接口。</p>
<p>我们回到AbstractApplicationContext的refresh方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">			<span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">			prepareRefresh();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">			prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">				postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">				invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">				registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Initialize message source for this context.</span></span><br><span class="line">				initMessageSource();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">				initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">				onRefresh();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">				registerListeners();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">				finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">				finishRefresh();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">				logger.warn(<span class="string">"Exception encountered during context initialization - cancelling refresh attempt"</span>, ex);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">				destroyBeans();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Reset 'active' flag.</span></span><br><span class="line">				cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Propagate exception to caller.</span></span><br><span class="line">				<span class="keyword">throw</span> ex;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>我们解析aop配置的操作是在        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();中完成的。</p>
<p>我们继续往下看，可以看到有registerBeanPostProcessors(beanFactory);方法</p>
<p>这个方法就是把所有的实现BeanPostProcessor接口的Bean都注入到AbstractBeanFactory的beanPostProcessors属性中。这个跟invokeBeanFactoryPostProcessors方法中将所有实现了BeanFactoryPostProcessor接口的Bean都注入到相应的list集合中并调用其postProcessBeanFactory方法的实现是大体一样的，这里就不再说了，可以看看之前讲解Spring解析属性文件的源码解析部分。</p>
<p>然后我们就直接看到实例化bean的代码段把，在refresh就是    finishBeanFactoryInitialization(beanFactory);的具体实现，我们不一层一层看了，直接看AbstractAutowireCapableBeanFactory类的</p>
<p><strong>initializeBean</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">			AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					invokeAwareMethods(beanName, bean);</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;, getAccessControlContext());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			invokeAwareMethods(beanName, bean);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Object wrappedBean = bean;</span><br><span class="line">		<span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">			wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">					(mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</span><br><span class="line">					beanName, <span class="string">"Invocation of init method failed"</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">			wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> wrappedBean;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法我们已经不陌生了，我们在讲解SpringMVC的时候提到过InitializingBean接口，如果Bean实现了这个接口，会在实例化Bean的时候通过该方法中的invokeInitMethods来调用afterPropertiesSet()方法。而今天在我们关注的BeanPostProcessor接口中，在这个类对应的方法很显然就是</p>
<p>applyBeanPostProcessorsBeforeInitialization和applyBeanPostProcessorsAfterInitialization方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsBeforeInitialization</span><span class="params">(Object existingBean, String beanName)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">	Object result = existingBean;</span><br><span class="line">	<span class="keyword">for</span> (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">		result = beanProcessor.postProcessBeforeInitialization(result, beanName);</span><br><span class="line">		<span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一目了然，就是遍历所有的BeanPostProcessor实现类（已经在registerBeanPostProcessors得到了所有的实现类集合），然后以当前Bean的信息为参数来调用他的postProcessBeforeInitialization方法。</p>
<p>同理如果是applyBeanPostProcessorsAfterInitialization方法，便是遍历后调用postProcessAfterInitialization方法。</p>
<p>分析到这里，很明显我们就可以吧目光转向AspectJAwareAdvisorAutoProxyCreator的这两个方法了。</p>
<h3 id="AspectJAwareAdvisorAutoProxyCreator"><a href="#AspectJAwareAdvisorAutoProxyCreator" class="headerlink" title="AspectJAwareAdvisorAutoProxyCreator"></a>AspectJAwareAdvisorAutoProxyCreator</h3><p>### </p>
<p>在我们上一篇讲解ConfigBeanDefinitionParser的parse方法的时候，说到    configureAutoProxyCreator(parserContext, element);的时候说先不细说，那么到了这一篇就需要从这里入手了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configureAutoProxyCreator</span><span class="params">(ParserContext parserContext, Element element)</span> </span>&#123;</span><br><span class="line">		AopNamespaceUtils.registerAspectJAutoProxyCreatorIfNecessary(parserContext, element);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerAspectJAutoProxyCreatorIfNecessary</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			ParserContext parserContext, Element sourceElement)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		BeanDefinition beanDefinition = AopConfigUtils.registerAspectJAutoProxyCreatorIfNecessary(</span><br><span class="line">				parserContext.getRegistry(), parserContext.extractSource(sourceElement));</span><br><span class="line">		useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement);</span><br><span class="line">		registerComponentIfNecessary(beanDefinition, parserContext);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>1.得到一个包含AspectJAwareAdvisorAutoProxyCreator实例的Bean定义。</p>
<p>2.根据element节点的相关属性设置一些属性。</p>
<p>3.将1中得到的Bean定义注册到Spring容器中。</p>
<p>我们详细说一下1和2.</p>
<p><strong>registerAspectJAutoProxyCreatorIfNecessary</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BeanDefinition <span class="title">registerAspectJAutoProxyCreatorIfNecessary</span><span class="params">(BeanDefinitionRegistry registry, Object source)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> registerOrEscalateApcAsRequired(AspectJAwareAdvisorAutoProxyCreator.class, registry, source);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BeanDefinition <span class="title">registerOrEscalateApcAsRequired</span><span class="params">(Class&lt;?&gt; cls, BeanDefinitionRegistry registry, Object source)</span> </span>&#123;</span><br><span class="line">		Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>);</span><br><span class="line">		<span class="keyword">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;</span><br><span class="line">			BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class="line">			<span class="keyword">if</span> (!cls.getName().equals(apcDefinition.getBeanClassName())) &#123;</span><br><span class="line">				<span class="keyword">int</span> currentPriority = findPriorityForClass(apcDefinition.getBeanClassName());</span><br><span class="line">				<span class="keyword">int</span> requiredPriority = findPriorityForClass(cls);</span><br><span class="line">				<span class="keyword">if</span> (currentPriority &lt; requiredPriority) &#123;</span><br><span class="line">					apcDefinition.setBeanClassName(cls.getName());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		RootBeanDefinition beanDefinition = <span class="keyword">new</span> RootBeanDefinition(cls);</span><br><span class="line">		beanDefinition.setSource(source);</span><br><span class="line">		beanDefinition.getPropertyValues().add(<span class="string">"order"</span>, Ordered.HIGHEST_PRECEDENCE);</span><br><span class="line">		beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">		registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);</span><br><span class="line">		<span class="keyword">return</span> beanDefinition;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>   1)当Spring容器中已经有名为org.springframework.aop.config.internalAutoProxyCreator的Bean。</p>
<p>获取对应的Bean定义，把这个Bean定义的ClassName和AspectJAwareAdvisorAutoProxyCreator比较，如果不相同，比较两个ClassName的优先级。如果AspectJAwareAdvisorAutoProxyCreator的优先级高，则把当前的Bean定义的ClassName设置为AspectJAwareAdvisorAutoProxyCreator。优先级为：</p>
<p>AnnotationAwareAspectJAutoProxyCreator&gt;AspectJAwareAdvisorAutoProxyCreator&gt;InfrastructureAdvisorAutoProxyCreator。</p>
<p>2）如果当前容器中并没有这个BeanName存在。那么就使用AspectJAwareAdvisorAutoProxyCreator构造出一个Bean定义，并注册一些相关属性，把order优先级设置为最低等等。然后返回。</p>
<p><strong>useClassProxyingIfNecessary</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useClassProxyingIfNecessary</span><span class="params">(BeanDefinitionRegistry registry, Element sourceElement)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (sourceElement != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">boolean</span> proxyTargetClass = Boolean.valueOf(sourceElement.getAttribute(PROXY_TARGET_CLASS_ATTRIBUTE));</span><br><span class="line">		<span class="keyword">if</span> (proxyTargetClass) &#123;</span><br><span class="line">			AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">boolean</span> exposeProxy = Boolean.valueOf(sourceElement.getAttribute(EXPOSE_PROXY_ATTRIBUTE));</span><br><span class="line">		<span class="keyword">if</span> (exposeProxy) &#123;</span><br><span class="line">			AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是看到了熟悉的东西，proxy-target-class属性在我们一开始学习aop配置的时候经常会提到，人们通常会告诉你，如果你想对类直接使用动态，那可以在\<aop:config>节点里配置属性：proxy-target-class=true即可,那么动态代理就会使用cglib来完成，cglib可以直接针对类来实现动态代理，而如果我们在aop配置的时候没有设置这个属性或者设置为false，那么就会使用JDK动态代理，这个时候就只能针对接口实现动态代理。</aop:config></p>
<p>那么这个方法其实他的主要作用就是为了上述的Bean定义注册两个属性，分别是proxyTargetClass和exposeProxy。</p>
<p>好了到现在，我们终于往Spring容器中注入了AspectJAwareAdvisorAutoProxyCreator构成的Bean定义。</p>
<p>我们来看下AspectJAwareAdvisorAutoProxyCreator的继承结构。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectJAwareAdvisorAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">AbstractAdvisorAutoProxyCreator</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAdvisorAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">AbstractAutoProxyCreator</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">ProxyProcessorSupport</span></span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">SmartInstantiationAwareBeanPostProcessor</span>, <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmartInstantiationAwareBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title">InstantiationAwareBeanPostProcessor</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InstantiationAwareBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyProcessorSupport</span> <span class="keyword">extends</span> <span class="title">ProxyConfig</span> <span class="keyword">implements</span> <span class="title">Ordered</span>, <span class="title">BeanClassLoaderAware</span>, <span class="title">AopInfrastructureBean</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<p>我们发现他的祖先类有实现了BeanPostProcessor接口。</p>
<p>翻阅源码，你会发现AspectJAwareAdvisorAutoProxyCreator以及他的祖先类都没有对postProcessBeforeInitialization方法有具体的实现，而只有对postProcessAfterInitialization方法有具体实现。</p>
<p>这个方法的实现在祖先类AbstractAutoProxyCreator中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">	if (bean != null) &#123;</span><br><span class="line">		Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">		if (!this.earlyProxyReferences.contains(cacheKey)) &#123;</span><br><span class="line">			return wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看方法的重点wrapIfNecessary</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (beanName != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">			<span class="keyword">return</span> bean;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line">			<span class="keyword">return</span> bean;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">			<span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">			<span class="keyword">return</span> bean;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Create proxy if we have advice.</span></span><br><span class="line">		Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line">		<span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">			<span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">			Object proxy = createProxy(bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line">			<span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">			<span class="keyword">return</span> proxy;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>1.通过getAdvicesAndAdvisorsForBean来获取可以对当前Bean做代理的AdviceBean。</p>
<p>2.如果AdviceBean不为空，则创建动态代理类，最后把其放入缓存，然后返回。</p>
<p><strong>getAdvicesAndAdvisorsForBean</strong></p>
<p>AbstractAdvisorAutoProxyCreator</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Object[] getAdvicesAndAdvisorsForBean(Class&lt;?&gt; beanClass, String beanName, TargetSource targetSource) &#123;</span><br><span class="line">	List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);</span><br><span class="line">	<span class="keyword">if</span> (advisors.isEmpty()) &#123;</span><br><span class="line">		<span class="keyword">return</span> DO_NOT_PROXY;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> advisors.toArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用当前bean的Class和beanName来找到匹配的Advisors</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findEligibleAdvisors</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">	List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">	List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class="line">	extendAdvisors(eligibleAdvisors);</span><br><span class="line">	<span class="keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class="line">		eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1)先获取所有的Advisor</p>
<p>2)然后调用findAdvisorsThatCanApply在所有的Advisor找到符合条件的Advisor集合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findAdvisorsThatCanApply</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	ProxyCreationContext.setCurrentProxiedBeanName(beanName);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		ProxyCreationContext.setCurrentProxiedBeanName(<span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Advisor&gt; <span class="title">findAdvisorsThatCanApply</span><span class="params">(List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (candidateAdvisors.isEmpty()) &#123;</span><br><span class="line">		<span class="keyword">return</span> candidateAdvisors;</span><br><span class="line">	&#125;</span><br><span class="line">	List&lt;Advisor&gt; eligibleAdvisors = <span class="keyword">new</span> LinkedList&lt;Advisor&gt;();</span><br><span class="line">	<span class="keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;</span><br><span class="line">		<span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> IntroductionAdvisor &amp;&amp; canApply(candidate, clazz)) &#123;</span><br><span class="line">			eligibleAdvisors.add(candidate);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">boolean</span> hasIntroductions = !eligibleAdvisors.isEmpty();</span><br><span class="line">	<span class="keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;</span><br><span class="line">		<span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line">			<span class="comment">// already processed</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (canApply(candidate, clazz, hasIntroductions)) &#123;</span><br><span class="line">			eligibleAdvisors.add(candidate);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到选出适合的Advisor的主要方法是canApply，我们主要看这个方法。</p>
<p><strong>canApply</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canApply</span><span class="params">(Pointcut pc, Class&lt;?&gt; targetClass, <span class="keyword">boolean</span> hasIntroductions)</span> </span>&#123;</span><br><span class="line">		Assert.notNull(pc, <span class="string">"Pointcut must not be null"</span>);</span><br><span class="line">		<span class="keyword">if</span> (!pc.getClassFilter().matches(targetClass)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		MethodMatcher methodMatcher = pc.getMethodMatcher();</span><br><span class="line">		IntroductionAwareMethodMatcher introductionAwareMethodMatcher = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (methodMatcher <span class="keyword">instanceof</span> IntroductionAwareMethodMatcher) &#123;</span><br><span class="line">			introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Set&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> LinkedHashSet&lt;Class&lt;?&gt;&gt;(ClassUtils.getAllInterfacesForClassAsSet(targetClass));</span><br><span class="line">		classes.add(targetClass);</span><br><span class="line">		<span class="keyword">for</span> (Class&lt;?&gt; clazz : classes) &#123;</span><br><span class="line">			Method[] methods = clazz.getMethods();</span><br><span class="line">			<span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">				<span class="keyword">if</span> ((introductionAwareMethodMatcher != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">						introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) ||</span><br><span class="line">						methodMatcher.matches(method, targetClass)) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>接下来看创建代理对象</p>
<p><strong>createProxy</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createProxy</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		Class&lt;?&gt; beanClass, String beanName, Object[] specificInterceptors, TargetSource targetSource)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">	proxyFactory.copyFrom(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">			proxyFactory.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">	<span class="keyword">for</span> (Advisor advisor : advisors) &#123;</span><br><span class="line">		proxyFactory.addAdvisor(advisor);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	proxyFactory.setTargetSource(targetSource);</span><br><span class="line">	customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line">	proxyFactory.setFrozen(<span class="keyword">this</span>.freezeProxy);</span><br><span class="line">	<span class="keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line">		proxyFactory.setPreFiltered(<span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法大体的意思就是新建一个ProxyFactory对象，然后将满足条件的Advisor信息都注入到这个对象中，最后调用 proxyFactory.getProxy(getProxyClassLoader());来创建代理对象。</p>
<p><strong>getProxy</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> createAopProxy().getProxy(classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>createAopProxy</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">protected final synchronized AopProxy createAopProxy() &#123;</span><br><span class="line">	if (!this.active) &#123;</span><br><span class="line">		activate();</span><br><span class="line">	&#125;</span><br><span class="line">	return getAopProxyFactory().createAopProxy(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终调用的是DefaultAopProxyFactory的createAopProxy方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">			Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">			<span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> +</span><br><span class="line">						<span class="string">"Either an interface or a target is required for proxy creation."</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (targetClass.isInterface()) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>方法很容易理解，如果proxy-target-class属性指定为true，而且不是对接口进行动态代理，就调用ObjenesisCglibAopProxy来完成动态代理，即使用CGLIB来完成动态代理。否则就是调用JdkDynamicAopProxy来完成动态代理，即使用JDK动态代理来实现。</p>
<p>我们先看我们熟悉的JDK动态代理的具体实现。</p>
<p>JdkDynamicAopProxy</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(<span class="string">"Creating JDK dynamic proxy: target source is "</span> + <span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">	&#125;</span><br><span class="line">	Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised);</span><br><span class="line">	findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line">	<span class="keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getProxy的方法很简单，就是使用当前的ClassLoader来加载当前Bean实现的所有接口，最后生成相应的动态代理实例。</p>
<p>至此，创建动态代理实例的过程就分析完了。</p>
<p>但是更重要的是当我们调用动态代理实例时，JdkDynamicAopProxy中对InvocationHandler接口的的具体实现。</p>
<p><strong>invoke</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		MethodInvocation invocation;</span><br><span class="line">		Object oldProxy = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">		TargetSource targetSource = <span class="keyword">this</span>.advised.targetSource;</span><br><span class="line">		Class&lt;?&gt; targetClass = <span class="keyword">null</span>;</span><br><span class="line">		Object target = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (!<span class="keyword">this</span>.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;</span><br><span class="line">				<span class="comment">// The target does not implement the equals(Object) method itself.</span></span><br><span class="line">				<span class="keyword">return</span> equals(args[<span class="number">0</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!<span class="keyword">this</span>.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;</span><br><span class="line">				<span class="comment">// The target does not implement the hashCode() method itself.</span></span><br><span class="line">				<span class="keyword">return</span> hashCode();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!<span class="keyword">this</span>.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;</span><br><span class="line">					method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123;</span><br><span class="line">				<span class="comment">// Service invocations on ProxyConfig with the proxy config...</span></span><br><span class="line">				<span class="keyword">return</span> AopUtils.invokeJoinpointUsingReflection(<span class="keyword">this</span>.advised, method, args);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			Object retVal;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line">				<span class="comment">// Make invocation available if necessary.</span></span><br><span class="line">				oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">				setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// May be null. Get as late as possible to minimize the time we "own" the target,</span></span><br><span class="line">			<span class="comment">// in case it comes from a pool.</span></span><br><span class="line">			target = targetSource.getTarget();</span><br><span class="line">			<span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">				targetClass = target.getClass();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Get the interception chain for this method.</span></span><br><span class="line">			List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Check whether we have any advice. If we don't, we can fallback on direct</span></span><br><span class="line">			<span class="comment">// reflective invocation of the target, and avoid creating a MethodInvocation.</span></span><br><span class="line">			<span class="keyword">if</span> (chain.isEmpty()) &#123;</span><br><span class="line">				<span class="comment">// We can skip creating a MethodInvocation: just invoke the target directly</span></span><br><span class="line">				<span class="comment">// Note that the final invoker must be an InvokerInterceptor so we know it does</span></span><br><span class="line">				<span class="comment">// nothing but a reflective operation on the target, and no hot swapping or fancy proxying.</span></span><br><span class="line">				retVal = AopUtils.invokeJoinpointUsingReflection(target, method, args);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// We need to create a method invocation...</span></span><br><span class="line">				invocation = <span class="keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line">				<span class="comment">// Proceed to the joinpoint through the interceptor chain.</span></span><br><span class="line">				retVal = invocation.proceed();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Massage return value if necessary.</span></span><br><span class="line">			Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line">			<span class="keyword">if</span> (retVal != <span class="keyword">null</span> &amp;&amp; retVal == target &amp;&amp; returnType.isInstance(proxy) &amp;&amp;</span><br><span class="line">					!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123;</span><br><span class="line">				<span class="comment">// Special case: it returned "this" and the return type of the method</span></span><br><span class="line">				<span class="comment">// is type-compatible. Note that we can't help if the target sets</span></span><br><span class="line">				<span class="comment">// a reference to itself in another returned object.</span></span><br><span class="line">				retVal = proxy;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (retVal == <span class="keyword">null</span> &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(</span><br><span class="line">						<span class="string">"Null return value from advice does not match primitive return type for: "</span> + method);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> retVal;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (target != <span class="keyword">null</span> &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">				<span class="comment">// Must have come from TargetSource.</span></span><br><span class="line">				targetSource.releaseTarget(target);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line">				<span class="comment">// Restore old proxy.</span></span><br><span class="line">				AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>我们直接看重点，直接跳过对不需要执行增强方法的方法的处理。</p>
<p>调用this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);来获得当前方法匹配的Advisor集合。</p>
<p>当Advisor集合不为空的时候，执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We need to create a method invocation...</span></span><br><span class="line">invocation = <span class="keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line"><span class="comment">// Proceed to the joinpoint through the interceptor chain.</span></span><br><span class="line">retVal = invocation.proceed();</span><br></pre></td></tr></table></figure>
<p>这两行就是关键。</p>
<p>我们重点看ReflectiveMethodInvocation的proceed()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">	<span class="comment">//	We start with an index of -1 and increment early.</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.currentInterceptorIndex == <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> invokeJoinpoint();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Object interceptorOrInterceptionAdvice =</span><br><span class="line">			<span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="keyword">this</span>.currentInterceptorIndex);</span><br><span class="line">	<span class="keyword">if</span> (interceptorOrInterceptionAdvice <span class="keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line">		<span class="comment">// Evaluate dynamic method matcher here: static part will already have</span></span><br><span class="line">		<span class="comment">// been evaluated and found to match.</span></span><br><span class="line">		InterceptorAndDynamicMethodMatcher dm =</span><br><span class="line">				(InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class="line">		<span class="keyword">if</span> (dm.methodMatcher.matches(<span class="keyword">this</span>.method, <span class="keyword">this</span>.targetClass, <span class="keyword">this</span>.arguments)) &#123;</span><br><span class="line">			<span class="keyword">return</span> dm.interceptor.invoke(<span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Dynamic matching failed.</span></span><br><span class="line">			<span class="comment">// Skip this interceptor and invoke the next in the chain.</span></span><br><span class="line">			<span class="keyword">return</span> proceed();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// It's an interceptor, so we just invoke it: The pointcut will have</span></span><br><span class="line">		<span class="comment">// been evaluated statically before this object was constructed.</span></span><br><span class="line">		<span class="keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的主要操作就是使用责任链模式来调用chain集合里的interceptor属性的invoke方法。</p>
<p>所以我们只要来看看这个chain到底是怎么个东西就好了。具体怎么得到这个chain的我们就不细说了，有兴趣的可以看源码（DefaultAdvisorAdapterRegistry的getInterceptors方法），chain集合是一个MethodInterceptor集合。</p>
<p>这个Intercepor集合主要包含下面几种：</p>
<p>AspectJAfterThrowingAdvice   对应着aop配置里面\<aop:after-returning>节点里的方法。</aop:after-returning></p>
<p>AspectJAfterAdvice      对应着 \<aop:after></aop:after></p>
<p>AspectJAroundAdvice         对应着 \<aop:around></aop:around></p>
<p>AfterReturningAdviceInterceptor 对应着AfterReturningAdvice      对应着 \<aop:after-returning></aop:after-returning></p>
<p>MethodBeforeAdviceInterceptor       对应着 MethodBeforeAdvice        对应着\ <aop:before></aop:before></p>
<p>这几种MethodInterceptor调用的先后顺序，如果没有在配置文件中指定Order，那么就会以在配置文件中出现的顺序来执行。执行的过程是一个责任链模式的应用，有兴趣的同学可以先一个例子debug深入研究。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2018/01/21/Spring AOP源码​/" data-id="cjcov2eib0000jwbzx5uyil68" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CAS/">CAS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java-WEB/">Java WEB</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaWEB/">JavaWEB</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java基础/">Java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mybatis/">Mybatis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringMVC/">SpringMVC</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js-css/">js&&css</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/02/05/CAS简单实例/">CAS简单实例</a>
          </li>
        
          <li>
            <a href="/2018/02/05/CAS/">CAS</a>
          </li>
        
          <li>
            <a href="/2018/02/05/数据库基础知识/">数据库基础知识</a>
          </li>
        
          <li>
            <a href="/2018/02/05/CAS结合openldap/">CAS结合openldap</a>
          </li>
        
          <li>
            <a href="/2018/01/31/DelegatingFilterProxy/">DelegatingFilterProxy</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>