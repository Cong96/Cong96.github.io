<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>迷途书童的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="厚积薄发">
<meta property="og:type" content="website">
<meta property="og:title" content="迷途书童的博客">
<meta property="og:url" content="https://cong96.github.io/index.html">
<meta property="og:site_name" content="迷途书童的博客">
<meta property="og:description" content="厚积薄发">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="迷途书童的博客">
<meta name="twitter:description" content="厚积薄发">
  
    <link rel="alternate" href="/atom.xml" title="迷途书童的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">迷途书童的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">一天进步一点</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://cong96.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-DelegatingFilterProxy" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/31/DelegatingFilterProxy/" class="article-date">
  <time datetime="2018-01-30T16:05:54.859Z" itemprop="datePublished">2018-01-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/31/DelegatingFilterProxy/">DelegatingFilterProxy</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近可算把一个项目整完了，然后最近打算来消化下项目中不懂的地方。项目中用到了spring-security来做验证授权，这一块是自己的知识盲区。所以先就来攻克这一块。</p>
<p>我们都知道在使用spring-security的时候都需要在web.xml做如下配置，这样的配置就表明了spring-security实际上是通过过滤器来实现的，很显然利用Filter确实是最好的选择。那么到底是如何通过以下配置，让过滤器和spring-security联系起来的呢，我们就来探讨一下，找到执行这一块的过程，接着，我们就使用spring-security的官方文档来一边学习一边看源码。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>springSecurityFilterChain<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>springSecurityFilterChain<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="DelegatingFilterProxy"><a href="#DelegatingFilterProxy" class="headerlink" title="DelegatingFilterProxy"></a>DelegatingFilterProxy</h3><p>这个类的作用就和他的名字一样，他就是一个起代理作用的过滤器，而真正的拦截器当然就是是spring-security里面的配置咯。但是我们知道，过滤器是由Tomcat来解析加载的，跟Spring容器是没有关系的。</p>
<p>所以我们就带着两个问题来看看这个类：</p>
<p>0.该类是如何完成代理。</p>
<p>1.是如何将过滤器和Spring容器结合起来的。</p>
<p>我们看源码：</p>
<p>先看父类GenericFilterBean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericFilterBean</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">		<span class="title">Filter</span>, <span class="title">BeanNameAware</span>, <span class="title">EnvironmentAware</span>, <span class="title">ServletContextAware</span>, <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<p>他的父类GenericFilterBean实现了很多接口，其中我们最熟悉的就是InitializingBean了。我们知道注入到Spring的Bean，在实例化之后，如果有实现InitializingBean接口的，会调用他的afterPropertiesSet方法。</p>
<p>而我们也注意到虽然GenericFilterBean是一个抽象类，但是他显式的实现了Filter的init方法，而子类DelegatingFilterProxy并没有显式的实现init方法，所以，也就是说当我们向tomcat注册了DelegatingFilterProxy过滤器后，会调用该监过滤器的init方法，而实际上调用的是父类的init方法，我们来看看这个方法做了什么。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">	Assert.notNull(filterConfig, <span class="string">"FilterConfig must not be null"</span>);</span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(<span class="string">"Initializing filter '"</span> + filterConfig.getFilterName() + <span class="string">"'"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>.filterConfig = filterConfig;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set bean properties from init parameters.</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		PropertyValues pvs = <span class="keyword">new</span> FilterConfigPropertyValues(filterConfig, <span class="keyword">this</span>.requiredProperties);</span><br><span class="line">		BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(<span class="keyword">this</span>);</span><br><span class="line">		ResourceLoader resourceLoader = <span class="keyword">new</span> ServletContextResourceLoader(filterConfig.getServletContext());</span><br><span class="line">		bw.registerCustomEditor(Resource.class, <span class="keyword">new</span> ResourceEditor(resourceLoader, <span class="keyword">this</span>.environment));</span><br><span class="line">		initBeanWrapper(bw);</span><br><span class="line">		bw.setPropertyValues(pvs, <span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">		String msg = <span class="string">"Failed to set bean properties on filter '"</span> +</span><br><span class="line">			filterConfig.getFilterName() + <span class="string">"': "</span> + ex.getMessage();</span><br><span class="line">		logger.error(msg, ex);</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> NestedServletException(msg, ex);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Let subclasses do whatever initialization they like.</span></span><br><span class="line">	initFilterBean();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(<span class="string">"Filter '"</span> + filterConfig.getFilterName() + <span class="string">"' configured successfully"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个init()方法主要前面很长一段代码，直到        initFilterBean();之前，都是用来获取Filter配置中的参数即init-param value的配置。我们需要关注的就是initFilterBean();方法，这个方法在父类中是一个抽象方法，具体的实现在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initFilterBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>.delegateMonitor) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.delegate == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// If no target bean name specified, use filter name.</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.targetBeanName == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">this</span>.targetBeanName = getFilterName();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Fetch Spring root application context and initialize the delegate early,</span></span><br><span class="line">			<span class="comment">// if possible. If the root application context will be started after this</span></span><br><span class="line">			<span class="comment">// filter proxy, we'll have to resort to lazy initialization.</span></span><br><span class="line">			WebApplicationContext wac = findWebApplicationContext();</span><br><span class="line">			<span class="keyword">if</span> (wac != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">this</span>.delegate = initDelegate(wac);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们分析下这个方法</p>
<p>0.首先要做一个同步操作。</p>
<p>1.然后进入同步块，如果当前的代理对象为null，查看targetBeanName对象是否为null，targetBeanName属性可以通过在web.xml中的filter中的init-param中配置。一般我们不显式的配置。</p>
<p>2.如果我们没有显式的配置的话，就调用getFilterName方法来得到targetBeanName:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> String <span class="title">getFilterName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">this</span>.filterConfig != <span class="keyword">null</span> ? <span class="keyword">this</span>.filterConfig.getFilterName() : <span class="keyword">this</span>.beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法很简单，如果这时我们没有在filter初始化参数中配置beanName的话，我们就取当前filterName，filterName是filter配置中必须要配置的。</p>
<p>3.得到当前的spring上下文，因为当我们通过ContextLoaderListener这个监听器去初始化Spring容器的时候，会把根上下文当做一个attribute注入到servletContext（即servlet上下文）中，key为WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE，value为根上下文，而我们在过滤器中又能通过FIlterConfig.getServletContext去得到ServletContext，所以我们也就顺理成章的能得到spring上下文了。</p>
<p>4.当前上下文不为空的时候，调用initDelegate(wac);来得到真正用来执行的过滤器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Filter <span class="title">initDelegate</span><span class="params">(WebApplicationContext wac)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">	Filter delegate = wac.getBean(getTargetBeanName(), Filter.class);</span><br><span class="line">	<span class="keyword">if</span> (isTargetFilterLifecycle()) &#123;</span><br><span class="line">		delegate.init(getFilterConfig());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> delegate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法很简单，就是通过限定BeanName以及Bean的类型为Filter来获取bean，而这里的BeanName就是targetName,当没有在filter配置中配置的时候，我们直接用的是filterName，而我们这里的配置的filterName是springSecurityFilterChain。看到这里，你肯定能得出一个结论，<strong>那就是如果你不在filter里配置targetBeanName或者beanName的时候，你的filterName就必须是springSecurityFilterChain</strong>，否则，肯定就无法在Spring找到delegate对象了，而BeanName为springSecurityFilterChain的Bean对象肯定在我们配置spring-security配置的时候以默认的方式注入到了spring，只有这样才说的通。</p>
<p>而对于DelegatingFilterProxy的dofilter方法，我们不用多看，猜也猜得到内部是调用delegate.dofilter方法。</p>
<p>那文章的最后，我们就来找一下到底这个BeanName为springSecurityFilterChain的Bean对象是哪个把，也算为我们之后阅读spring-security模块的代码开个头。</p>
<p>我们知道spring-security的配置是如下的形式：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:security</span>=<span class="string">"http://www.springframework.org/schema/security"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/security</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/security/spring-security.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">http</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/**"</span> <span class="attr">access</span>=<span class="string">"hasRole('USER')"</span>&gt;</span><span class="tag">&lt;/<span class="name">intercept-url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">http</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>而且会使用spring-security命名空间。很明显又是使用了命名空间来解析xml配置。这里我们不赘述整个过程了，我们直接找到解析http节点的BeanDefinitionParser实现类。</p>
<p>这个类就是org.springframework.security.config.http.HttpSecurityBeanDefinitionParser,我们直接看他的parse方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext pc)</span> </span>&#123;</span><br><span class="line">	CompositeComponentDefinition compositeDef = <span class="keyword">new</span> CompositeComponentDefinition(</span><br><span class="line">			element.getTagName(), pc.extractSource(element));</span><br><span class="line">	pc.pushContainingComponent(compositeDef);</span><br><span class="line"></span><br><span class="line">	registerFilterChainProxyIfNecessary(pc, pc.extractSource(element));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Obtain the filter chains and add the new chain to it</span></span><br><span class="line">	BeanDefinition listFactoryBean = pc.getRegistry().getBeanDefinition(</span><br><span class="line">			BeanIds.FILTER_CHAINS);</span><br><span class="line">	List&lt;BeanReference&gt; filterChains = (List&lt;BeanReference&gt;) listFactoryBean</span><br><span class="line">			.getPropertyValues().getPropertyValue(<span class="string">"sourceList"</span>).getValue();</span><br><span class="line"></span><br><span class="line">	filterChains.add(createFilterChain(element, pc));</span><br><span class="line"></span><br><span class="line">	pc.popAndRegisterContainingComponent();</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的具体实现我们先不分析，我们看到他的一个子方法</p>
<p><strong>registerFilterChainProxyIfNecessary</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerFilterChainProxyIfNecessary</span><span class="params">(ParserContext pc, Object source)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (pc.getRegistry().containsBeanDefinition(BeanIds.FILTER_CHAIN_PROXY)) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Not already registered, so register the list of filter chains and the</span></span><br><span class="line">		<span class="comment">// FilterChainProxy</span></span><br><span class="line">		BeanDefinition listFactoryBean = <span class="keyword">new</span> RootBeanDefinition(ListFactoryBean.class);</span><br><span class="line">		listFactoryBean.getPropertyValues().add(<span class="string">"sourceList"</span>, <span class="keyword">new</span> ManagedList());</span><br><span class="line">		pc.registerBeanComponent(<span class="keyword">new</span> BeanComponentDefinition(listFactoryBean,</span><br><span class="line">				BeanIds.FILTER_CHAINS));</span><br><span class="line"></span><br><span class="line">		BeanDefinitionBuilder fcpBldr = BeanDefinitionBuilder</span><br><span class="line">				.rootBeanDefinition(FilterChainProxy.class);</span><br><span class="line">		fcpBldr.getRawBeanDefinition().setSource(source);</span><br><span class="line">		fcpBldr.addConstructorArgReference(BeanIds.FILTER_CHAINS);</span><br><span class="line">		fcpBldr.addPropertyValue(<span class="string">"filterChainValidator"</span>, <span class="keyword">new</span> RootBeanDefinition(</span><br><span class="line">				DefaultFilterChainValidator.class));</span><br><span class="line">		BeanDefinition fcpBean = fcpBldr.getBeanDefinition();</span><br><span class="line">		pc.registerBeanComponent(<span class="keyword">new</span> BeanComponentDefinition(fcpBean,</span><br><span class="line">				BeanIds.FILTER_CHAIN_PROXY));</span><br><span class="line">		pc.getRegistry().registerAlias(BeanIds.FILTER_CHAIN_PROXY,</span><br><span class="line">				BeanIds.SPRING_SECURITY_FILTER_CHAIN);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到倒数第二行代码，将一个Bean注入到spring中，名字为BeanIds.FILTER_CHAIN_PROXY。</p>
<p>接着我们看到方法的最后一行代码，给这个Bean赋一个别名BeanIds.SPRING_SECURITY_FILTER_CHAIN，而对应的值就是springSecurityFilterChain</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** External alias for FilterChainProxy bean, for use in web.xml files */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SPRING_SECURITY_FILTER_CHAIN = <span class="string">"springSecurityFilterChain"</span>;</span><br></pre></td></tr></table></figure>
<p>所以这里也就完成了DelegatingFilterProxy中delegate对象注入到spring容器的过程。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2018/01/31/DelegatingFilterProxy/" data-id="cjd1u5hfp0000ggbz32cguiy9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post---Java中的引用传递" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/31/--Java中的引用传递/" class="article-date">
  <time datetime="2018-01-30T16:00:55.618Z" itemprop="datePublished">2018-01-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java基础/">Java基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/31/--Java中的引用传递/">Java中的引用传递</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近每天都在做面试题，发现还是有很多题是很注重基础的，趁着有点空，就抓紧把一些典型的题目记录下来。</p>
<h3 id="Java中的引用传递"><a href="#Java中的引用传递" class="headerlink" title="Java中的引用传递"></a>Java中的引用传递</h3><p>Example 0</p>
<p>我们来看与Java引用传递有关的第一个题目，也是多次出现的一题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wangcc.MyJavaSE.jmm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangeTest</span> </span>&#123;</span><br><span class="line">	String str = <span class="string">"kobe"</span>;</span><br><span class="line">	<span class="keyword">char</span>[] ch = &#123; <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ExchangeTest ex = <span class="keyword">new</span> ExchangeTest();</span><br><span class="line">		ex.change(ex.str, ex.ch);</span><br><span class="line">		System.out.print(ex.str + <span class="string">"and"</span>);</span><br><span class="line">		System.out.println(ex.ch);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String str, <span class="keyword">char</span>[] ch)</span> </span>&#123;</span><br><span class="line">		str = <span class="string">"james"</span>;</span><br><span class="line">		ch[<span class="number">0</span>] = <span class="string">'g'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个程序的输出结果是多少？</p>
<p>答案是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kobeandgbc</span><br></pre></td></tr></table></figure>
<p>这个答案与你的预期相符合吗？</p>
<p>为什么字符串类型的str没有改变而char数组类型的改变了呢？</p>
<p><strong>造成这个的原因，其实就是因为一句话，Java中都是引用传递而不是值传递。</strong></p>
<p>不过如果只是跟你说这句话的，肯定会很蒙。</p>
<p>我们好好的来解析这句话，<strong>在Java中，我们把参数传到方法中的时候，我们都是将当前引用的副本传递到方法中，注意不是引用本身，而是引用的副本。</strong></p>
<p>我们回到当前的方法，当调用ex.change方法时，在虚拟机栈中会创建change方法的栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从执行到调用完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。虚拟机栈是描述Java方法执行的内存模型。局部变量表包括基本数据类型，对象引用和returnAddress，在方法执行前已经确定大小。</p>
<p>这个时候我们把str的引用的副本传递给方法形参str，把ch的引用副本传递给形参ch，再一次强调是副本。</p>
<p>然后执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str = &quot;james&quot;;</span><br></pre></td></tr></table></figure>
<p>这行代码就直接把局部变量表中的str的指向从指向字符串常量池的kobe字符串变成了指向james这个字符串。也就是说，已经把str里的值改变了，原来里面的值是指向kobe的引用，但是现在已经被改成指向james的引用了。</p>
<p>接着执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch[0] = &apos;g&apos;;</span><br></pre></td></tr></table></figure>
<p>我们知道数组对象也是在堆中创建的，而ch[0]=’g’;</p>
<p>这句代码并没有改变局部变量表中ch的指向，他依旧还是那个外部的ch引用的副本。他仅仅是找到ch[0]这个数组对象第一个元素的位置，然后改变其对应的值。可能这样说还是不清楚，换一种说法就是说，你依旧是在同一块堆空间里进行的替换数组第一个元素的值，局部变量表的ch和外部的ch都是指向的同一个堆空间。也就是说外部的ch指向的堆空间的数组第一个元素改变了。所以得到了上述答案。</p>
<p><strong>其实主要的就是要看方法到底有没有更改引用副本的指向，方法里到底是不是还是对同一块堆空间进行操作。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2018/01/31/--Java中的引用传递/" data-id="cjd1tzd280000d0bzevtgxm64" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post---装饰者模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/31/--装饰者模式/" class="article-date">
  <time datetime="2018-01-30T16:00:55.615Z" itemprop="datePublished">2018-01-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/设计模式/">设计模式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/31/--装饰者模式/">装饰者模式(一)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在复习之前写过的博客，看到Mybatis缓存的部分，想起了Cache的设计用到了装饰者模式，那么刚好我们就来好好看看装饰者模式。</p>
<h3 id="从Mybatis的Cache设计说起"><a href="#从Mybatis的Cache设计说起" class="headerlink" title="从Mybatis的Cache设计说起"></a>从Mybatis的Cache设计说起</h3><p>我们之前已经说过了，要想让Mybatis的二级缓存生效，需要在Mapper文件中加入如下配置。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于这个配置的作用，我们直接引用mybatis官方文档。</p>
<p>这个简单语句的效果如下:</p>
<ul>
<li>映射语句文件中的所有 select 语句将会被缓存。</li>
<li>映射语句文件中的所有 insert,update 和 delete 语句会刷新缓存。</li>
<li>缓存会使用 Least Recently Used(LRU,最近最少使用的)算法来收回。</li>
<li>根据时间表(比如 no Flush Interval,没有刷新间隔), 缓存不会以任何时间顺序 来刷新。</li>
<li>缓存会存储列表集合或对象(无论查询方法返回什么)的 1024 个引用。</li>
<li>缓存会被视为是 read/write(可读/可写)的缓存,意味着对象检索不是共享的,而 且可以安全地被调用者修改,而不干扰其他调用者或线程所做的潜在修改。</li>
</ul>
<p>所有的这些属性都可以通过缓存元素的属性来修改。比如:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span></span></span><br><span class="line"><span class="tag">  <span class="attr">eviction</span>=<span class="string">"FIFO"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">flushInterval</span>=<span class="string">"60000"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">size</span>=<span class="string">"512"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">readOnly</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个更高级的配置创建了一个 FIFO 缓存,并每隔 60 秒刷新,存数结果对象或列表的 512 个引用,而且返回的对象被认为是只读的,因此在不同线程中的调用者之间修改它们会 导致冲突。</p>
<p>可用的收回策略有:</p>
<ul>
<li>LRU – 最近最少使用的:移除最长时间不被使用的对象。</li>
<li>FIFO – 先进先出:按对象进入缓存的顺序来移除它们。</li>
<li>SOFT – 软引用:移除基于垃圾回收器状态和软引用规则的对象。</li>
<li>WEAK – 弱引用:更积极地移除基于垃圾收集器状态和弱引用规则的对象。</li>
</ul>
<p>默认的是 LRU。</p>
<p>flushInterval(刷新间隔)可以被设置为任意的正整数,而且它们代表一个合理的毫秒 形式的时间段。默认情况是不设置,也就是没有刷新间隔,缓存仅仅调用语句时刷新。</p>
<p>size(引用数目)可以被设置为任意正整数,要记住你缓存的对象数目和你运行环境的 可用内存资源数目。默认值是 1024。</p>
<p>readOnly(只读)属性可以被设置为 true 或 false。只读的缓存会给所有调用者返回缓 存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。可读写的缓存 会返回缓存对象的拷贝(通过序列化) 。这会慢一些,但是安全,因此默认是 false。</p>
<h4 id="Mybatis是如何加载Cache配置的"><a href="#Mybatis是如何加载Cache配置的" class="headerlink" title="Mybatis是如何加载Cache配置的"></a>Mybatis是如何加载Cache配置的</h4><p>在Mybatis中，对Mapper配置文件的解析由XMLMapperBuilder来完成。</p>
<p>configurationElement</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configurationElement</span><span class="params">(XNode context)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     String namespace = context.getStringAttribute(<span class="string">"namespace"</span>);</span><br><span class="line">     <span class="keyword">if</span> (namespace.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">   	  <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Mapper's namespace cannot be empty"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     builderAssistant.setCurrentNamespace(namespace);</span><br><span class="line">     cacheRefElement(context.evalNode(<span class="string">"cache-ref"</span>));</span><br><span class="line">     cacheElement(context.evalNode(<span class="string">"cache"</span>));</span><br><span class="line">     parameterMapElement(context.evalNodes(<span class="string">"/mapper/parameterMap"</span>));</span><br><span class="line">     resultMapElements(context.evalNodes(<span class="string">"/mapper/resultMap"</span>));</span><br><span class="line">     sqlElement(context.evalNodes(<span class="string">"/mapper/sql"</span>));</span><br><span class="line">     buildStatementFromContext(context.evalNodes(<span class="string">"select|insert|update|delete"</span>));</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error parsing Mapper XML. Cause: "</span> + e, e);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>我们先看使用默认配置情况下的解析</p>
<pre><code>cacheElement(context.evalNode(&quot;cache&quot;));
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cacheElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">     String type = context.getStringAttribute(<span class="string">"type"</span>, <span class="string">"PERPETUAL"</span>);</span><br><span class="line">     Class&lt;? extends Cache&gt; typeClass = typeAliasRegistry.resolveAlias(type);</span><br><span class="line">     String eviction = context.getStringAttribute(<span class="string">"eviction"</span>, <span class="string">"LRU"</span>);</span><br><span class="line">     Class&lt;? extends Cache&gt; evictionClass = typeAliasRegistry.resolveAlias(eviction);</span><br><span class="line">     Long flushInterval = context.getLongAttribute(<span class="string">"flushInterval"</span>);</span><br><span class="line">     Integer size = context.getIntAttribute(<span class="string">"size"</span>);</span><br><span class="line">     <span class="keyword">boolean</span> readWrite = !context.getBooleanAttribute(<span class="string">"readOnly"</span>, <span class="keyword">false</span>);</span><br><span class="line">     Properties props = context.getChildrenAsProperties();</span><br><span class="line">     builderAssistant.useNewCache(typeClass, evictionClass, flushInterval, size, readWrite, props);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到在cacheElement中，有对cache节点下的属性的值进行读取并作出相应的处理。</p>
<p>然后通过这些处理过的信息调用 builderAssistant.useNewCache方法来创建Cache实例并注册到Configuration中。</p>
<p>我们来看MapperBuilderAssistant中的useNewCache方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Cache <span class="title">useNewCache</span><span class="params">(Class&lt;? extends Cache&gt; typeClass,</span></span></span><br><span class="line"><span class="function"><span class="params">    Class&lt;? extends Cache&gt; evictionClass,</span></span></span><br><span class="line"><span class="function"><span class="params">    Long flushInterval,</span></span></span><br><span class="line"><span class="function"><span class="params">    Integer size,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> readWrite,</span></span></span><br><span class="line"><span class="function"><span class="params">    Properties props)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//如果在配置文件中没有显式指定 就使用PerpetualCache.class</span></span><br><span class="line">  typeClass = valueOrDefault(typeClass, PerpetualCache.class);</span><br><span class="line">  <span class="comment">//如果没有显式指定，LruCache.class</span></span><br><span class="line">  evictionClass = valueOrDefault(evictionClass, LruCache.class);</span><br><span class="line">  <span class="comment">//开始创建一个使用了层层装饰者模式包裹的Cache实例</span></span><br><span class="line">  Cache cache = <span class="keyword">new</span> CacheBuilder(currentNamespace)</span><br><span class="line">      .implementation(typeClass)</span><br><span class="line">      .addDecorator(evictionClass)</span><br><span class="line">      .clearInterval(flushInterval)</span><br><span class="line">      .size(size)</span><br><span class="line">      .readWrite(readWrite)</span><br><span class="line">      .properties(props)</span><br><span class="line">      .build();</span><br><span class="line">  <span class="comment">//将cache加入到configuration中</span></span><br><span class="line">  configuration.addCache(cache);</span><br><span class="line">  currentCache = cache;</span><br><span class="line">  <span class="keyword">return</span> cache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法不难理解，就是先创建一个使用了装饰者模式得到的Cache实例，然后将这个实例注入到configuration中。</p>
<p>所以我们主要看是怎么创建的。</p>
<p>CacheBuilder</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认情况下是PerpetualCache.class，这个一般不会在配置文件中更改</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CacheBuilder <span class="title">implementation</span><span class="params">(Class&lt;? extends Cache&gt; implementation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.implementation = implementation;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//默认的是LruCache 对应的属性是eviction 即设置回收策略</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">LRU – 最近最少使用的:移除最长时间不被使用的对象。</span></span><br><span class="line"><span class="comment">FIFO – 先进先出:按对象进入缓存的顺序来移除它们。</span></span><br><span class="line"><span class="comment">SOFT – 软引用:移除基于垃圾回收器状态和软引用规则的对象。</span></span><br><span class="line"><span class="comment">WEAK – 弱引用:更积极地移除基于垃圾收集器状态和弱引用规则的对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> CacheBuilder <span class="title">addDecorator</span><span class="params">(Class&lt;? extends Cache&gt; decorator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (decorator != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.decorators.add(decorator);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//设置缓存失效时间，默认是不设置  ，以毫秒为单位</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> CacheBuilder <span class="title">clearInterval</span><span class="params">(Long clearInterval)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.clearInterval = clearInterval;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//对应的size属性  默认是1024</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> CacheBuilder <span class="title">size</span><span class="params">(Integer size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.size = size;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125; </span><br><span class="line"><span class="comment">//对应readOnly属性 设置缓存是否为只读 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CacheBuilder <span class="title">readWrite</span><span class="params">(<span class="keyword">boolean</span> readWrite)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.readWrite = readWrite;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//设置相应的自定义配置，通过属性文件</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> CacheBuilder <span class="title">properties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.properties = properties;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Cache <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//使用单个String形参的构造方法来初始化PerpetualCache，构造方法的入参是namesapceName</span></span><br><span class="line">    setDefaultImplementations();</span><br><span class="line"> </span><br><span class="line">    Cache cache = newBaseCacheInstance(implementation, id);</span><br><span class="line">  <span class="comment">//如果有自定义的参数，带上</span></span><br><span class="line">    setCacheProperties(cache);</span><br><span class="line">  <span class="comment">//添加用于设置回收策略的Cache，这里开始了第一次封装Cache</span></span><br><span class="line">    <span class="keyword">if</span> (PerpetualCache.class.equals(cache.getClass())) &#123; <span class="comment">// issue #352, do not apply decorators to custom caches</span></span><br><span class="line">      <span class="keyword">for</span> (Class&lt;? extends Cache&gt; decorator : decorators) &#123;</span><br><span class="line">        cache = newCacheDecoratorInstance(decorator, cache);</span><br><span class="line">        setCacheProperties(cache);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//这里实现了cache装饰类的层层封装</span></span><br><span class="line">      cache = setStandardDecorators(cache);</span><br><span class="line">    &#125; </span><br><span class="line">  <span class="comment">//最后还是封装成一个LoggingCache类型的Cache，这个Cache已经经过层层装饰了</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!LoggingCache.class.isAssignableFrom(cache.getClass())) &#123;</span><br><span class="line">      cache = <span class="keyword">new</span> LoggingCache(cache);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cache;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>来稍微看一下具体的装饰步骤</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Cache <span class="title">newCacheDecoratorInstance</span><span class="params">(Class&lt;? extends Cache&gt; cacheClass, Cache base)</span> </span>&#123;</span><br><span class="line">  Constructor&lt;? extends Cache&gt; cacheConstructor = getCacheDecoratorConstructor(cacheClass);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cacheConstructor.newInstance(base);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">"Could not instantiate cache decorator ("</span> + cacheClass + <span class="string">"). Cause: "</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Cache <span class="title">setStandardDecorators</span><span class="params">(Cache cache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      MetaObject metaCache = SystemMetaObject.forObject(cache);</span><br><span class="line">      <span class="keyword">if</span> (size != <span class="keyword">null</span> &amp;&amp; metaCache.hasSetter(<span class="string">"size"</span>)) &#123;</span><br><span class="line">        metaCache.setValue(<span class="string">"size"</span>, size);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果设置了缓存失效时间,加一个ScheduledCache装饰类</span></span><br><span class="line">      <span class="keyword">if</span> (clearInterval != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cache = <span class="keyword">new</span> ScheduledCache(cache);</span><br><span class="line">        ((ScheduledCache) cache).setClearInterval(clearInterval);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果并不是只读，加一个SerializedCache装饰类</span></span><br><span class="line">      <span class="keyword">if</span> (readWrite) &#123;</span><br><span class="line">        cache = <span class="keyword">new</span> SerializedCache(cache);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//然后加上具有日志功能的装饰类</span></span><br><span class="line">      cache = <span class="keyword">new</span> LoggingCache(cache);</span><br><span class="line">      <span class="comment">//然后加上具有同步功能的装饰类</span></span><br><span class="line">      cache = <span class="keyword">new</span> SynchronizedCache(cache);</span><br><span class="line">      <span class="keyword">return</span> cache;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">"Error building standard cache decorators.  Cause: "</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>通过这个分析，我们可以得到基本的Cache的装饰链</p>
<p>LoggingCache-&gt; SynchronizedCache-&gt;SerializedCache-&gt;LoggingCache-&gt;ScheduledCache-&gt;LRUCache-&gt;PerpetualCache。</p>
<p>也就是说其实最后最终调用的还是PerpetualCache里的方法。</p>
<p>最后说一下：加入到configuration的过程。    configuration.addCache(cache);</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCache</span><span class="params">(Cache cache)</span> </span>&#123;</span><br><span class="line">  caches.put(cache.getId(), cache);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>cache.getId()，id是在初始化PerpetualCache这个Cache的时候通过构造方法传入的，id的值是这个Mapper的命名空间名。所以这样我们才能在MappedStatement中找对应的cache.</p>
<p>我们再回头看看我们曾经说过的Mybatis二级缓存。</p>
<p>我们直接看CacheExecutor的query方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">//获取该Mapper命名空间下的缓存</span></span><br><span class="line">  Cache cache = ms.getCache();</span><br><span class="line">  <span class="comment">//如果有，开始准备使用缓存了</span></span><br><span class="line">  <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//如果是select语句，默认情况下不清缓存，但是如果在Mapper文件中有在select配置中配置属性fluchCache为true的话，会执行缓存清理的动作。具体对这个是否需要请缓存配置的解析在XMLStatementBuilder类的parseStatementNode方法中。</span></span><br><span class="line">    flushCacheIfRequired(ms);</span><br><span class="line">    <span class="comment">//如果确定这个select语句使用了Cache并且方法参数中没有resultHandler类型的参数。就使用Cache了</span></span><br><span class="line">    <span class="keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">      ensureNoOutParams(ms, parameterObject, boundSql);</span><br><span class="line">      <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">      <span class="comment">//从缓存中找</span></span><br><span class="line">      List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</span><br><span class="line">      <span class="comment">//如果没找到，去查询</span></span><br><span class="line">      <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">        list = delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">        <span class="comment">//将查询的结果放入Cache中</span></span><br><span class="line">        tcm.putObject(cache, key, list); <span class="comment">// issue #578. Query must be not synchronized to prevent deadlocks</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//返回结果</span></span><br><span class="line">      <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法的大概流程已经在代码块中解释了。</p>
<p>我们主要看下这个过程中对缓存的使用。</p>
<p>先看是否执行缓存清理的方法</p>
<p><strong>flushCacheIfRequired</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushCacheIfRequired</span><span class="params">(MappedStatement ms)</span> </span>&#123;</span><br><span class="line">   Cache cache = ms.getCache();</span><br><span class="line">  <span class="comment">//如果需要清理缓存，update的时候默认清理缓存</span></span><br><span class="line">   <span class="keyword">if</span> (cache != <span class="keyword">null</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;      </span><br><span class="line">     tcm.clear(cache);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(Cache cache)</span> </span>&#123;</span><br><span class="line">   getTransactionalCache(cache).clear();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> TransactionalCache <span class="title">getTransactionalCache</span><span class="params">(Cache cache)</span> </span>&#123;</span><br><span class="line">   TransactionalCache txCache = transactionalCaches.get(cache);</span><br><span class="line">   <span class="keyword">if</span> (txCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">     txCache = <span class="keyword">new</span> TransactionalCache(cache);</span><br><span class="line">     transactionalCaches.put(cache, txCache);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> txCache;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>tcm对应的是一个TransactionalCacheManager对象，可以把他看做一个TransactionalCache池。在CachingExecutor中是这样初始化的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> TransactionalCacheManager tcm = <span class="keyword">new</span> TransactionalCacheManager();</span><br></pre></td></tr></table></figure>
<p>所以在初始化Executor执行器的时候，tcm也就存在了。</p>
<p>TransactionalCacheManager中的getTransactionalCache方法，这个方法很明显是构造一下cache和TransactionalCache的关系，存入Map中，而且TransactionalCache将cache作为构造方法的入参。</p>
<p>所以这里，每一个cache就对应着一个包含cache的TransactionalCache对象。</p>
<p>TransactionalCache的clear方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  reset();</span><br><span class="line">  clearOnCommit = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  clearOnCommit = <span class="keyword">false</span>;</span><br><span class="line">  entriesToRemoveOnCommit.clear();</span><br><span class="line">  entriesToAddOnCommit.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>clear方法最后把clearOnCommit置为true.</p>
<p>并且把entriesToRemoveOnCommit和entriesToAddOnCommit这两个Map中的元素都清空了、。</p>
<p><strong>tcm.putObject(cache, key, list);</strong></p>
<p>将结果放入到缓存的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Cache cache, CacheKey key, Object value)</span> </span>&#123;</span><br><span class="line">  getTransactionalCache(cache).putObject(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用的是TransactionalCache的putObject方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object object)</span> </span>&#123;</span><br><span class="line"><span class="comment">//移除entriesToRemoveOnCommit中key为当前的CacheKey的元素</span></span><br><span class="line">   entriesToRemoveOnCommit.remove(key);</span><br><span class="line">   <span class="comment">//将当前的CacheKey为keey，并且构造一个包含cache，CacheKey和查询结果的AddEntry为Value存进entriesToAddCommit</span></span><br><span class="line">   entriesToAddOnCommit.put(key, <span class="keyword">new</span> AddEntry(delegate, key, object));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>所以到这里呢，putObject方法呢，实际上只是把元素存在位于TranscationCache中的entriesToRemoveOnCommit这个Map中。</p>
<p><strong>注意，此时并没有将查询结果放入到我们之前说的装饰器模式构造的cache中。</strong></p>
<p><strong>tcm.getObject(cache, key);</strong></p>
<p>在缓存中查找是否有当前CacheKey对应的值。</p>
<p>调用的是ransactionalCache的getObject方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (clearOnCommit) <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// issue #146</span></span><br><span class="line">   <span class="keyword">return</span> delegate.getObject(key);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>当clearOnCommit为true的时候就直接返回了，即代表着如果是udpate语句或者设置了flushCache属性为true的话，就甭想着在cache里面找，赶紧再跟数据库做交互呀。</p>
<p>如果不为true，那么就要在cache中去寻找当前CacheKey对应的值了。</p>
<p>而你会发现，之前的putObject并没有把值存入到cache中呀，所以这里根本不用分析了，肯定是找不到的。是的，不信你做个试验，你会发现第二次查询的时候依然是直接跟数据库做交互，不会在缓存中取。</p>
<p><strong>事实上，如果你想要让Mybatis的二级缓存失效，你需要手动的在查询后执行session.commit操作。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    commit(<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">boolean</span> force)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      executor.commit(isCommitOrRollbackRequired(force));</span><br><span class="line">      dirty = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error committing transaction.  Cause: "</span> + e, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当调用无参的commit方法时，force指定是false</span></span><br><span class="line"><span class="comment">使用DefaultSqlSessionFactory的无参openSession()方法时，autoCommit为false</span></span><br><span class="line"><span class="comment">如果使用的是有参的openSession(boolean autoCommit)方法，那就取决于传入的参数了</span></span><br><span class="line"><span class="comment">所以也就是说，如果没有显式的将dirty设置为true的时候方法返回false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">***注意  在调用update方法的时候，会把dirty设置为true，这时候方法就会返回true了。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isCommitOrRollbackRequired</span><span class="params">(<span class="keyword">boolean</span> force)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (!autoCommit &amp;&amp; dirty) || force;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，其实session.commit()实际上调用的是executor的commit方法。而具体传什么参数给executor的commit方法是由isCommitOrRollbackRequired方法决定的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">boolean</span> required)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    delegate.commit(required);</span><br><span class="line">    tcm.commit();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BaseExecutor</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">boolean</span> required)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (closed) <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Cannot commit, transaction is already closed"</span>);</span><br><span class="line">  <span class="comment">//清理一级缓存</span></span><br><span class="line">    clearLocalCache();</span><br><span class="line">  <span class="comment">//BatchExecutor有重写这个方法里的具体方法，目前没有用到，先不分析</span></span><br><span class="line">    flushStatements();</span><br><span class="line">  <span class="comment">//这里就执行      connection.commit();操作 非查询数据的时候会用到</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (required) &#123;</span><br><span class="line">      transaction.commit();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>我们这里不去过多的分析executor的commit()方法。</p>
<p>而是要分析</p>
<p><strong>tcm.commit();</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (TransactionalCache txCache : transactionalCaches.values()) &#123;</span><br><span class="line">     txCache.commit();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>调用这个会话中的TransactionalCache池里的所有TransactionalCache的commit()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//如果clearOnCommit为true，那么就清理掉所有的放在cache里的数据</span></span><br><span class="line">  <span class="keyword">if</span> (clearOnCommit) &#123;</span><br><span class="line">    delegate.clear();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//将要从cache中要移除的元素移除了</span></span><br><span class="line">    <span class="keyword">for</span> (RemoveEntry entry : entriesToRemoveOnCommit.values()) &#123;</span><br><span class="line">      entry.commit();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//将要添加到cache中的元素添加到cache中</span></span><br><span class="line">  <span class="keyword">for</span> (AddEntry entry : entriesToAddOnCommit.values()) &#123;</span><br><span class="line">    entry.commit();</span><br><span class="line">  &#125;</span><br><span class="line">  reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AddEntry是TransactionalCache的一个静态内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddEntry</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Cache cache;</span><br><span class="line">  <span class="keyword">private</span> Object key;</span><br><span class="line">  <span class="keyword">private</span> Object value;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AddEntry</span><span class="params">(Cache cache, Object key, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cache = cache;</span><br><span class="line">    <span class="keyword">this</span>.key = key;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cache.putObject(key, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显他的commit方法就是在调用cache的putObject方法。</p>
<p>那么这个putObject方法就是我们要看的。</p>
<p>LoggingCache</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object object)</span> </span>&#123;</span><br><span class="line">   delegate.putObject(key, object);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>我们一开始说了，我们得到的cache是一个LoggingCache实例。他的delegate属性是SynchronizedCache,他保证放入数据时候的线程安全。而如果没有设置readOnly为true的时候，会接着调用SerializedCache来做一个序列化的操作。如果设置了缓存过时时间，会调用ScheduledCache来做一个查看是否缓存失效的判断。接着就到了设置回收策略的Cache，我们这里默认是LRUCache，即最近最少使用，内部是使用LinkedHashMap实现的，并不复杂，回收策略是必须的，因为缓存不可能无限大，一定要设置一个max值。然后才到PerpetualCache，这才到了我们把CacheKey和查询结果存放起来的类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">private</span> Map&lt;Object, Object&gt; cache = <span class="keyword">new</span> HashMap&lt;Object, Object&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">   cache.put(key, value);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>很简单，就是把键值对放到cache这个Map中。</p>
<p>而对于delegate.getObject(key);的具体过程，当然是和delegate.putObject(key, object);相似的，就不细说了。</p>
<p>这里我们看到了每一个Cache都有自己的功能，而PerpetualCache只有最原始的存放数据和得到数据的功能。为了让Cache的功能更强大，我们使用了装饰者模式来一步步的丰富Cache的功能。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2018/01/31/--装饰者模式/" data-id="cjd1tzd2h0001d0bzx76nysvv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post---CSS笔记（一）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/24/--CSS笔记（一）/" class="article-date">
  <time datetime="2018-01-24T15:02:28.061Z" itemprop="datePublished">2018-01-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/js-css/">js&&css</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/24/--CSS笔记（一）/">CSS笔记（一）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在客串前端，哎，那真是基本不会呀，全都忘光了，所以很多东西都相当于重新开始学。所以就把每天新学到的前知识都记录下来吧。</p>
<h3 id="CSS笔记"><a href="#CSS笔记" class="headerlink" title="CSS笔记"></a>CSS笔记</h3><ul>
<li><p>当一个元素由这种class=”A B”，A B中间有空格分开的时候，就代表这个元素既有A的属性，</p>
<p>也有B的属性。那么为什么当要表示一个元素由多个class的属性需要用空格分开呢，那就要问问浏览器的渲染原理了，据说webkit是用c++写的，我们就不深究了。</p>
</li>
<li><p>对于!important</p>
<p>css属性的优先级</p>
<p>1)  !important &gt; 行内样式 &gt;head中style标签定义的样式 &gt; 外部CSS文件中的样式<br>2)  而在这几者内部，写在后面的CSS样式会覆盖前边的（越靠后优先级越高）</p>
</li>
</ul>
<ul>
<li><p>CSS伪类</p>
<p> CSS 伪类用于向某些选择器添加特殊的效果。</p>
<p>a:link {color: #FF0000}        /<em> 未访问的链接 </em>/<br>a:visited {color: #00FF00}    /<em> 已访问的链接 </em>/<br>a:hover {color: #FF00FF}    /<em> 鼠标移动到链接上 </em>/<br>a:active {color: #0000FF}    /<em> 选定的链接 </em>/<br>提示：在 CSS 定义中，a:hover 必须被置于 a:link 和 a:visited 之后，才是有效的。</p>
<p>提示：在 CSS 定义中，a:active 必须被置于 a:hover 之后，才是有效的。</p>
<p>提示：伪类名称对大小写不敏感。</p>
<p>focus伪类<br>:focus 选择器用于选取获得焦点的元素。</p>
<p>提示：接收键盘事件或其他用户输入的元素都允许 :focus 选择器。<br>接收键盘输入事件</p>
</li>
<li><p>&lt;!DOCTYPE&gt;<br>定义和用法<br>&lt;!DOCTYPE&gt; 声明必须是 HTML 文档的第一行，位于 \<html> 标签之前。</html></p>
<p>&lt;!DOCTYPE&gt; 声明不是 HTML 标签；它是指示 web 浏览器关于页面使用哪个 HTML 版本进行编写的指令。</p>
<p>在 HTML 4.01 中，&lt;!DOCTYPE&gt; 声明引用 DTD，因为 HTML 4.01 基于 SGML。DTD 规定了标记语言的规则，这样浏览器才能正确地呈现内容。</p>
<p>HTML5 不基于 SGML，所以不需要引用 DTD。</p>
<p>提示：请始终向 HTML 文档添加 &lt;!DOCTYPE&gt; 声明，这样浏览器才能获知文档类型。</p>
</li>
</ul>
<ul>
<li><p>target属性</p>
<p>\<a> 标签的 target 属性规定在何处打开链接文档。</a></p>
<p>如果在一个 \<a> 标签内包含一个 target 属性，浏览器将会载入和显示用这个标签的 href 属性命名的、名称与这个目标吻合的框架或者窗口中的文档。如果这个指定名称或 id 的框架或者窗口不存在，浏览器将打开一个新的窗口，给这个窗口一个指定的标记，然后将新的文档载入那个窗口。从此以后，超链接文档就可以指向这个新的窗口。</a></p>
<p>_blank</p>
<p>浏览器总在一个新打开、未命名的窗口中载入目标文档。</p>
<p>_self<br>这个目标的值对所有没有指定目标的 <a> 标签是默认目标，它使得目标文档载入并显示在相同的框架或者窗口中作为源文档。这个目标是多余且不必要的，除非和文档标题 <base> 标签中的 target 属性一起使用。</a></p>
<p>_parent<br>这个目标使得文档载入父窗口或者包含来超链接引用的框架的框架集。如果这个引用是在窗口或者在顶级框架中，那么它与目标 _self 等效。</p>
<p>_top<br>这个目标使得文档载入包含这个超链接的窗口，用 _top 目标将会清除所有被包含的框架并将文档载入整个浏览器窗口。</p>
<p>​</p>
</li>
</ul>
<p>这里多说一句，使用鼠标中键点击链接就会自动在新窗口打开。估计有很多人都不知道鼠标滚轮是可以按的，也就是传说中的鼠标中键。</p>
<ul>
<li><p>overflow-x 属性规定是否对内容的左/右边缘进行裁剪 - 如果溢出元素内容区域的话。</p>
<p>overflow-y 属性规定是否对内容的上/下边缘进行裁剪 - 如果溢出元素内容区域的话。</p>
<p>无法在IE8及以下<br>visible    不裁剪内容，可能会显示在内容框之外。<br>hidden    裁剪内容 - 不提供滚动机制。<br>scroll    裁剪内容 - 提供滚动机制。<br>auto    如果溢出框，则应该提供滚动机制。<br>no-display    如果内容不适合内容框，则删除整个框。<br>no-content    如果内容不适合内容框，则隐藏整个内容。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2018/01/24/--CSS笔记（一）/" data-id="cjct7q5nh0000hsbzi6mcs3qv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post---JDK1.8中接口的新特性" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/24/--JDK1.8中接口的新特性/" class="article-date">
  <time datetime="2018-01-24T14:54:35.265Z" itemprop="datePublished">2018-01-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java基础/">Java基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/24/--JDK1.8中接口的新特性/">JDK1.8中接口的新特性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>昨天在牛客网做题，有一道题叫做在JDK8的环境下，接口能不能有具体的方法实现还是只能有抽象方法。</p>
<p>当然原题是个选择题，问法也不是这样问的。如果是这样问的，大家肯定都会想着是不是JDK8有更改了，接口里不只是可以有抽象方法了，也可以有具体的实现了，是的，确实是这样。我们今天就来看看下JDK8中接口的新特性。</p>
<h3 id="JDK8中接口的新特性"><a href="#JDK8中接口的新特性" class="headerlink" title="JDK8中接口的新特性"></a>JDK8中接口的新特性</h3><p>在JDK8环境中，接口中的方法不再是只能有抽象方法，他可以有静态方法和default方法。</p>
<p>我们来看一个例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wangcc.MyJavaSE.jdk8interface;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NewInterface</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"staticMethod"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">defaultMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"defaultMethod"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给出一个接口，在JDK8的环境下，他可以拥有静态方法和default方法，所谓default方法既是使用default关键字来修饰的方法。一个接口可以有多个静态方法和default方法，没有个数限制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wangcc.MyJavaSE.jdk8interface;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleImpl</span> <span class="keyword">implements</span> <span class="title">NewInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"INFO"</span>);</span><br><span class="line">		defaultMethod();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现类只需要实现它的抽象方法即可，JDK8中的接口愈发的像抽象类靠拢的感觉。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wangcc.MyJavaSE.jdk8interface;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewInterfaceTest</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		NewInterface.staticMethod();</span><br><span class="line">		<span class="keyword">new</span> SimpleImpl().defaultMethod();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于静态方法和default方法的调用。</p>
<p>对于静态方法，并没有特殊的地方，在接口中直接由接口名调用，不需要由接口实现类对象来调用。</p>
<p>而对于default方法，很明显是需要实力对象来调用的。而且有一点需要特别注意。</p>
<p>我们知道在Java中是单继承的，但是是可以实现多个接口的，所以，当一个类实现了多个接口之后，如果多个接口有着相同的default方法，即方法名和参数列表相同。那么此时就会出现问题，无法识别到底是调用的哪个接口的方法，这个时候就必须要在实现类里面显式重写default的方法，而关于default的方法的重写,我们在实现类中不需要继续出现default关键字也不能出现default关键字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wangcc.MyJavaSE.jdk8interface;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleImpl</span> <span class="keyword">implements</span> <span class="title">NewInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"INFO"</span>);</span><br><span class="line">		defaultMethod();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">defaultMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Impl default Method"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重写的default方法必须的访问权限必须是public，因为default方法除了没有显式的访问修饰符外，只能用public访问限定符来修饰，而我们知道在Java中，要重写一个方法，访问限定符一定要大于父类或者接口指定的访问限定符范围，而且方法声明处抛出的异常也要大于后者。所以访问权限必须是public。</p>
<p>最后，当default方法和实现类继承的父类的方法同名时，优先调用父类的方法。</p>
<h3 id="strictfp关键字"><a href="#strictfp关键字" class="headerlink" title="strictfp关键字"></a>strictfp关键字</h3><p>今天在看default关键字的时候无意中发现了还有一个名为strictfp的关键字，这个关键字可是之前从来都没有看过额。那今天碰到了就记录一下吧，目前的场景还没有用到过。</p>
<p>自Java2以来，Java语言增加了一个关键字strictfp</p>
<p>strictfp 的意思是FP-strict，也就是说精确浮点的意思。在Java虚拟机进行浮点运算时，如果没有指定strictfp关键字时，Java的编译器以及运 行环境在对浮点运算的表达式是采取一种近似于我行我素的行为来完成这些操作，以致于得到的结果往往无法令你满意。而一旦使用了strictfp来声明一个 类、接口或者方法时，那么所声明的范围内Java的编译器以及运行环境会完全依照浮点规范IEEE-754来执行。因此如果你想让你的浮点运算更加精确， 而且不会因为不同的硬件平台所执行的结果不一致的话，那就请用关键字strictfp。</p>
<p>你可以将一个类、接口以及方法声明为strictfp，但是不允许对接口中的方法以及构造函数声明strictfp关键字。现在这句话就需要更改了，是不允许对接口中的抽象方法使用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2018/01/24/--JDK1.8中接口的新特性/" data-id="cjct6yxxe000044bzpl8htft7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Spring AOP源码​" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/21/Spring AOP源码​/" class="article-date">
  <time datetime="2018-01-21T14:07:52.843Z" itemprop="datePublished">2018-01-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/21/Spring AOP源码​/">Spring AOP源码（一）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>上一篇我们讲解了Spring对aop配置的处理，但是还没有讲Spring中是怎么运用这些配置的。今天我们就俩看下Spring是怎么让这些东西起作用的。</p>
<h3 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h3><p>在讲解之前，我们需要先认识一下BeanPostProcessor接口。</p>
<p>我们回到AbstractApplicationContext的refresh方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">			<span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">			prepareRefresh();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">			prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">				postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">				invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">				registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Initialize message source for this context.</span></span><br><span class="line">				initMessageSource();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">				initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">				onRefresh();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">				registerListeners();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">				finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">				finishRefresh();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">				logger.warn(<span class="string">"Exception encountered during context initialization - cancelling refresh attempt"</span>, ex);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">				destroyBeans();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Reset 'active' flag.</span></span><br><span class="line">				cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Propagate exception to caller.</span></span><br><span class="line">				<span class="keyword">throw</span> ex;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>我们解析aop配置的操作是在        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();中完成的。</p>
<p>我们继续往下看，可以看到有registerBeanPostProcessors(beanFactory);方法</p>
<p>这个方法就是把所有的实现BeanPostProcessor接口的Bean都注入到AbstractBeanFactory的beanPostProcessors属性中。这个跟invokeBeanFactoryPostProcessors方法中将所有实现了BeanFactoryPostProcessor接口的Bean都注入到相应的list集合中并调用其postProcessBeanFactory方法的实现是大体一样的，这里就不再说了，可以看看之前讲解Spring解析属性文件的源码解析部分。</p>
<p>然后我们就直接看到实例化bean的代码段把，在refresh就是    finishBeanFactoryInitialization(beanFactory);的具体实现，我们不一层一层看了，直接看AbstractAutowireCapableBeanFactory类的</p>
<p><strong>initializeBean</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">			AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					invokeAwareMethods(beanName, bean);</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;, getAccessControlContext());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			invokeAwareMethods(beanName, bean);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Object wrappedBean = bean;</span><br><span class="line">		<span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">			wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">					(mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</span><br><span class="line">					beanName, <span class="string">"Invocation of init method failed"</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">			wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> wrappedBean;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法我们已经不陌生了，我们在讲解SpringMVC的时候提到过InitializingBean接口，如果Bean实现了这个接口，会在实例化Bean的时候通过该方法中的invokeInitMethods来调用afterPropertiesSet()方法。而今天在我们关注的BeanPostProcessor接口中，在这个类对应的方法很显然就是</p>
<p>applyBeanPostProcessorsBeforeInitialization和applyBeanPostProcessorsAfterInitialization方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsBeforeInitialization</span><span class="params">(Object existingBean, String beanName)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">	Object result = existingBean;</span><br><span class="line">	<span class="keyword">for</span> (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">		result = beanProcessor.postProcessBeforeInitialization(result, beanName);</span><br><span class="line">		<span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一目了然，就是遍历所有的BeanPostProcessor实现类（已经在registerBeanPostProcessors得到了所有的实现类集合），然后以当前Bean的信息为参数来调用他的postProcessBeforeInitialization方法。</p>
<p>同理如果是applyBeanPostProcessorsAfterInitialization方法，便是遍历后调用postProcessAfterInitialization方法。</p>
<p>分析到这里，很明显我们就可以吧目光转向AspectJAwareAdvisorAutoProxyCreator的这两个方法了。</p>
<h3 id="AspectJAwareAdvisorAutoProxyCreator"><a href="#AspectJAwareAdvisorAutoProxyCreator" class="headerlink" title="AspectJAwareAdvisorAutoProxyCreator"></a>AspectJAwareAdvisorAutoProxyCreator</h3><p>### </p>
<p>在我们上一篇讲解ConfigBeanDefinitionParser的parse方法的时候，说到    configureAutoProxyCreator(parserContext, element);的时候说先不细说，那么到了这一篇就需要从这里入手了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configureAutoProxyCreator</span><span class="params">(ParserContext parserContext, Element element)</span> </span>&#123;</span><br><span class="line">		AopNamespaceUtils.registerAspectJAutoProxyCreatorIfNecessary(parserContext, element);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerAspectJAutoProxyCreatorIfNecessary</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			ParserContext parserContext, Element sourceElement)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		BeanDefinition beanDefinition = AopConfigUtils.registerAspectJAutoProxyCreatorIfNecessary(</span><br><span class="line">				parserContext.getRegistry(), parserContext.extractSource(sourceElement));</span><br><span class="line">		useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement);</span><br><span class="line">		registerComponentIfNecessary(beanDefinition, parserContext);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>1.得到一个包含AspectJAwareAdvisorAutoProxyCreator实例的Bean定义。</p>
<p>2.根据element节点的相关属性设置一些属性。</p>
<p>3.将1中得到的Bean定义注册到Spring容器中。</p>
<p>我们详细说一下1和2.</p>
<p><strong>registerAspectJAutoProxyCreatorIfNecessary</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BeanDefinition <span class="title">registerAspectJAutoProxyCreatorIfNecessary</span><span class="params">(BeanDefinitionRegistry registry, Object source)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> registerOrEscalateApcAsRequired(AspectJAwareAdvisorAutoProxyCreator.class, registry, source);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BeanDefinition <span class="title">registerOrEscalateApcAsRequired</span><span class="params">(Class&lt;?&gt; cls, BeanDefinitionRegistry registry, Object source)</span> </span>&#123;</span><br><span class="line">		Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>);</span><br><span class="line">		<span class="keyword">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;</span><br><span class="line">			BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class="line">			<span class="keyword">if</span> (!cls.getName().equals(apcDefinition.getBeanClassName())) &#123;</span><br><span class="line">				<span class="keyword">int</span> currentPriority = findPriorityForClass(apcDefinition.getBeanClassName());</span><br><span class="line">				<span class="keyword">int</span> requiredPriority = findPriorityForClass(cls);</span><br><span class="line">				<span class="keyword">if</span> (currentPriority &lt; requiredPriority) &#123;</span><br><span class="line">					apcDefinition.setBeanClassName(cls.getName());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		RootBeanDefinition beanDefinition = <span class="keyword">new</span> RootBeanDefinition(cls);</span><br><span class="line">		beanDefinition.setSource(source);</span><br><span class="line">		beanDefinition.getPropertyValues().add(<span class="string">"order"</span>, Ordered.HIGHEST_PRECEDENCE);</span><br><span class="line">		beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">		registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);</span><br><span class="line">		<span class="keyword">return</span> beanDefinition;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>   1)当Spring容器中已经有名为org.springframework.aop.config.internalAutoProxyCreator的Bean。</p>
<p>获取对应的Bean定义，把这个Bean定义的ClassName和AspectJAwareAdvisorAutoProxyCreator比较，如果不相同，比较两个ClassName的优先级。如果AspectJAwareAdvisorAutoProxyCreator的优先级高，则把当前的Bean定义的ClassName设置为AspectJAwareAdvisorAutoProxyCreator。优先级为：</p>
<p>AnnotationAwareAspectJAutoProxyCreator&gt;AspectJAwareAdvisorAutoProxyCreator&gt;InfrastructureAdvisorAutoProxyCreator。</p>
<p>2）如果当前容器中并没有这个BeanName存在。那么就使用AspectJAwareAdvisorAutoProxyCreator构造出一个Bean定义，并注册一些相关属性，把order优先级设置为最低等等。然后返回。</p>
<p><strong>useClassProxyingIfNecessary</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useClassProxyingIfNecessary</span><span class="params">(BeanDefinitionRegistry registry, Element sourceElement)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (sourceElement != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">boolean</span> proxyTargetClass = Boolean.valueOf(sourceElement.getAttribute(PROXY_TARGET_CLASS_ATTRIBUTE));</span><br><span class="line">		<span class="keyword">if</span> (proxyTargetClass) &#123;</span><br><span class="line">			AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">boolean</span> exposeProxy = Boolean.valueOf(sourceElement.getAttribute(EXPOSE_PROXY_ATTRIBUTE));</span><br><span class="line">		<span class="keyword">if</span> (exposeProxy) &#123;</span><br><span class="line">			AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是看到了熟悉的东西，proxy-target-class属性在我们一开始学习aop配置的时候经常会提到，人们通常会告诉你，如果你想对类直接使用动态，那可以在\<aop:config>节点里配置属性：proxy-target-class=true即可,那么动态代理就会使用cglib来完成，cglib可以直接针对类来实现动态代理，而如果我们在aop配置的时候没有设置这个属性或者设置为false，那么就会使用JDK动态代理，这个时候就只能针对接口实现动态代理。</aop:config></p>
<p>那么这个方法其实他的主要作用就是为了上述的Bean定义注册两个属性，分别是proxyTargetClass和exposeProxy。</p>
<p>好了到现在，我们终于往Spring容器中注入了AspectJAwareAdvisorAutoProxyCreator构成的Bean定义。</p>
<p>我们来看下AspectJAwareAdvisorAutoProxyCreator的继承结构。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectJAwareAdvisorAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">AbstractAdvisorAutoProxyCreator</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAdvisorAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">AbstractAutoProxyCreator</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">ProxyProcessorSupport</span></span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">SmartInstantiationAwareBeanPostProcessor</span>, <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmartInstantiationAwareBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title">InstantiationAwareBeanPostProcessor</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InstantiationAwareBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyProcessorSupport</span> <span class="keyword">extends</span> <span class="title">ProxyConfig</span> <span class="keyword">implements</span> <span class="title">Ordered</span>, <span class="title">BeanClassLoaderAware</span>, <span class="title">AopInfrastructureBean</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<p>我们发现他的祖先类有实现了BeanPostProcessor接口。</p>
<p>翻阅源码，你会发现AspectJAwareAdvisorAutoProxyCreator以及他的祖先类都没有对postProcessBeforeInitialization方法有具体的实现，而只有对postProcessAfterInitialization方法有具体实现。</p>
<p>这个方法的实现在祖先类AbstractAutoProxyCreator中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">	if (bean != null) &#123;</span><br><span class="line">		Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">		if (!this.earlyProxyReferences.contains(cacheKey)) &#123;</span><br><span class="line">			return wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看方法的重点wrapIfNecessary</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (beanName != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">			<span class="keyword">return</span> bean;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line">			<span class="keyword">return</span> bean;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">			<span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">			<span class="keyword">return</span> bean;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Create proxy if we have advice.</span></span><br><span class="line">		Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line">		<span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">			<span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">			Object proxy = createProxy(bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line">			<span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">			<span class="keyword">return</span> proxy;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>1.通过getAdvicesAndAdvisorsForBean来获取可以对当前Bean做代理的AdviceBean。</p>
<p>2.如果AdviceBean不为空，则创建动态代理类，最后把其放入缓存，然后返回。</p>
<p><strong>getAdvicesAndAdvisorsForBean</strong></p>
<p>AbstractAdvisorAutoProxyCreator</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Object[] getAdvicesAndAdvisorsForBean(Class&lt;?&gt; beanClass, String beanName, TargetSource targetSource) &#123;</span><br><span class="line">	List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);</span><br><span class="line">	<span class="keyword">if</span> (advisors.isEmpty()) &#123;</span><br><span class="line">		<span class="keyword">return</span> DO_NOT_PROXY;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> advisors.toArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用当前bean的Class和beanName来找到匹配的Advisors</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findEligibleAdvisors</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">	List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">	List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class="line">	extendAdvisors(eligibleAdvisors);</span><br><span class="line">	<span class="keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class="line">		eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1)先获取所有的Advisor</p>
<p>2)然后调用findAdvisorsThatCanApply在所有的Advisor找到符合条件的Advisor集合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findAdvisorsThatCanApply</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	ProxyCreationContext.setCurrentProxiedBeanName(beanName);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		ProxyCreationContext.setCurrentProxiedBeanName(<span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Advisor&gt; <span class="title">findAdvisorsThatCanApply</span><span class="params">(List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (candidateAdvisors.isEmpty()) &#123;</span><br><span class="line">		<span class="keyword">return</span> candidateAdvisors;</span><br><span class="line">	&#125;</span><br><span class="line">	List&lt;Advisor&gt; eligibleAdvisors = <span class="keyword">new</span> LinkedList&lt;Advisor&gt;();</span><br><span class="line">	<span class="keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;</span><br><span class="line">		<span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> IntroductionAdvisor &amp;&amp; canApply(candidate, clazz)) &#123;</span><br><span class="line">			eligibleAdvisors.add(candidate);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">boolean</span> hasIntroductions = !eligibleAdvisors.isEmpty();</span><br><span class="line">	<span class="keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;</span><br><span class="line">		<span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line">			<span class="comment">// already processed</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (canApply(candidate, clazz, hasIntroductions)) &#123;</span><br><span class="line">			eligibleAdvisors.add(candidate);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到选出适合的Advisor的主要方法是canApply，我们主要看这个方法。</p>
<p><strong>canApply</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canApply</span><span class="params">(Pointcut pc, Class&lt;?&gt; targetClass, <span class="keyword">boolean</span> hasIntroductions)</span> </span>&#123;</span><br><span class="line">		Assert.notNull(pc, <span class="string">"Pointcut must not be null"</span>);</span><br><span class="line">		<span class="keyword">if</span> (!pc.getClassFilter().matches(targetClass)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		MethodMatcher methodMatcher = pc.getMethodMatcher();</span><br><span class="line">		IntroductionAwareMethodMatcher introductionAwareMethodMatcher = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (methodMatcher <span class="keyword">instanceof</span> IntroductionAwareMethodMatcher) &#123;</span><br><span class="line">			introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Set&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> LinkedHashSet&lt;Class&lt;?&gt;&gt;(ClassUtils.getAllInterfacesForClassAsSet(targetClass));</span><br><span class="line">		classes.add(targetClass);</span><br><span class="line">		<span class="keyword">for</span> (Class&lt;?&gt; clazz : classes) &#123;</span><br><span class="line">			Method[] methods = clazz.getMethods();</span><br><span class="line">			<span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">				<span class="keyword">if</span> ((introductionAwareMethodMatcher != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">						introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) ||</span><br><span class="line">						methodMatcher.matches(method, targetClass)) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>接下来看创建代理对象</p>
<p><strong>createProxy</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createProxy</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		Class&lt;?&gt; beanClass, String beanName, Object[] specificInterceptors, TargetSource targetSource)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">	proxyFactory.copyFrom(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">			proxyFactory.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">	<span class="keyword">for</span> (Advisor advisor : advisors) &#123;</span><br><span class="line">		proxyFactory.addAdvisor(advisor);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	proxyFactory.setTargetSource(targetSource);</span><br><span class="line">	customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line">	proxyFactory.setFrozen(<span class="keyword">this</span>.freezeProxy);</span><br><span class="line">	<span class="keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line">		proxyFactory.setPreFiltered(<span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法大体的意思就是新建一个ProxyFactory对象，然后将满足条件的Advisor信息都注入到这个对象中，最后调用 proxyFactory.getProxy(getProxyClassLoader());来创建代理对象。</p>
<p><strong>getProxy</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> createAopProxy().getProxy(classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>createAopProxy</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">protected final synchronized AopProxy createAopProxy() &#123;</span><br><span class="line">	if (!this.active) &#123;</span><br><span class="line">		activate();</span><br><span class="line">	&#125;</span><br><span class="line">	return getAopProxyFactory().createAopProxy(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终调用的是DefaultAopProxyFactory的createAopProxy方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">			Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">			<span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> +</span><br><span class="line">						<span class="string">"Either an interface or a target is required for proxy creation."</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (targetClass.isInterface()) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>方法很容易理解，如果proxy-target-class属性指定为true，而且不是对接口进行动态代理，就调用ObjenesisCglibAopProxy来完成动态代理，即使用CGLIB来完成动态代理。否则就是调用JdkDynamicAopProxy来完成动态代理，即使用JDK动态代理来实现。</p>
<p>我们先看我们熟悉的JDK动态代理的具体实现。</p>
<p>JdkDynamicAopProxy</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(<span class="string">"Creating JDK dynamic proxy: target source is "</span> + <span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">	&#125;</span><br><span class="line">	Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised);</span><br><span class="line">	findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line">	<span class="keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getProxy的方法很简单，就是使用当前的ClassLoader来加载当前Bean实现的所有接口，最后生成相应的动态代理实例。</p>
<p>至此，创建动态代理实例的过程就分析完了。</p>
<p>但是更重要的是当我们调用动态代理实例时，JdkDynamicAopProxy中对InvocationHandler接口的的具体实现。</p>
<p><strong>invoke</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		MethodInvocation invocation;</span><br><span class="line">		Object oldProxy = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">		TargetSource targetSource = <span class="keyword">this</span>.advised.targetSource;</span><br><span class="line">		Class&lt;?&gt; targetClass = <span class="keyword">null</span>;</span><br><span class="line">		Object target = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (!<span class="keyword">this</span>.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;</span><br><span class="line">				<span class="comment">// The target does not implement the equals(Object) method itself.</span></span><br><span class="line">				<span class="keyword">return</span> equals(args[<span class="number">0</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!<span class="keyword">this</span>.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;</span><br><span class="line">				<span class="comment">// The target does not implement the hashCode() method itself.</span></span><br><span class="line">				<span class="keyword">return</span> hashCode();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!<span class="keyword">this</span>.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;</span><br><span class="line">					method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123;</span><br><span class="line">				<span class="comment">// Service invocations on ProxyConfig with the proxy config...</span></span><br><span class="line">				<span class="keyword">return</span> AopUtils.invokeJoinpointUsingReflection(<span class="keyword">this</span>.advised, method, args);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			Object retVal;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line">				<span class="comment">// Make invocation available if necessary.</span></span><br><span class="line">				oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">				setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// May be null. Get as late as possible to minimize the time we "own" the target,</span></span><br><span class="line">			<span class="comment">// in case it comes from a pool.</span></span><br><span class="line">			target = targetSource.getTarget();</span><br><span class="line">			<span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">				targetClass = target.getClass();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Get the interception chain for this method.</span></span><br><span class="line">			List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Check whether we have any advice. If we don't, we can fallback on direct</span></span><br><span class="line">			<span class="comment">// reflective invocation of the target, and avoid creating a MethodInvocation.</span></span><br><span class="line">			<span class="keyword">if</span> (chain.isEmpty()) &#123;</span><br><span class="line">				<span class="comment">// We can skip creating a MethodInvocation: just invoke the target directly</span></span><br><span class="line">				<span class="comment">// Note that the final invoker must be an InvokerInterceptor so we know it does</span></span><br><span class="line">				<span class="comment">// nothing but a reflective operation on the target, and no hot swapping or fancy proxying.</span></span><br><span class="line">				retVal = AopUtils.invokeJoinpointUsingReflection(target, method, args);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// We need to create a method invocation...</span></span><br><span class="line">				invocation = <span class="keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line">				<span class="comment">// Proceed to the joinpoint through the interceptor chain.</span></span><br><span class="line">				retVal = invocation.proceed();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Massage return value if necessary.</span></span><br><span class="line">			Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line">			<span class="keyword">if</span> (retVal != <span class="keyword">null</span> &amp;&amp; retVal == target &amp;&amp; returnType.isInstance(proxy) &amp;&amp;</span><br><span class="line">					!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123;</span><br><span class="line">				<span class="comment">// Special case: it returned "this" and the return type of the method</span></span><br><span class="line">				<span class="comment">// is type-compatible. Note that we can't help if the target sets</span></span><br><span class="line">				<span class="comment">// a reference to itself in another returned object.</span></span><br><span class="line">				retVal = proxy;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (retVal == <span class="keyword">null</span> &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(</span><br><span class="line">						<span class="string">"Null return value from advice does not match primitive return type for: "</span> + method);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> retVal;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (target != <span class="keyword">null</span> &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">				<span class="comment">// Must have come from TargetSource.</span></span><br><span class="line">				targetSource.releaseTarget(target);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line">				<span class="comment">// Restore old proxy.</span></span><br><span class="line">				AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>我们直接看重点，直接跳过对不需要执行增强方法的方法的处理。</p>
<p>调用this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);来获得当前方法匹配的Advisor集合。</p>
<p>当Advisor集合不为空的时候，执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We need to create a method invocation...</span></span><br><span class="line">invocation = <span class="keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line"><span class="comment">// Proceed to the joinpoint through the interceptor chain.</span></span><br><span class="line">retVal = invocation.proceed();</span><br></pre></td></tr></table></figure>
<p>这两行就是关键。</p>
<p>我们重点看ReflectiveMethodInvocation的proceed()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">	<span class="comment">//	We start with an index of -1 and increment early.</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.currentInterceptorIndex == <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> invokeJoinpoint();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Object interceptorOrInterceptionAdvice =</span><br><span class="line">			<span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="keyword">this</span>.currentInterceptorIndex);</span><br><span class="line">	<span class="keyword">if</span> (interceptorOrInterceptionAdvice <span class="keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line">		<span class="comment">// Evaluate dynamic method matcher here: static part will already have</span></span><br><span class="line">		<span class="comment">// been evaluated and found to match.</span></span><br><span class="line">		InterceptorAndDynamicMethodMatcher dm =</span><br><span class="line">				(InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class="line">		<span class="keyword">if</span> (dm.methodMatcher.matches(<span class="keyword">this</span>.method, <span class="keyword">this</span>.targetClass, <span class="keyword">this</span>.arguments)) &#123;</span><br><span class="line">			<span class="keyword">return</span> dm.interceptor.invoke(<span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Dynamic matching failed.</span></span><br><span class="line">			<span class="comment">// Skip this interceptor and invoke the next in the chain.</span></span><br><span class="line">			<span class="keyword">return</span> proceed();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// It's an interceptor, so we just invoke it: The pointcut will have</span></span><br><span class="line">		<span class="comment">// been evaluated statically before this object was constructed.</span></span><br><span class="line">		<span class="keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的主要操作就是使用责任链模式来调用chain集合里的interceptor属性的invoke方法。</p>
<p>所以我们只要来看看这个chain到底是怎么个东西就好了。具体怎么得到这个chain的我们就不细说了，有兴趣的可以看源码（DefaultAdvisorAdapterRegistry的getInterceptors方法），chain集合是一个MethodInterceptor集合。</p>
<p>这个Intercepor集合主要包含下面几种：</p>
<p>AspectJAfterThrowingAdvice   对应着aop配置里面\<aop:after-returning>节点里的方法。</aop:after-returning></p>
<p>AspectJAfterAdvice      对应着 \<aop:after></aop:after></p>
<p>AspectJAroundAdvice         对应着 \<aop:around></aop:around></p>
<p>AfterReturningAdviceInterceptor 对应着AfterReturningAdvice      对应着 \<aop:after-returning></aop:after-returning></p>
<p>MethodBeforeAdviceInterceptor       对应着 MethodBeforeAdvice        对应着\ <aop:before></aop:before></p>
<p>这几种MethodInterceptor调用的先后顺序，如果没有在配置文件中指定Order，那么就会以在配置文件中出现的顺序来执行。执行的过程是一个责任链模式的应用，有兴趣的同学可以先一个例子debug深入研究。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2018/01/21/Spring AOP源码​/" data-id="cjcov2eib0000jwbzx5uyil68" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post---Spring源码之AOP" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/21/--Spring源码之AOP/" class="article-date">
  <time datetime="2018-01-21T14:07:52.842Z" itemprop="datePublished">2018-01-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/21/--Spring源码之AOP/">Spring源码之AOP</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前说过了IOC，现在自然要来到AOP了，先来看下配置文件实现的AOP的相关源码解析。</p>
<p>显然还是会用到BeanDefinitionParser接口的实现类。</p>
<p>这里是用ConfigBeanDefinitionParser实现类来完成对\<aop:config>节点的解析。</aop:config></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"xmlHandler"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.tgb.aop.XMLAdvice"</span> /&gt;  </span><br><span class="line">&lt;aop:config&gt;  </span><br><span class="line">    &lt;aop:aspect id=<span class="string">"aspect"</span> ref=<span class="string">"xmlHandler"</span>&gt;  </span><br><span class="line">        &lt;aop:pointcut id=<span class="string">"pointUserMgr"</span> expression=<span class="string">"execution(* com.tgb.aop.*.find*(..))"</span>/&gt;  </span><br><span class="line">          </span><br><span class="line">        &lt;aop:before method=<span class="string">"doBefore"</span>  pointcut-ref=<span class="string">"pointUserMgr"</span>/&gt;  </span><br><span class="line">        &lt;aop:after method=<span class="string">"doAfter"</span>  pointcut-ref=<span class="string">"pointUserMgr"</span>/&gt;  </span><br><span class="line">        &lt;aop:around method=<span class="string">"doAround"</span>  pointcut-ref=<span class="string">"pointUserMgr"</span>/&gt;  </span><br><span class="line">        &lt;aop:after-returning method=<span class="string">"doReturn"</span>  pointcut-ref=<span class="string">"pointUserMgr"</span>/&gt;  </span><br><span class="line">        &lt;aop:after-throwing method=<span class="string">"doThrowing"</span> throwing=<span class="string">"ex"</span> pointcut-ref=<span class="string">"pointUserMgr"</span>/&gt;  </span><br><span class="line">          </span><br><span class="line">    &lt;/aop:aspect&gt;</span><br></pre></td></tr></table></figure>
<h3 id="ConfigBeanDefinitionParser"><a href="#ConfigBeanDefinitionParser" class="headerlink" title="ConfigBeanDefinitionParser"></a>ConfigBeanDefinitionParser</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">		CompositeComponentDefinition compositeDef =</span><br><span class="line">				<span class="keyword">new</span> CompositeComponentDefinition(element.getTagName(), parserContext.extractSource(element));</span><br><span class="line">		parserContext.pushContainingComponent(compositeDef);</span><br><span class="line"><span class="comment">//向Spring容器注册了一个BeanName为org.springframework.aop.config.internalAutoProxyCreator的Bean定义，可以自定义也可以使用Spring提供的（根据优先级来）</span></span><br><span class="line">      <span class="comment">//深入这个方法你会发现熟悉的proxy-target-class属性 以及一个不是很常用的exposeProxy属性</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	向Spring容器注册了一个BeanName为org.springframework.aop.config.internalAutoProxyCreator的Bean定义，可以自定义也可以使用Spring提供的（根据优先级来）</span></span><br><span class="line"><span class="comment">Spring默认提供的是org.springframework.aop.aspectj.autoproxy.AspectJAwareAdvisorAutoProxyCreator，这个类是AOP的核心类，留在下篇讲解</span></span><br><span class="line"><span class="comment">在这个方法里面也会根据配置proxy-target-class和expose-proxy，设置是否使用CGLIB进行代理以及是否暴露最终的代理。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">      </span><br><span class="line">      configureAutoProxyCreator(parserContext, element);</span><br><span class="line"></span><br><span class="line">		List&lt;Element&gt; childElts = DomUtils.getChildElements(element);</span><br><span class="line">		<span class="keyword">for</span> (Element elt: childElts) &#123;</span><br><span class="line">			String localName = parserContext.getDelegate().getLocalName(elt);</span><br><span class="line">			<span class="keyword">if</span> (POINTCUT.equals(localName)) &#123;</span><br><span class="line">				parsePointcut(elt, parserContext);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (ADVISOR.equals(localName)) &#123;</span><br><span class="line">				parseAdvisor(elt, parserContext);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (ASPECT.equals(localName)) &#123;</span><br><span class="line">				parseAspect(elt, parserContext);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		parserContext.popAndRegisterContainingComponent();</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>我们直接来看解析\<aop:config>的方法。</aop:config></p>
<p>1.调用  configureAutoProxyCreator(parserContext, element);在向Spring容器里注册一个名为</p>
<p><strong>org.springframework.aop.config.internalAutoProxyCreator</strong>的Bean定义，类型默认是</p>
<p><strong>org.springframework.aop.aspectj.autoproxy.AspectJAwareAdvisorAutoProxyCreator</strong>,</p>
<p>具体实现先不细说。</p>
<p>2.接着往下看，我们的配置文件里面config节点下是aspect，所以我们这里直接看parseAspect(elt, parserContext);这个方法就帮我们解析了aspect节点下的所有配置，是我们今天要关注的重点。</p>
<p><strong>parseAspect(elt, parserContext)</strong></p>
<p>parseAspect</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseAspect</span><span class="params">(Element aspectElement, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//获取ID和指定的beanName</span></span><br><span class="line">		String aspectId = aspectElement.getAttribute(ID);</span><br><span class="line">		String aspectName = aspectElement.getAttribute(REF);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//往paresState这个栈里面推入一个当前aspcet节点的Entry</span></span><br><span class="line">			<span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> AspectEntry(aspectId, aspectName));</span><br><span class="line">          <span class="comment">//新建一个Bean定义List和BeanReference的List，在将Bean定义转化为Bean的时候会用到</span></span><br><span class="line">			List&lt;BeanDefinition&gt; beanDefinitions = <span class="keyword">new</span> ArrayList&lt;BeanDefinition&gt;();</span><br><span class="line">			List&lt;BeanReference&gt; beanReferences = <span class="keyword">new</span> ArrayList&lt;BeanReference&gt;();</span><br><span class="line"><span class="comment">//如果该aspect节点有declare-parents属性的话，得到其属性对应的值，然后对其进行处理。</span></span><br><span class="line">			List&lt;Element&gt; declareParents = DomUtils.getChildElementsByTagName(aspectElement, DECLARE_PARENTS);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = METHOD_INDEX; i &lt; declareParents.size(); i++) &#123;</span><br><span class="line">				Element declareParentsElement = declareParents.get(i);</span><br><span class="line">				beanDefinitions.add(parseDeclareParents(declareParentsElement, parserContext));</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// We have to parse "advice" and all the advice kinds in one loop, to get the</span></span><br><span class="line">			<span class="comment">// ordering semantics right.</span></span><br><span class="line">          <span class="comment">//对aspect下的子节点进行处理。</span></span><br><span class="line">			NodeList nodeList = aspectElement.getChildNodes();</span><br><span class="line">			<span class="keyword">boolean</span> adviceFoundAlready = <span class="keyword">false</span>;</span><br><span class="line">          <span class="comment">//****开始对子节点遍历</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodeList.getLength(); i++) &#123;</span><br><span class="line">				Node node = nodeList.item(i);</span><br><span class="line">              <span class="comment">/*</span></span><br><span class="line"><span class="comment">              即这个for循环只用来处理&lt;aop:aspect&gt;标签下的&lt;aop:before&gt;、&lt;aop:after&gt;、&lt;aop:after-returning&gt;、&lt;aop:after-throwing method=""&gt;、&lt;aop:around method=""&gt;这五个标签的。</span></span><br><span class="line"><span class="comment">              </span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">				<span class="keyword">if</span> (isAdviceNode(node, parserContext)) &#123;</span><br><span class="line">					<span class="keyword">if</span> (!adviceFoundAlready) &#123;</span><br><span class="line">						adviceFoundAlready = <span class="keyword">true</span>;</span><br><span class="line">						<span class="keyword">if</span> (!StringUtils.hasText(aspectName)) &#123;</span><br><span class="line">							parserContext.getReaderContext().error(</span><br><span class="line">									<span class="string">"&lt;aspect&gt; tag needs aspect bean reference via 'ref' attribute when declaring advices."</span>,</span><br><span class="line">									aspectElement, <span class="keyword">this</span>.parseState.snapshot());</span><br><span class="line">							<span class="keyword">return</span>;</span><br><span class="line">						&#125;</span><br><span class="line">                      <span class="comment">//要注入一个包含aspectName的beanReference，在aspectComponentDefinition 转化为Bean的时候会用到</span></span><br><span class="line">						beanReferences.add(<span class="keyword">new</span> RuntimeBeanReference(aspectName));</span><br><span class="line">					&#125;</span><br><span class="line">					AbstractBeanDefinition advisorDefinition = parseAdvice(</span><br><span class="line">							aspectName, i, aspectElement, (Element) node, parserContext, beanDefinitions, beanReferences);</span><br><span class="line">                  <span class="comment">//将advisorDefinition加入到beanDefinitions</span></span><br><span class="line">					beanDefinitions.add(advisorDefinition);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">	<span class="comment">//新建一个aspectComponentDefinition，注入了beanDefinitions beanReferences</span></span><br><span class="line">			AspectComponentDefinition aspectComponentDefinition = createAspectComponentDefinition(</span><br><span class="line">					aspectElement, aspectId, beanDefinitions, beanReferences, parserContext);</span><br><span class="line">			parserContext.pushContainingComponent(aspectComponentDefinition);</span><br><span class="line"></span><br><span class="line">			List&lt;Element&gt; pointcuts = DomUtils.getChildElementsByTagName(aspectElement, POINTCUT);</span><br><span class="line">			<span class="keyword">for</span> (Element pointcutElement : pointcuts) &#123;</span><br><span class="line">				parsePointcut(pointcutElement, parserContext);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			parserContext.popAndRegisterContainingComponent();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">this</span>.parseState.pop();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>我们直接从对aspect子节点遍历开始看起。</p>
<p>isAdviceNode(node, parserContext)的作用是筛选出了要处理的子节点的名字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAdviceNode</span><span class="params">(Node aNode, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!(aNode <span class="keyword">instanceof</span> Element)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		String name = parserContext.getDelegate().getLocalName(aNode);</span><br><span class="line">		<span class="keyword">return</span> (BEFORE.equals(name) || AFTER.equals(name) || AFTER_RETURNING_ELEMENT.equals(name) ||</span><br><span class="line">				AFTER_THROWING_ELEMENT.equals(name) || AROUND.equals(name));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以很清楚的看出，代表只会处理aop:aspect&gt;标签下的\<aop:before>、\<aop:after>、\<aop:after-returning>、\<aop:after-throwing method="">、\<aop:around method="">这五个标签。</aop:around></aop:after-throwing></aop:after-returning></aop:after></aop:before></p>
<p>接着看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AbstractBeanDefinition advisorDefinition = parseAdvice(</span><br><span class="line">						aspectName, i, aspectElement, (Element) node, parserContext, beanDefinitions, beanReferences);</span><br></pre></td></tr></table></figure>
<p>这里正式处理子节点了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AbstractBeanDefinition <span class="title">parseAdvice</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			String aspectName, <span class="keyword">int</span> order, Element aspectElement, Element adviceElement, ParserContext parserContext,</span></span></span><br><span class="line"><span class="function"><span class="params">			List&lt;BeanDefinition&gt; beanDefinitions, List&lt;BeanReference&gt; beanReferences)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//将当前的节点的信息放入到parseState栈中</span></span><br><span class="line">			<span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> AdviceEntry(parserContext.getDelegate().getLocalName(adviceElement)));</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">			<span class="comment">// create the method factory bean</span></span><br><span class="line">			RootBeanDefinition methodDefinition = <span class="keyword">new</span> RootBeanDefinition(MethodLocatingFactoryBean.class);</span><br><span class="line">			methodDefinition.getPropertyValues().add(<span class="string">"targetBeanName"</span>, aspectName);</span><br><span class="line">			methodDefinition.getPropertyValues().add(<span class="string">"methodName"</span>, adviceElement.getAttribute(<span class="string">"method"</span>));</span><br><span class="line">			methodDefinition.setSynthetic(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// create instance factory definition</span></span><br><span class="line">			RootBeanDefinition aspectFactoryDef =</span><br><span class="line">					<span class="keyword">new</span> RootBeanDefinition(SimpleBeanFactoryAwareAspectInstanceFactory.class);</span><br><span class="line">			aspectFactoryDef.getPropertyValues().add(<span class="string">"aspectBeanName"</span>, aspectName);</span><br><span class="line">			aspectFactoryDef.setSynthetic(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// register the pointcut</span></span><br><span class="line">			AbstractBeanDefinition adviceDef = createAdviceDefinition(</span><br><span class="line">					adviceElement, parserContext, aspectName, order, methodDefinition, aspectFactoryDef,</span><br><span class="line">					beanDefinitions, beanReferences);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// configure the advisor</span></span><br><span class="line">			RootBeanDefinition advisorDefinition = <span class="keyword">new</span> RootBeanDefinition(AspectJPointcutAdvisor.class);</span><br><span class="line">			advisorDefinition.setSource(parserContext.extractSource(adviceElement));</span><br><span class="line"><span class="comment">//看方法名就知道，当Adviser Bean定义通过Spring转化为AspectJPointcutAdvisor实例的时候，</span></span><br><span class="line">          <span class="comment">//advise Bean定义对应的AbstractAspectJAdvice实例将作为前者的构造方法的形参注入。</span></span><br><span class="line">          advisorDefinition.getConstructorArgumentValues().addGenericArgumentValue(adviceDef);</span><br><span class="line">		<span class="comment">//如果节点有order属性，要注入order属性</span></span><br><span class="line">          <span class="keyword">if</span> (aspectElement.hasAttribute(ORDER_PROPERTY)) &#123;</span><br><span class="line">				advisorDefinition.getPropertyValues().add(</span><br><span class="line">						ORDER_PROPERTY, aspectElement.getAttribute(ORDER_PROPERTY));</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// register the final advisor</span></span><br><span class="line">		<span class="comment">//注册到Spring容器中，即BeanFactory中	parserContext.getReaderContext().registerWithGeneratedName(advisorDefinition);</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> advisorDefinition;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">//出栈</span></span><br><span class="line">			<span class="keyword">this</span>.parseState.pop();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>1,创建一个Method工厂Bean定义，里面包含的信息有aspectname以及相应节点的method属性值。</p>
<p>2.创建一个aspectFactory工厂Bean定义，里面包含的信息有asepectname.</p>
<p>3.创建一个Advise Bean定义，下面会重点讲解。</p>
<p>4.创建一个Advisor Bean定义，将AdviseBean注入到其中，然后返回。看方法名就知道，当Adviser Bean定义通过Spring转化为AspectJPointcutAdvisor实例的时候，    advise Bean定义对应的AbstractAspectJAdvice实例将作为前者的构造方法的形参注入。</p>
<p>我们重点来看下是如何创建Advise Bean定义的。</p>
<p><strong>createAdviceDefinition</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AbstractBeanDefinition <span class="title">createAdviceDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			Element adviceElement, ParserContext parserContext, String aspectName, <span class="keyword">int</span> order,</span></span></span><br><span class="line"><span class="function"><span class="params">			RootBeanDefinition methodDef, RootBeanDefinition aspectFactoryDef,</span></span></span><br><span class="line"><span class="function"><span class="params">			List&lt;BeanDefinition&gt; beanDefinitions, List&lt;BeanReference&gt; beanReferences)</span> </span>&#123;</span><br><span class="line"><span class="comment">//新建Advice Bean定义</span></span><br><span class="line">		RootBeanDefinition adviceDefinition = <span class="keyword">new</span> RootBeanDefinition(getAdviceClass(adviceElement, parserContext));</span><br><span class="line">		adviceDefinition.setSource(parserContext.extractSource(adviceElement));</span><br><span class="line">	<span class="comment">//注入 aspectName和declarationOrder属性</span></span><br><span class="line">		adviceDefinition.getPropertyValues().add(ASPECT_NAME_PROPERTY, aspectName);</span><br><span class="line">		adviceDefinition.getPropertyValues().add(DECLARATION_ORDER_PROPERTY, order);</span><br><span class="line"><span class="comment">//如果该节点有returning属性，将其注入该Bean定义的returningName属性</span></span><br><span class="line">		<span class="keyword">if</span> (adviceElement.hasAttribute(RETURNING)) &#123;</span><br><span class="line">			adviceDefinition.getPropertyValues().add(</span><br><span class="line">					RETURNING_PROPERTY, adviceElement.getAttribute(RETURNING));</span><br><span class="line">		&#125;</span><br><span class="line">  <span class="comment">//如果该节点有throwing属性，那么将其注入到该Bean定义的throwingName属性</span></span><br><span class="line">		<span class="keyword">if</span> (adviceElement.hasAttribute(THROWING)) &#123;</span><br><span class="line">			adviceDefinition.getPropertyValues().add(</span><br><span class="line">					THROWING_PROPERTY, adviceElement.getAttribute(THROWING));</span><br><span class="line">		&#125;</span><br><span class="line">  <span class="comment">//如果该节点有arg-names属性，那么将其注入到该Bean定义的argumentNames属性</span></span><br><span class="line">		<span class="keyword">if</span> (adviceElement.hasAttribute(ARG_NAMES)) &#123;</span><br><span class="line">			adviceDefinition.getPropertyValues().add(</span><br><span class="line">					ARG_NAMES_PROPERTY, adviceElement.getAttribute(ARG_NAMES));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//很明显这里是为了该Bean定义中的Bean收集构造方法参数信息</span></span><br><span class="line">		ConstructorArgumentValues cav = adviceDefinition.getConstructorArgumentValues();</span><br><span class="line"><span class="comment">//第一个参数 Method		</span></span><br><span class="line">  cav.addIndexedArgumentValue(METHOD_INDEX, methodDef);</span><br><span class="line">	<span class="comment">//第二个参数 pointcut</span></span><br><span class="line">		Object pointcut = parsePointcutProperty(adviceElement, parserContext);</span><br><span class="line">		<span class="keyword">if</span> (pointcut <span class="keyword">instanceof</span> BeanDefinition) &#123;</span><br><span class="line">			cav.addIndexedArgumentValue(POINTCUT_INDEX, pointcut);</span><br><span class="line">			beanDefinitions.add((BeanDefinition) pointcut);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (pointcut <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">			RuntimeBeanReference pointcutRef = <span class="keyword">new</span> RuntimeBeanReference((String) pointcut);</span><br><span class="line">			cav.addIndexedArgumentValue(POINTCUT_INDEX, pointcutRef);</span><br><span class="line">			beanReferences.add(pointcutRef);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="comment">//第三个参数，asepctFactory</span></span><br><span class="line">		cav.addIndexedArgumentValue(ASPECT_INSTANCE_FACTORY_INDEX, aspectFactoryDef);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> adviceDefinition;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>1.通过节点的标签名字来得到要新建的AdviseBean定义的构造方法的入参。</p>
<p>getAdviceClass</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; getAdviceClass(Element adviceElement, ParserContext parserContext) &#123;</span><br><span class="line">		String elementName = parserContext.getDelegate().getLocalName(adviceElement);</span><br><span class="line">		<span class="keyword">if</span> (BEFORE.equals(elementName)) &#123;</span><br><span class="line">			<span class="keyword">return</span> AspectJMethodBeforeAdvice.class;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (AFTER.equals(elementName)) &#123;</span><br><span class="line">			<span class="keyword">return</span> AspectJAfterAdvice.class;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (AFTER_RETURNING_ELEMENT.equals(elementName)) &#123;</span><br><span class="line">			<span class="keyword">return</span> AspectJAfterReturningAdvice.class;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (AFTER_THROWING_ELEMENT.equals(elementName)) &#123;</span><br><span class="line">			<span class="keyword">return</span> AspectJAfterThrowingAdvice.class;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (AROUND.equals(elementName)) &#123;</span><br><span class="line">			<span class="keyword">return</span> AspectJAroundAdvice.class;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unknown advice kind ["</span> + elementName + <span class="string">"]."</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到五个不同类型的节点都有自己对应的AbstractAdvise实现类。</p>
<p>2.注入一系列的属性</p>
<p>3.注入对应的Bean的构造方法参数。</p>
<p>我们这里主要看注入第二个参数的过程。</p>
<p>我们截取这一段来分析一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Object pointcut = parsePointcutProperty(adviceElement, parserContext);</span><br><span class="line">	<span class="keyword">if</span> (pointcut <span class="keyword">instanceof</span> BeanDefinition) &#123;</span><br><span class="line">		cav.addIndexedArgumentValue(POINTCUT_INDEX, pointcut);</span><br><span class="line">		beanDefinitions.add((BeanDefinition) pointcut);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pointcut <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">		RuntimeBeanReference pointcutRef = <span class="keyword">new</span> RuntimeBeanReference((String) pointcut);</span><br><span class="line">		cav.addIndexedArgumentValue(POINTCUT_INDEX, pointcutRef);</span><br><span class="line">		beanReferences.add(pointcutRef);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>1.先调用parsePointcutProperty得到我们要注入的pointcut。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">parsePointcutProperty</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (element.hasAttribute(POINTCUT) &amp;&amp; element.hasAttribute(POINTCUT_REF)) &#123;</span><br><span class="line">		parserContext.getReaderContext().error(</span><br><span class="line">				<span class="string">"Cannot define both 'pointcut' and 'pointcut-ref' on &lt;advisor&gt; tag."</span>,</span><br><span class="line">				element, <span class="keyword">this</span>.parseState.snapshot());</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (element.hasAttribute(POINTCUT)) &#123;</span><br><span class="line">		<span class="comment">// Create a pointcut for the anonymous pc and register it.</span></span><br><span class="line">		String expression = element.getAttribute(POINTCUT);</span><br><span class="line">		AbstractBeanDefinition pointcutDefinition = createPointcutDefinition(expression);</span><br><span class="line">		pointcutDefinition.setSource(parserContext.extractSource(element));</span><br><span class="line">		<span class="keyword">return</span> pointcutDefinition;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (element.hasAttribute(POINTCUT_REF)) &#123;</span><br><span class="line">		String pointcutRef = element.getAttribute(POINTCUT_REF);</span><br><span class="line">		<span class="keyword">if</span> (!StringUtils.hasText(pointcutRef)) &#123;</span><br><span class="line">			parserContext.getReaderContext().error(</span><br><span class="line">					<span class="string">"'pointcut-ref' attribute contains empty value."</span>, element, <span class="keyword">this</span>.parseState.snapshot());</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> pointcutRef;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		parserContext.getReaderContext().error(</span><br><span class="line">				<span class="string">"Must define one of 'pointcut' or 'pointcut-ref' on &lt;advisor&gt; tag."</span>,</span><br><span class="line">				element, <span class="keyword">this</span>.parseState.snapshot());</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法有点长，但是很好理解：</p>
<p>1.如果当前节点没有pointcut属性和pointcut-ref属性，那么直接返回null。</p>
<p>2.如果当前节点有pointcut属性，则调用createPointcutDefinition创建一个Bean定义，里面对应的bean是一个AspectJExpressionPointcut实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> AbstractBeanDefinition <span class="title">createPointcutDefinition</span><span class="params">(String expression)</span> </span>&#123;</span><br><span class="line">	RootBeanDefinition beanDefinition = <span class="keyword">new</span> RootBeanDefinition(AspectJExpressionPointcut.class);</span><br><span class="line">	beanDefinition.setScope(BeanDefinition.SCOPE_PROTOTYPE);</span><br><span class="line">	beanDefinition.setSynthetic(<span class="keyword">true</span>);</span><br><span class="line">	beanDefinition.getPropertyValues().add(EXPRESSION, expression);</span><br><span class="line">	<span class="keyword">return</span> beanDefinition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到我们把pointcut属性对应的值注入到了AspectJExpressionPointcut的expresssion属性中。</p>
<p>而且要注意这个Bean是原型bean，而我们Spring默认的bean都是单例的。所以当节点中的属性是pointcut时，我们是要给出expression表达式，而对应的Bean是Spring默认给出的。</p>
<p>3.如果节点有pointcut-ref属性，我们直接返回属性值，也就是一个String对象。</p>
<p>2.当得到要注入的pointcut后，根据他的类型来选择不同的操作，如果是pointcut属性，即注入的是一个Bean定义时，我们除了要做必要的注入到构造方法里之外，我们需要把他注入到beanDefinitions这个Bean定义的list中。如果是pointcut-ref,即是String类型，那么额外的操作则变成了把他注入到beanReferences这个BeanReference类型的List，BeanReference的作用这里先稍微说一句，因为有些Bean是需要依赖于其他bean的，所以就需要BeanReference，而具体什么时候起作用以及怎么起作用，我们下次再细说。</p>
<p>我们回到parseAspect方法，我们现在可以吧目光投向parseAdvice后的代码。</p>
<p>我们会将得到的advisorDefinition加入到beanDefinitions。</p>
<p>然后新建一个AspectComponentDefinition实例，里面注入了beanDefinitions和beanReferences。</p>
<p>最后，我们需要对aspect下面的pointcut子节点进行处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Element&gt; pointcuts = DomUtils.getChildElementsByTagName(aspectElement, POINTCUT);</span><br><span class="line">	<span class="keyword">for</span> (Element pointcutElement : pointcuts) &#123;</span><br><span class="line">		parsePointcut(pointcutElement, parserContext);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	parserContext.popAndRegisterContainingComponent();</span><br></pre></td></tr></table></figure>
<p>先得到所有的poincut节点，然后调用parsePointcut注册pointcut的信息，最后会向Spring容器注册一个PointcutComponentDefinition组件。</p>
<p>最后将所有aspect相关信息组成的aspectComponentDefinition注入到Spring容器中。</p>
<p>然后回到parse方法，注入CompositeComponentDefinition到Spring容器中。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2018/01/21/--Spring源码之AOP/" data-id="cjcouzso30000n8bzgj3axs8k" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-session" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/17/session/" class="article-date">
  <time datetime="2018-01-17T14:07:23.732Z" itemprop="datePublished">2018-01-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java-WEB/">Java WEB</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/17/session/">Cookie和Session</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>###前言</p>
<p>最近在看Tomcat的源码，然后想着就把Servlet的相关知识都复习一下吧。自然就需要关注Cookie和Session了。</p>
<p>###Cookie</p>
<p>Response 操作Cookie的方法就一个 addCookie()<br>通常我们添加Cookie的操作如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cookie cookie=<span class="keyword">new</span> Cookie(<span class="string">"name"</span>,<span class="string">"kobe"</span>);</span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure></p>
<p>通常我们这样操作只设置了Cookie的name value<br>但是Cookie还是有很多其他的属性的。<br>name  String   该Cookie的名称。Cookie一旦创建，名称便不可更改<br>value Object   该Cookie的值。如果值为Unicode字符，需要为字符编码。如果值为二进制数据，则需要使用BASE64编码<br>maxAge int     该Cookie失效的时间，单位秒。如果为正数，则该Cookie在maxAge秒之后失效。如果为负数，该Cookie为临时Cookie，关闭浏览器即失效，浏览器也不会以任何形式保存该Cookie。如果为0，表示删除该Cookie。默认为–1<br>secure boolean 该Cookie是否仅被使用安全协议传输。安全协议。安全协议有HTTPS，SSL等，在网络上传输数据之前先将数据加密。默认为false<br><strong>path</strong>  String 该Cookie的使用路径。如果设置为“/sessionWeb/”，则只有contextPath为“/sessionWeb”的程序可以访问该Cookie。如果设置为“/”，则本域名下contextPath都可以访问该Cookie。注意最后一个字符必须为“/”<br>那我们默认没有显式指定的时候是什么呢？<br>这个就跟我们在哪里添加Cookie有关。<br>localhost:8080/mywebapp/testcookie/test1.jsp<br>比如我在/mywebapp/testcookie/test1.jsp中添加的Cookie，没有显示指定path<br>那么这里的path默认就是/mywebapp/testcookie/<br>即默认情况下，只有与创建 cookie 的页面在同一个目录或子目录下的网页才可以访问，这个是因为安全方面的考虑，造成不是所有页面都可以随意访问其他页面创建的 cookie。<br><strong>domain</strong> String<br>可以访问该Cookie的域名。如果设置为“.google.com”，则所有以“google.com”结尾的域名都可以访问该Cookie。注意第一个字符必须为“.”<br>那么如果没有显示的设置呢？<br>如网址为www.jb51.net/test/test.aspx，那么domain默认为www.jb51.net。<br>而跨域访问，如域A为t1.test.com，域B为t2.test.com，那么在域A生产一个令域A和域B都能访问的cookie就要将该cookie的domain设置为.test.com；如果要在域A生产一个令域A不能访问而域B能访问的cookie就要将该cookie的domain设置为t2.test.com。</p>
<p>comment  String<br>该Cookie的用处说明。浏览器显示Cookie信息的时候显示该说明<br>version int 该Cookie使用的版本号。0表示遵循Netscape的Cookie规范，1表示遵循W3C的RFC<br>2109规范</p>
<p>cookie有大小限制 4kb<br>同个网站可以创建多个 cookie ，而多个 cookie 可以存放在同一个cookie 文件中。</p>
<p>介绍了这么多关于Cookie的知识，但是还没有介绍Cookie的应用，我们需要很好的掌握基础知识，但是同样的，我们更需要知道怎样去应用这些知识，学以致用才是我们追求的。</p>
<p>很明显，当没有Cookie的时候，如果我们登陆一个网站，而网站的每一个页面都需要用户名密码验证的时候，我们需要在每次提交访问页面的请求的时候都需要<strong>显式的带上用户名和密码等消息</strong>。（也就是说用户名和密码必须是请求参数），这显然是很糟糕的体验，所以Cookie就出现了，他解决了这一问题。<br>有了Cookie之后可以这么做呢，第一次登陆页面的请求过来，请求参数里面必然是有用户名和密码的。那么我们在服务器端(以Java语言 web容器:Tomcat 为例),将用户名和密码的信息添加到Cookie当中，使用response.addCookie添加。然后将信息存入数据库中。<br>你观看Tomcat的源码：org.apache.catalina.connector.Response就可以看到最后Cookie的信息会存到Set-Cookie这个响应头字段中。<br>然后Cookie信息就会到浏览器中了，这个时候浏览器会根据maxAge即Cookie的有效时间来判断是否需要存放在本地磁盘中，如果maxAge没有在服务器端进行显示的设置，即默认的设置为-1,那么这个Cookie就会随着浏览器窗口的关闭而失效。而如果是一个d大于0的maxAge，就会将其存放到本地磁盘中。（不同的浏览器的存放位置不同），而不同domain或者path的Cookie都会存放在不同的Cookie文件中，而两者都相同的Cookie会存在同一文件中。<br>那么这里很明显我们需要设置一个显式的maxAge，单位为秒，如果希望密码保存一星期则<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cookie.setMaxAge(<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>*<span class="number">7</span>);</span><br></pre></td></tr></table></figure></p>
<p>这时，当我们第二次访问该网站的页面的时候，在我们的请求头里就会出现Cookie的相关信息。<br>会在请求头的Cookie字段中。（因为domain和path都符合，所以我们存在本地磁盘的用户名和密码cookie会出现在请求头中），这时候我们在服务器端再需要验证登录是否合法的时候，就不需要把用户名和密码显示的拿过来了，因为已经在Cookie中带过来了，那么我们就可以在服务器端中找到相应的Cookie信息，然后再去与数据库中的信息比较，看是否有效。这样就避免了每次都要输入用户名和密码。</p>
<p>但是很明显，如果你不是一个开发小白，你就知道上述的设计存在很多问题。<br>1.直接把密码放入到Cookie中也太不严谨了把，cookie信息可是可以直接用js获取的，是没有任何安全保障的。<br>2.是否真的需要每次去把cookie中的信息放到数据库（特指传统的关系型数据库）中去比较。</p>
<p>对于第一点，也就是安全性，相对于第二点的性能，这是我们急需用解决的。<br>解决方法：可能你一开始就会想到，之前不是说了cookie有一个属性叫做secure，你在设置cookie的时候把他设置成true不就好了么，这样他就只能在HTTPS,SSL等安全协议下传输了。但是他也只能保证 cookie 与服务器之间的数据传输过程加密，而保存在本地的 cookie文件并不加密。所以如果想让本地cookie也加密，就得自己加密数据。<br>所以，我们不仅用使用安全传输协议，还需要将cookie信息进行加密。</p>
<p>我们进行如下改进，第一次请求时，我们依然会把用户名和密码存入数据库中，或者查询，看是否已经有这个用户，这是跟数据库的第一次交互。<br>然后我们使用一个密钥将用户名加密，将加密后的密文和用户名分别放入相应的cookie中。而在之后的请求中，服务器端会将用户名再次用密钥进行加密，然后与cookie中的密文进行比较。这样就避免了多次访问数据库以及暴露密码的问题。</p>
<p>###Session<br>在每个context对象，即每个web app都具有一个独立的manager对象。通过server.xml可以配置定制化的manager，也可以不配置。不管怎样，在生成context对象时，都会生成一个manager对象。缺省的是StandardManager类。相应的代码在ContextRuleSet的addRuleInstances方法中。涉及到Digester解析XML的知识,这方面的知识要赶紧啃了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">digester.addObjectCreate(prefix + <span class="string">"Context/Manager"</span>,</span><br><span class="line">                         <span class="string">"org.apache.catalina.session.StandardManager"</span>,</span><br><span class="line">                         <span class="string">"className"</span>);</span><br><span class="line">digester.addSetProperties(prefix + <span class="string">"Context/Manager"</span>);</span><br><span class="line">digester.addSetNext(prefix + <span class="string">"Context/Manager"</span>,</span><br><span class="line">                    <span class="string">"setManager"</span>,</span><br><span class="line">                    <span class="string">"org.apache.catalina.Manager"</span>);</span><br><span class="line"></span><br><span class="line">digester.addObjectCreate(prefix + <span class="string">"Context/Manager/Store"</span>,</span><br><span class="line">                         <span class="keyword">null</span>, <span class="comment">// MUST be specified in the element</span></span><br><span class="line">                         <span class="string">"className"</span>);</span><br><span class="line">digester.addSetProperties(prefix + <span class="string">"Context/Manager/Store"</span>);</span><br><span class="line">digester.addSetNext(prefix + <span class="string">"Context/Manager/Store"</span>,</span><br><span class="line">                    <span class="string">"setStore"</span>,</span><br><span class="line">                    <span class="string">"org.apache.catalina.Store"</span>);</span><br><span class="line"></span><br><span class="line">digester.addObjectCreate(prefix + <span class="string">"Context/Manager/SessionIdGenerator"</span>,</span><br><span class="line">                         <span class="string">"org.apache.catalina.util.StandardSessionIdGenerator"</span>,</span><br><span class="line">                         <span class="string">"className"</span>);</span><br><span class="line">digester.addSetProperties(prefix + <span class="string">"Context/Manager/SessionIdGenerator"</span>);</span><br><span class="line">digester.addSetNext(prefix + <span class="string">"Context/Manager/SessionIdGenerator"</span>,</span><br><span class="line">                    <span class="string">"setSessionIdGenerator"</span>,</span><br><span class="line">                    <span class="string">"org.apache.catalina.SessionIdGenerator"</span>);</span><br></pre></td></tr></table></figure></p>
<p>第一次请求过来是不会带有Cookie的，也就不会有jsessionId出现。Session其实也是一种Cookie。请求过来后，服务器端就会为这个请求的客户机加上Cookie作为标识了。</p>
<p>browser发送Http request；<br>tomcat内核Http11Processor会从HTTP request中解析出“jsessionid”(具体的解析过程为先从request的URL中解析，这是为了有的浏览器把cookie功能禁止后，将URL重写考虑的，如果解析不出来，再从cookie中解析相应的jsessionid)，解析完后封装成一个request对象(当然还有其他的http header)；<br>servlet中获取session，其过程是根据刚才解析得到的jsessionid(如果有的话)，从session池(session maps)中获取相应的session对象；这个地方有个逻辑，就是如果jsessionid为空的话(或者没有其对应的session对象，或者有session对象，但此对象已经过期超时)，可以选择创建一个session，或者不创建；<br>如果创建新session，则将session放入session池中，同时将与其相对应的jsessionid写入cookie通过Http response header的方式发送给browser，然后重复第一步。</p>
<p>以上是session的获取及创建过程。在servlet中获取session，通常是调用request的getSession方法。这个方法需要传入一个boolean参数，这个参数就是实现刚才说的，当jsessionid为空或从session池中获取不到相应的session对象时，选择创建一个新的session还是不创建。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> Session <span class="title">doGetSession</span><span class="params">(<span class="keyword">boolean</span> create)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// There cannot be a session if no context has been assigned yet</span></span><br><span class="line">     Context context = getContext();</span><br><span class="line">     <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> (<span class="keyword">null</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//如果有session存在但是无效</span></span><br><span class="line">     <span class="comment">// Return the current session if it exists and is valid</span></span><br><span class="line">     <span class="keyword">if</span> ((session != <span class="keyword">null</span>) &amp;&amp; !session.isValid()) &#123;</span><br><span class="line">         session = <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//如果有效，直接返回</span></span><br><span class="line">     <span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> (session);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//       获取所在context的manager对象   </span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// Return the requested session if it exists and is valid</span></span><br><span class="line">     Manager manager = context.getManager();</span><br><span class="line">     <span class="keyword">if</span> (manager == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;        <span class="comment">// Sessions are not supported</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//requestedSessionId就是从Http request中解析出来的  </span></span><br><span class="line">     <span class="keyword">if</span> (requestedSessionId != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             session = manager.findSession(requestedSessionId);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">             session = <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//如果存在但无效</span></span><br><span class="line">         <span class="keyword">if</span> ((session != <span class="keyword">null</span>) &amp;&amp; !session.isValid()) &#123;</span><br><span class="line">             session = <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//如果有效，返回</span></span><br><span class="line">         <span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">         	<span class="comment">//session对象有效，记录此次访问时间  </span></span><br><span class="line"></span><br><span class="line">             session.access();</span><br><span class="line">             <span class="keyword">return</span> (session);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 如果参数是false，则不创建新session对象了，直接退出了  </span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// Create a new session if requested and the response is not committed</span></span><br><span class="line">     <span class="keyword">if</span> (!create) &#123;</span><br><span class="line">         <span class="keyword">return</span> (<span class="keyword">null</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> ((response != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">         context.getServletContext().getEffectiveSessionTrackingModes().</span><br><span class="line">                 contains(SessionTrackingMode.COOKIE) &amp;&amp;</span><br><span class="line">         response.getResponse().isCommitted()) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException</span><br><span class="line">           (sm.getString(<span class="string">"coyoteRequest.sessionCreateCommitted"</span>));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//在非常有限的情况下重用客户端提供的会话id。</span></span><br><span class="line">     <span class="comment">// Re-use session IDs provided by the client in very limited</span></span><br><span class="line">     <span class="comment">// circumstances.</span></span><br><span class="line">     String sessionId = getRequestedSessionId();</span><br><span class="line">     <span class="keyword">if</span> (requestedSessionSSL) &#123;</span><br><span class="line">     	<span class="comment">//如果会话ID是从SSL握手获得的</span></span><br><span class="line">         <span class="comment">// If the session ID has been obtained from the SSL handshake then</span></span><br><span class="line">         <span class="comment">// use it.</span></span><br><span class="line">     &#125; </span><br><span class="line">     <span class="comment">//如果路径为/ ，且sessionId是从url中获得的，即url重写获得</span></span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="string">"/"</span>.equals(context.getSessionCookiePath())</span><br><span class="line">             &amp;&amp; isRequestedSessionIdFromCookie())) &#123;</span><br><span class="line">             <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这是常见的(ish)用例:使用相同的会话ID。</span></span><br><span class="line"><span class="comment">同一主机上的多个web应用程序。通常这是</span></span><br><span class="line"><span class="comment">用于Portlet实现。只有在session会话通过cookie跟踪时才有效。</span></span><br><span class="line"><span class="comment">。cookie必须有一条“/”的路径。</span></span><br><span class="line"><span class="comment">否则不会提供给所有web应用程序的请求。</span></span><br><span class="line"><span class="comment">客户提供的任何会话ID都应该是一个会话。</span></span><br><span class="line"><span class="comment">已经存在于主机的某个地方。只有当上下文</span></span><br><span class="line"><span class="comment">被标识为要确认的时候才会检查。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">         <span class="comment">/* This is the common(ish) use case: using the same session ID with</span></span><br><span class="line"><span class="comment">          * multiple web applications on the same host. Typically this is</span></span><br><span class="line"><span class="comment">          * used by Portlet implementations. It only works if sessions are</span></span><br><span class="line"><span class="comment">          * tracked via cookies. The cookie must have a path of "/" else it</span></span><br><span class="line"><span class="comment">          * won't be provided for requests to all web applications.</span></span><br><span class="line"><span class="comment">          *</span></span><br><span class="line"><span class="comment">          * Any session ID provided by the client should be for a session</span></span><br><span class="line"><span class="comment">          * that already exists somewhere on the host. Check if the context</span></span><br><span class="line"><span class="comment">          * is configured for this to be confirmed.</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         <span class="keyword">if</span> (context.getValidateClientProvidedNewSessionId()) &#123;</span><br><span class="line">             <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">             <span class="keyword">for</span> (Container container : getHost().findChildren()) &#123;</span><br><span class="line">                 Manager m = ((Context) container).getManager();</span><br><span class="line">                 <span class="keyword">if</span> (m != <span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="keyword">try</span> &#123;</span><br><span class="line">                         <span class="keyword">if</span> (m.findSession(sessionId) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                             found = <span class="keyword">true</span>;</span><br><span class="line">                             <span class="keyword">break</span>;</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                         <span class="comment">// Ignore. Problems with this manager will be</span></span><br><span class="line">                         <span class="comment">// handled elsewhere.</span></span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">                 sessionId = <span class="keyword">null</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         sessionId = <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//创建一个session</span></span><br><span class="line">     session = manager.createSession(sessionId);</span><br><span class="line">     <span class="comment">// 将新session的jsessionid写入cookie，传给browser ，佐证了session也是cookie</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="comment">// Creating a new session cookie based on that session</span></span><br><span class="line">     <span class="keyword">if</span> ((session != <span class="keyword">null</span>) &amp;&amp; (getContext() != <span class="keyword">null</span>)</span><br><span class="line">            &amp;&amp; getContext().getServletContext().</span><br><span class="line">                    getEffectiveSessionTrackingModes().contains(</span><br><span class="line">                            SessionTrackingMode.COOKIE)) &#123;</span><br><span class="line">         Cookie cookie =</span><br><span class="line">             ApplicationSessionCookieConfig.createSessionCookie(</span><br><span class="line">                     context, session.getIdInternal(), isSecure());</span><br><span class="line"></span><br><span class="line">         response.addSessionCookieInternal(cookie);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (session == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//记录访问时间</span></span><br><span class="line">     session.access();</span><br><span class="line">     <span class="keyword">return</span> session;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session = manager.createSession(sessionId);</span><br></pre></td></tr></table></figure>
<p> StandardManager父类ManagerBase中实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Session <span class="title">createSession</span><span class="params">(String sessionId)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> ((maxActiveSessions &gt;= <span class="number">0</span>) &amp;&amp;</span><br><span class="line">              (getActiveSessions() &gt;= maxActiveSessions)) &#123;</span><br><span class="line">          rejectedSessions++;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> TooManyActiveSessionsException(</span><br><span class="line">                  sm.getString(<span class="string">"managerBase.createSession.ise"</span>),</span><br><span class="line">                  maxActiveSessions);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// Recycle or create a Session instance</span></span><br><span class="line">      Session session = createEmptySession();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Initialize the properties of the new session and return it</span></span><br><span class="line">      session.setNew(<span class="keyword">true</span>);</span><br><span class="line">      session.setValid(<span class="keyword">true</span>);</span><br><span class="line">      session.setCreationTime(System.currentTimeMillis());</span><br><span class="line">      session.setMaxInactiveInterval(((Context) getContainer()).getSessionTimeout() * <span class="number">60</span>);</span><br><span class="line">      String id = sessionId;</span><br><span class="line">      <span class="keyword">if</span> (id == <span class="keyword">null</span>) &#123;</span><br><span class="line">      	<span class="comment">//会去重</span></span><br><span class="line">          id = generateSessionId();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//在这里将session放入sessions中</span></span><br><span class="line">      session.setId(id);</span><br><span class="line">      sessionCounter++;</span><br><span class="line"></span><br><span class="line">      SessionTiming timing = <span class="keyword">new</span> SessionTiming(session.getCreationTime(), <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">synchronized</span> (sessionCreationTiming) &#123;</span><br><span class="line">          sessionCreationTiming.add(timing);</span><br><span class="line">          sessionCreationTiming.poll();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> (session);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>生产id的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">generateSessionId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String result = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Not thread-safe but if one of multiple increments is lost</span></span><br><span class="line">            <span class="comment">// that is not a big deal since the fact that there was any</span></span><br><span class="line">            <span class="comment">// duplicate is a much bigger issue.</span></span><br><span class="line">            duplicates++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result = sessionIdGenerator.generateSessionId();</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">while</span> (sessions.containsKey(result));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用算法生成id,然后会在sessions这个map中查看是否有重复，起到去重的效果。</p>
<p>###URL地址重写<br>URL地址重写是对客户端不支持Cookie的解决方案。URL地址重写的原理是将该用户Session的id信息重写到URL地址中。服务器能够解析重写后的URL获取Session的id。这样即使客户端不支持Cookie，也可以使用Session来记录用户状态。HttpServletResponse类提供了encodeURL(Stringurl)实现URL地址重写</p>
<p>该方法会自动判断客户端是否支持Cookie。如果客户端支持Cookie，会将URL原封不动地输出来。如果客户端不支持Cookie，则会将用户Session的id重写到URL中。<br>增添的jsessionid字符串既不会影响请求的文件名，也不会影响提交的地址栏参数。用户单击这个链接的时候会把Session的id通过URL提交到服务器上，服务器通过解析URL地址获得Session的id。<br>对于WAP程序，由于大部分的手机浏览器都不支持Cookie，WAP程序都会采用URL地址重写来跟踪用户会话。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">response.encodeURL(<span class="string">"index.jsp?c=1&amp;wd=Java"</span>);</span><br><span class="line"><span class="comment">//用于重定向</span></span><br><span class="line">response.sendRedirect(response.encodeRedirectURL(“administrator.jsp”));</span><br></pre></td></tr></table></figure>
<p><strong>encodeURL</strong>       org.apache.catalina.connector.Response(真正我们用户能看到的HttpServletResponse实现类是他的封装类ResponseFacade)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">encodeURL</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       String absolute;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           absolute = toAbsolute(url);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IllegalArgumentException iae) &#123;</span><br><span class="line">           <span class="comment">// Relative URL</span></span><br><span class="line">           <span class="keyword">return</span> url;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (isEncodeable(absolute)) &#123;</span><br><span class="line">           <span class="comment">// W3c spec clearly said</span></span><br><span class="line">           <span class="keyword">if</span> (url.equalsIgnoreCase(<span class="string">""</span>)) &#123;</span><br><span class="line">               url = absolute;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (url.equals(absolute) &amp;&amp; !hasPath(url)) &#123;</span><br><span class="line">               url += <span class="string">'/'</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> (toEncoded(url, request.getSessionInternal().getIdInternal()));</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> (url);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>关键在toEncoded<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">protected</span> String <span class="title">toEncoded</span><span class="params">(String url, String sessionId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((url == <span class="keyword">null</span>) || (sessionId == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (url);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String path = url;</span><br><span class="line">        String query = <span class="string">""</span>;</span><br><span class="line">        String anchor = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> question = url.indexOf(<span class="string">'?'</span>);</span><br><span class="line">        <span class="keyword">if</span> (question &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            path = url.substring(<span class="number">0</span>, question);</span><br><span class="line">            query = url.substring(question);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pound = path.indexOf(<span class="string">'#'</span>);</span><br><span class="line">        <span class="keyword">if</span> (pound &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            anchor = path.substring(pound);</span><br><span class="line">            path = path.substring(<span class="number">0</span>, pound);</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(path);</span><br><span class="line">        <span class="keyword">if</span>( sb.length() &gt; <span class="number">0</span> ) &#123; <span class="comment">// jsessionid can't be first.</span></span><br><span class="line">            sb.append(<span class="string">";"</span>);</span><br><span class="line">            sb.append(SessionConfig.getSessionUriParamName(</span><br><span class="line">                    request.getContext()));</span><br><span class="line">            sb.append(<span class="string">"="</span>);</span><br><span class="line">            sb.append(sessionId);</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(anchor);</span><br><span class="line">        sb.append(query);</span><br><span class="line">        <span class="keyword">return</span> (sb.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SessionConfig.getSessionUriParamName(</span><br><span class="line">request.getContext()));</span><br></pre></td></tr></table></figure>
<p>  调用了这个方法来获取jsessionId<br>  具体获取方法有兴趣的可以深入研究。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2018/01/17/session/" data-id="cjcj5a2ja0000lobzn8o9nly1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-对classpath的理解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/14/对classpath的理解/" class="article-date">
  <time datetime="2018-01-14T13:50:41.923Z" itemprop="datePublished">2018-01-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaWEB/">JavaWEB</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/14/对classpath的理解/">对classpath的理解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在看一个项目，看到他在web.xml配置文件中使用了classpath*:后跟配置文件通配符。</p>
<p>而我一般都是用的classpath:,这时候突然想起我之前有特意查阅过两种方式的区别，不过很遗憾的是我已经忘了，所以这次打算记录下来，就算以后再忘了也后及时查阅。</p>
<h3 id="ResourceLoader"><a href="#ResourceLoader" class="headerlink" title="ResourceLoader"></a>ResourceLoader</h3><p>我们废话不多说，直接看spring对这两种方式修饰配置文件位置的方法是如何加载相应配置文件。</p>
<p>回到AbstractApplicationContext的refresh方法，我们看获取Beanfactory的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">		ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	refreshBeanFactory();</span><br><span class="line">	ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(<span class="string">"Bean factory for "</span> + getDisplayName() + <span class="string">": "</span> + beanFactory);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入AbstractRefreshableApplicationContext的refreshBeanFactory</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">			destroyBeans();</span><br><span class="line">			closeBeanFactory();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">			beanFactory.setSerializationId(getId());</span><br><span class="line">			customizeBeanFactory(beanFactory);</span><br><span class="line">			loadBeanDefinitions(beanFactory);</span><br><span class="line">			<span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">				<span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"I/O error parsing bean definition source for "</span> + getDisplayName(), ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>其中有一个loadBeanDefinitions(beanFactory);就是在这个方法里，我们<strong>读取配置文件并注册Bean</strong></p>
<p>XmlWebApplicationContext(默认是该实例)的loadBeanDefinitions</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">		<span class="comment">// Create a new XmlBeanDefinitionReader for the given BeanFactory.</span></span><br><span class="line">		XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Configure the bean definition reader with this context's</span></span><br><span class="line">		<span class="comment">// resource loading environment.</span></span><br><span class="line">		beanDefinitionReader.setEnvironment(getEnvironment());</span><br><span class="line">		beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">		beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Allow a subclass to provide custom initialization of the reader,</span></span><br><span class="line">		<span class="comment">// then proceed with actually loading the bean definitions.</span></span><br><span class="line">		initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">		loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到有为beanDefinitionReader设置ResourceLoader</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<p>这里我们将XmlWebApplicationContext实例设置为了ResourceLoader，因为XmlWebApplicationContext也是一个实现了ResourceLoader的类的子类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlWebApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractRefreshableWebApplicationContext</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRefreshableWebApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractRefreshableConfigApplicationContext</span></span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">ConfigurableWebApplicationContext</span>, <span class="title">ThemeSource</span> </span>&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRefreshableConfigApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractRefreshableApplicationContext</span></span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">BeanNameAware</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRefreshableApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractApplicationContext</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">extends</span> <span class="title">DefaultResourceLoader</span></span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">ConfigurableApplicationContext</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultResourceLoader</span> <span class="keyword">implements</span> <span class="title">ResourceLoader</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<p>接着看        loadBeanDefinitions(beanDefinitionReader);</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	String[] configLocations = getConfigLocations();</span><br><span class="line">	<span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (String configLocation : configLocations) &#123;</span><br><span class="line">			reader.loadBeanDefinitions(configLocation);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>org.springframework.beans.factory.xml.XmlBeanDefinitionReader父类AbstractBeanDefinitionReader</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> loadBeanDefinitions(location, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location, Set&lt;Resource&gt; actualResources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">	ResourceLoader resourceLoader = getResourceLoader();</span><br><span class="line">	<span class="keyword">if</span> (resourceLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">				<span class="string">"Cannot import bean definitions from location ["</span> + location + <span class="string">"]: no ResourceLoader available"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (resourceLoader <span class="keyword">instanceof</span> ResourcePatternResolver) &#123;</span><br><span class="line">		<span class="comment">// Resource pattern matching available.</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);</span><br><span class="line">			<span class="keyword">int</span> loadCount = loadBeanDefinitions(resources);</span><br><span class="line">			<span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">					actualResources.add(resource);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">"Loaded "</span> + loadCount + <span class="string">" bean definitions from location pattern ["</span> + location + <span class="string">"]"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> loadCount;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">					<span class="string">"Could not resolve bean definition resource pattern ["</span> + location + <span class="string">"]"</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Can only load single resources by absolute URL.</span></span><br><span class="line">		Resource resource = resourceLoader.getResource(location);</span><br><span class="line">		<span class="keyword">int</span> loadCount = loadBeanDefinitions(resource);</span><br><span class="line">		<span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">			actualResources.add(resource);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">"Loaded "</span> + loadCount + <span class="string">" bean definitions from location ["</span> + location + <span class="string">"]"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> loadCount;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        ResourceLoader resourceLoader = getResourceLoader();</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">	public ResourceLoader getResourceLoader() &#123;</span><br><span class="line">		return this.resourceLoader;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>resourceLoader就是XmlWebApplicationContext实例</p>
<p>主要关注    Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);</p>
<p>XmlWebApplicationContext没有直接实现这个方法，在祖先类AbstractApplicationContext中实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Resource[] getResources(String locationPattern) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.resourcePatternResolver.getResources(locationPattern);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们真正调用的是resourcePatternResolver的getResources方法，那他到底是哪个实例呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.resourcePatternResolver = getResourcePatternResolver();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> ResourcePatternResolver <span class="title">getResourcePatternResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> PathMatchingResourcePatternResolver(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>org.springframework.core.io.support.PathMatchingResourcePatternResolver的getResources</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Resource[] getResources(String locationPattern) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">	Assert.notNull(locationPattern, <span class="string">"Location pattern must not be null"</span>);</span><br><span class="line">	<span class="keyword">if</span> (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) &#123;</span><br><span class="line">		<span class="comment">// a class path resource (multiple resources for same name possible)</span></span><br><span class="line">		<span class="keyword">if</span> (getPathMatcher().isPattern(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) &#123;</span><br><span class="line">			<span class="comment">// a class path resource pattern</span></span><br><span class="line">			<span class="keyword">return</span> findPathMatchingResources(locationPattern);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// all class path resources with the given name</span></span><br><span class="line">			<span class="keyword">return</span> findAllClassPathResources(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Only look for a pattern after a prefix here</span></span><br><span class="line">		<span class="comment">// (to not get fooled by a pattern symbol in a strange prefix).</span></span><br><span class="line">		<span class="keyword">int</span> prefixEnd = locationPattern.indexOf(<span class="string">":"</span>) + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) &#123;</span><br><span class="line">			<span class="comment">// a file pattern</span></span><br><span class="line">			<span class="keyword">return</span> findPathMatchingResources(locationPattern);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// a single resource with the given name</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Resource[] &#123;getResourceLoader().getResource(locationPattern)&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>终于来到我们要分析的方法了</strong></p>
<p>再说一下，这个方法是位于org.springframework.core.io.support.PathMatchingResourcePatternResolver的getResources。</p>
<p>我们初看一下这个方法，可以看到大概分三个分支来处理资源的加载。</p>
<p>而如果按照classpath和classpath*来区分的话，很显然就是两种。</p>
<p>当这种两种方式的配置文件路径都是统配符的时候调用的是同一个方法，当然具体方法里的流程还是不一样的，当是指定路径的时候都有各自的处理方法，我们先就从无通配符先来分析吧。</p>
<ul>
<li><p><strong>classpath*</strong></p>
<p>findAllClassPathResources</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Resource[] findAllClassPathResources(String location) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">	String path = location;</span><br><span class="line">	<span class="keyword">if</span> (path.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">		path = path.substring(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	Set&lt;Resource&gt; result = doFindAllClassPathResources(path);</span><br><span class="line">	<span class="keyword">return</span> result.toArray(<span class="keyword">new</span> Resource[result.size()]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果location以/打头，把/去掉，然后调用</p>
<p>doFindAllClassPathResources得到我们想要的资源</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Set&lt;Resource&gt; <span class="title">doFindAllClassPathResources</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		Set&lt;Resource&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;Resource&gt;(<span class="number">16</span>);</span><br><span class="line">		ClassLoader cl = getClassLoader();</span><br><span class="line">		Enumeration&lt;URL&gt; resourceUrls = (cl != <span class="keyword">null</span> ? cl.getResources(path) : ClassLoader.getSystemResources(path));</span><br><span class="line">		<span class="keyword">while</span> (resourceUrls.hasMoreElements()) &#123;</span><br><span class="line">			URL url = resourceUrls.nextElement();</span><br><span class="line">			result.add(convertClassLoaderURL(url));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="string">""</span>.equals(path)) &#123;</span><br><span class="line">			<span class="comment">// The above result is likely to be incomplete, i.e. only containing file system references.</span></span><br><span class="line">			<span class="comment">// We need to have pointers to each of the jar files on the classpath as well...</span></span><br><span class="line">			addAllClassLoaderJarRoots(cl, result);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>1.先定义一个size为16的LinkedHashSet集合，命名为result。</p>
<p>2、然后通过getClassLoader();方法得到一个ClassLaoder对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> getResourceLoader().getClassLoader();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ResourceLoader <span class="title">getResourceLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.resourceLoader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显是调用了resourceLoader属性的getClassLoader();方法，那么这个对象是什么呢，又是什么时候注入的呢，其实上面已经给出答案了。这个对象是一个XmlWebApplicationContext实例。最后你会发现调用的祖先类DefaultResourceLoader的getClassLoader方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">this</span>.classLoader != <span class="keyword">null</span> ? <span class="keyword">this</span>.classLoader : ClassUtils.getDefaultClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后你会发现ClassLoader对象是由ClassUtils.getDefaultClassLoader()得到的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getDefaultClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ClassLoader cl = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		cl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="comment">// Cannot access thread context ClassLoader - falling back...</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (cl == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// No thread context class loader -&gt; use class loader of this class.</span></span><br><span class="line">		cl = ClassUtils.class.getClassLoader();</span><br><span class="line">		<span class="keyword">if</span> (cl == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// getClassLoader() returning null indicates the bootstrap ClassLoader</span></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				cl = ClassLoader.getSystemClassLoader();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">				<span class="comment">// Cannot access system ClassLoader - oh well, maybe the caller can live with null...</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先取当前线程的ClassLoader实例，如果取不到，那就调用ClassUtils类的classLoader实例，如果还是没有，就调用ClassLoader.getSystemClassLoader();返回委托的系统类加载器。该加载器是新的 ClassLoader 实例的默认委托父类加载器，通常是用来启动应用程序的类加载器。 </p>
<p>在运行时启动序列的早期首先调用此方法，这时会创建系统类加载器并将其设置为调用 Thread 的上下文类加载器。<br>默认的系统类加载器是此类的一个与实现有关的实例。 </p>
<p>3.由上面得到的类加载器实例调用 cl.getResources(path)来ClassLoader (Java Platform SE 6)</p>
<p>查找所有给定名称的资源。资源是可以通过类代码以与代码基无关的方式访问的某些数据（图像、声音、文本等）。 </p>
<p>4.将得到的资源的URL封装成UrlResource放入到rusult集合中。</p>
<p>5.如果路径不为“”的话，此时就可以返回result了，但是如果一旦为“”的时候，那就需要调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addAllClassLoaderJarRoots(cl, result);</span><br></pre></td></tr></table></figure>
<p>对类路径中的每个jar文件加载。</p>
<p>​</p>
<p>​</p>
</li>
<li><p><strong>classpath</strong></p>
<p>其实更准确的说是非classpath*</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Resource <span class="title">getResource</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">	Assert.notNull(location, <span class="string">"Location must not be null"</span>);</span><br><span class="line">	<span class="keyword">if</span> (location.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> getResourceByPath(location);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (location.startsWith(CLASSPATH_URL_PREFIX)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// Try to parse the location as a URL...</span></span><br><span class="line">			URL url = <span class="keyword">new</span> URL(location);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (MalformedURLException ex) &#123;</span><br><span class="line">			<span class="comment">// No URL -&gt; resolve as resource path.</span></span><br><span class="line">			<span class="keyword">return</span> getResourceByPath(location);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.如果是以/打头的生成一个ClassPathContextResource类型对象，这个类是DefaultResourceLoader的内部类，继承了ClassPathResource类，实际上还是调用的是后者的方法，在构造方法中会去掉/。</p>
<p>2.如果是以classpath:打头的，生成一个ClassPathResource对象。</p>
<p>3,否则就尝试创建一个UrlResource对象，如果创建失败，生成一个ClassPathContextResource对象返回。</p>
</li>
<li><p>通配符findPathMatchingResources</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Resource <span class="title">getResource</span><span class="params">(String location)</span> </span>&#123;  </span><br><span class="line">    Assert.notNull(location, <span class="string">"Location must not be null"</span>);  </span><br><span class="line">    <span class="keyword">if</span> (location.startsWith(CLASSPATH_URL_PREFIX)) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="comment">// Try to parse the location as a URL...  </span></span><br><span class="line">            URL url = <span class="keyword">new</span> URL(location);  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> UrlResource(url);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">catch</span> (MalformedURLException ex) &#123;  </span><br><span class="line">            <span class="comment">// No URL -&gt; resolve as resource path.  </span></span><br><span class="line">            <span class="keyword">return</span> getResourceByPath(location);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">其实很简单，如果以classpath开头，则创建为一个ClassPathResource，否则则试图以URL的方式加载资源，创建一个UrlResource.</span><br><span class="line">路径包含通配符的</span><br><span class="line">             这种情况是最复杂的，涉及到层层递归，那我把加了注释的代码发出来大家看一下，其实主要的思想就是</span><br><span class="line"><span class="number">1</span>.先获取目录，加载目录里面的所有资源</span><br><span class="line"><span class="number">2</span>.在所有资源里面进行查找匹配，找出我们需要的资源</span><br><span class="line">[java] view plain copy</span><br><span class="line"><span class="keyword">protected</span> Resource[] findPathMatchingResources(String locationPattern) <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">        <span class="comment">//拿到能确定的目录，即拿到不包括通配符的能确定的路径  比如classpath*:/aaa/bbb/spring-*.xml 则返回classpath*:/aaa/bbb/                                     //如果是classpath*:/aaa/*/spring-*.xml，则返回 classpath*:/aaa/  </span></span><br><span class="line">        String rootDirPath = determineRootDir(locationPattern);  </span><br><span class="line">        <span class="comment">//得到spring-*.xml  </span></span><br><span class="line">        String subPattern = locationPattern.substring(rootDirPath.length());  </span><br><span class="line">        <span class="comment">//递归加载所有的根目录资源，要注意的是递归的时候又得考虑classpath,与classpath*的情况，而且还得考虑根路径中是否又包含通配符，参考上面那张流程图  </span></span><br><span class="line">        Resource[] rootDirResources = getResources(rootDirPath);  </span><br><span class="line">        Set&lt;Resource&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;Resource&gt;(<span class="number">16</span>);  </span><br><span class="line">        <span class="comment">//将根目录所有资源中所有匹配我们需要的资源(如spring-*)加载result中  </span></span><br><span class="line">        <span class="keyword">for</span> (Resource rootDirResource : rootDirResources) &#123;  </span><br><span class="line">            rootDirResource = resolveRootDirResource(rootDirResource);  </span><br><span class="line">            <span class="keyword">if</span> (isJarResource(rootDirResource)) &#123;  </span><br><span class="line">                result.addAll(doFindPathMatchingJarResources(rootDirResource, subPattern));  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rootDirResource.getURL().getProtocol().startsWith(ResourceUtils.URL_PROTOCOL_VFS)) &#123;  </span><br><span class="line">                result.addAll(VfsResourceMatchingDelegate.findMatchingResources(rootDirResource, subPattern, getPathMatcher()));  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span> &#123;  </span><br><span class="line">                result.addAll(doFindPathMatchingFileResources(rootDirResource, subPattern));  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </span><br><span class="line">            logger.debug(<span class="string">"Resolved location pattern ["</span> + locationPattern + <span class="string">"] to resources "</span> + result);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> result.toArray(<span class="keyword">new</span> Resource[result.size()]);  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>1.先获取目录，加载目录里面的所有资源</p>
<p>2.在所有资源里面进行查找匹配，找出我们需要的资源</p>
<p><strong>一定要注意determineRootDir得到的是完全确定的目录，也就是说这个目录结构中是不能包含通配符的</strong>.</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1.无论是classpath还是classpath*都可以加载整个classpath下（包括jar包里面）的资源文件。</p>
<p>2.classpath只会返回第一个匹配的资源，查找路径是优先在项目中存在资源文件，再查找jar包。classpath*:会找到所有的。</p>
<p>3.其实两者的区别实际上就是ClassLoader的getResoure和getResources的区别。</p>
<p>classpath*:调用的是getResources,这个已经很明显了，而你如果去观看classpath对应的Resource封装类，你会发现getUrl方法内部都是调用的getResource方法。</p>
<p>4.当出现classpath:spring*/spring-*.xml和classpath<em>\</em>:spring<em>/spring-\</em>.xml时，前者找不到资源后者可以找到。（当然前提是相应位置有），这个到底是否是正确的，还需要明天去公司验证。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2018/01/14/对classpath的理解/" data-id="cjcj5a2ji0001lobz904zktw2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Spring配置文件解析(一)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/11/Spring配置文件解析(一)/" class="article-date">
  <time datetime="2018-01-10T16:08:24.749Z" itemprop="datePublished">2018-01-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/11/Spring配置文件解析(一)/">Spring之BeanFactoryPostProcessor</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>今天在编写代码的时候，在ldap的spring配置文件中也使用了PropertyPlaceholderConfigurer来解析配置文件，而applicationContext这个根配置文件中已经使用了这个配置了，导致配置文件读取不到报错，后来，我只在根配置文件留了相关配置，把配置文件都放在这里面解析，然后就OK了。可是为什么不能有多个PropertyPlaceholderConfigurer实例呢？我们必须要搞清楚。</p>
<p>先看一个简单的配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"propertyConfigurer"</span></span></span><br><span class="line"><span class="tag">		<span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"locations"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">value</span>&gt;</span>classpath:um.properties<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">value</span>&gt;</span>classpath:jms.properties<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">value</span>&gt;</span>classpath:ldap.properties<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>而查找资料，我们可以很容易的看到当想要有多个实例共存的配置其实很简单，就是在配置文件里加上一个属性，</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"ignoreUnresolvablePlaceholders"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>即改成</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"propertyConfigurer"</span></span><br><span class="line">		<span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span><br><span class="line">		&lt;property name=<span class="string">"ignoreUnresolvablePlaceholders"</span> value=<span class="string">"true"</span>/&gt;</span><br><span class="line">		&lt;property name=<span class="string">"locations"</span>&gt;</span><br><span class="line">		</span><br><span class="line">			&lt;list&gt;</span><br><span class="line">				&lt;value&gt;classpath:um.properties&lt;/value&gt;</span><br><span class="line">				&lt;value&gt;classpath:jms.properties&lt;/value&gt;</span><br><span class="line">			&lt;/list&gt;</span><br><span class="line">		&lt;/property&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line">        &lt;bean id=<span class="string">"propertyConfigurer2"</span></span><br><span class="line">		<span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span><br><span class="line">		&lt;property name=<span class="string">"ignoreUnresolvablePlaceholders"</span> value=<span class="string">"true"</span>/&gt;</span><br><span class="line">		&lt;property name=<span class="string">"locations"</span>&gt;</span><br><span class="line">		</span><br><span class="line">		 &lt;list&gt;</span><br><span class="line">            &lt;value&gt;</span><br><span class="line">                classpath:ldap.properties</span><br><span class="line">            &lt;/value&gt;</span><br><span class="line">        &lt;/list&gt;</span><br><span class="line">		&lt;/property&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>这样多个实例就会相安无事，很好，问题解决了，可是这是为什么呢？我们一定要得知真相。</p>
<p>PropertyPlaceholderConfigurer：PlaceholderConfigurerSupport的子类，它解析本地属性或者系统属性或者环境变量定义的占位符(以${}描述)。分析下这个类</p>
<h3 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h3><p>PropertyPlaceholderConfigurer是个bean工厂后置处理器的实现，也就是 BeanFactoryPostProcessor接口的一个实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyPlaceholderConfigurer</span> <span class="keyword">extends</span> <span class="title">PlaceholderConfigurerSupport</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PlaceholderConfigurerSupport</span> <span class="keyword">extends</span> <span class="title">PropertyResourceConfigurer</span></span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">BeanNameAware</span>, <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyResourceConfigurer</span> <span class="keyword">extends</span> <span class="title">PropertiesLoaderSupport</span></span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span>, <span class="title">PriorityOrdered</span> </span>&#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesLoaderSupport</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<p>实现该接口，可以在spring的bean创建之前，修改bean的定义属性。也就是说，Spring允许BeanFactoryPostProcessor在容器实例化任何其它bean之前读取配置元数据，并可以根据需要进行修改，例如可以把bean的scope从singleton改为prototype，也可以把property的值给修改掉。可以同时配置多个BeanFactoryPostProcessor，并通过设置’order’属性来控制各个BeanFactoryPostProcessor的执行次序。<br>注意：BeanFactoryPostProcessor是在spring容器加载了bean的定义文件之后，在bean实例化之前执行的。接口方法的入参是ConfigurrableListableBeanFactory，使用该参数，可以获取到相关bean的定义信息。</p>
<p>我们来看看到底是在什么时候执行的</p>
<p>继续回到Spring初始化的方法refresh()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">			<span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">			prepareRefresh();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">			prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">				postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">				invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">				registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Initialize message source for this context.</span></span><br><span class="line">				initMessageSource();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">				initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">				onRefresh();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">				registerListeners();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">				finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">				finishRefresh();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">				logger.warn(<span class="string">"Exception encountered during context initialization - cancelling refresh attempt"</span>, ex);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">				destroyBeans();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Reset 'active' flag.</span></span><br><span class="line">				cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Propagate exception to caller.</span></span><br><span class="line">				<span class="keyword">throw</span> ex;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>关于BeanFactoryProcessor的调用 就在                        invokeBeanFactoryPostProcessors(beanFactory);</p>
<p>我们来看下这个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">		PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>其中getBeanFactoryPostProcessors()很明显是获取BeanFatoryPostProcessor实例类集合的方法，默认情况下，到这个节点为止，这个方法的到的结果应该是空的。</p>
<p>发现调用的是PostProcessorRegistrationDelegate的invokeBeanFactoryPostProcessors方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Invoke BeanDefinitionRegistryPostProcessors first, if any.</span></span><br><span class="line">		Set&lt;String&gt; processedBeans = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class="line">			BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">			List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="keyword">new</span> LinkedList&lt;BeanFactoryPostProcessor&gt;();</span><br><span class="line">			List&lt;BeanDefinitionRegistryPostProcessor&gt; registryPostProcessors =</span><br><span class="line">					<span class="keyword">new</span> LinkedList&lt;BeanDefinitionRegistryPostProcessor&gt;();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class="line">				<span class="keyword">if</span> (postProcessor <span class="keyword">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line">					BeanDefinitionRegistryPostProcessor registryPostProcessor =</span><br><span class="line">							(BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class="line">					registryPostProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">					registryPostProcessors.add(registryPostProcessor);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					regularPostProcessors.add(postProcessor);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">			<span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line">			<span class="comment">// Separate between BeanDefinitionRegistryPostProcessors that implement</span></span><br><span class="line">			<span class="comment">// PriorityOrdered, Ordered, and the rest.</span></span><br><span class="line">			String[] postProcessorNames =</span><br><span class="line">					beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">			List&lt;BeanDefinitionRegistryPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;BeanDefinitionRegistryPostProcessor&gt;();</span><br><span class="line">			<span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">				<span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">					priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">					processedBeans.add(ppName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			OrderComparator.sort(priorityOrderedPostProcessors);</span><br><span class="line">			registryPostProcessors.addAll(priorityOrderedPostProcessors);</span><br><span class="line">			invokeBeanDefinitionRegistryPostProcessors(priorityOrderedPostProcessors, registry);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.</span></span><br><span class="line">			postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">			List&lt;BeanDefinitionRegistryPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;BeanDefinitionRegistryPostProcessor&gt;();</span><br><span class="line">			<span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">					orderedPostProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">					processedBeans.add(ppName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			OrderComparator.sort(orderedPostProcessors);</span><br><span class="line">			registryPostProcessors.addAll(orderedPostProcessors);</span><br><span class="line">			invokeBeanDefinitionRegistryPostProcessors(orderedPostProcessors, registry);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.</span></span><br><span class="line">			<span class="keyword">boolean</span> reiterate = <span class="keyword">true</span>;</span><br><span class="line">			<span class="keyword">while</span> (reiterate) &#123;</span><br><span class="line">				reiterate = <span class="keyword">false</span>;</span><br><span class="line">				postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">				<span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">					<span class="keyword">if</span> (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">						BeanDefinitionRegistryPostProcessor pp = beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class);</span><br><span class="line">						registryPostProcessors.add(pp);</span><br><span class="line">						processedBeans.add(ppName);</span><br><span class="line">						pp.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">						reiterate = <span class="keyword">true</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Now, invoke the postProcessBeanFactory callback of all processors handled so far.</span></span><br><span class="line">			invokeBeanFactoryPostProcessors(registryPostProcessors, beanFactory);</span><br><span class="line">			invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Invoke factory processors registered with the context instance.</span></span><br><span class="line">			invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">		<span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line">		String[] postProcessorNames =</span><br><span class="line">				beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,</span></span><br><span class="line">		<span class="comment">// Ordered, and the rest.</span></span><br><span class="line">		List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;BeanFactoryPostProcessor&gt;();</span><br><span class="line">		List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		<span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">			<span class="keyword">if</span> (processedBeans.contains(ppName)) &#123;</span><br><span class="line">				<span class="comment">// skip - already processed in first phase above</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">				priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">				orderedPostProcessorNames.add(ppName);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">		OrderComparator.sort(priorityOrderedPostProcessors);</span><br><span class="line">		invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span></span><br><span class="line">		List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;BeanFactoryPostProcessor&gt;();</span><br><span class="line">		<span class="keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line">			orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">		&#125;</span><br><span class="line">		OrderComparator.sort(orderedPostProcessors);</span><br><span class="line">		invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Finally, invoke all other BeanFactoryPostProcessors.</span></span><br><span class="line">		List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;BeanFactoryPostProcessor&gt;();</span><br><span class="line">		<span class="keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">			nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">		&#125;</span><br><span class="line">		invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法又是巨长，我们来简单说一下这个方法都做了什么。</p>
<p>1.如果beanFactory是BeanDefinitionRegistry类型的（默认情况下是DefaultListableBeanFactory，实现了BeanDefinitionRegistry接口），</p>
<p>1.1定义两个List集合 ，一个打算用来存放regularBeanFactoryProcessor，一个存放register集合。</p>
<p>1.2遍历传进来的beanFactoryPostProcessors,如果是BeanDefinitionRegistryPostProcessor类型，则执行他的postProcessBeanDefinitionRegistry方法，然后加入register。如果不是，则加入regular。</p>
<p>1.3通过                beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);</p>
<p>得到所有注册到Spring容器中BeanDefinitionRegistryPostProcessor类型的Bean的beanName。</p>
<p>1.4新建一个名为priorityOrderedPostProcessors的List集合，用来存放实现了PriorityOrdered接口的BeanDefinitionRegistryPostProcessor实现类，并且也把这些实现类的name存入processedBeans这个HashSet中，使用HashSet，不能重复元素。</p>
<p>1.5排序后，把这个priorityOrdered的list集合加入到register中，然后对priorityOrdered执行invokeBeanDefinitionRegistryPostProcessors方法，即执行priorityOrdered的postProcessBeanDefinitionRegistry方法。</p>
<p>1.6新建一个名为orderedPostProcessors的集合来存放实现了Order接口的实现类，并且要剔除实现了PriorityOrdered接口的那部分，也把符合条件的实现类的名字加入processedBeans</p>
<p>1.7排序后，。。。和1.5一样</p>
<p>1.8，对哪些没有实现Order接口也没有实现PriorityOrdered的实现类（即不需要排序的类）调用他们的postProcessBeanDefinitionRegistry方法。</p>
<p>1.9最后对register和regular集合都调用共同要调用的方法，postProcessBeanFactory方法，这样就完成了BeanDefinitionRegistryPostProcessor这一类型BeanFactoryProcessor的调用。</p>
<p>2.如果不是BeanDefinitionRegistry类型的BeanFactory，那么就先直接遍历调用beanFactoryPostProcessors集合元素的postProcessBeanDefinitionRegistry</p>
<p>3.来到了非BeanDefinitionRegistryPostProcessor类型的BeanFactoryProcessor的调用，思路和1中的思路完全一样，就不啰嗦了。</p>
<p>我们分析了Spring对BeanFactoryProcessor实现类的调用节点以及调用的方法，那我们现在就来分析下PropertyPlaceholderConfigurer。</p>
<h3 id="PropertyPlaceholderConfigurer"><a href="#PropertyPlaceholderConfigurer" class="headerlink" title="PropertyPlaceholderConfigurer"></a>PropertyPlaceholderConfigurer</h3><p>我们第一时间肯定是要寻找他的postProcessBeanFactory方法，我们没有在该类中找到，很明显,肯定是他的祖先类实现了，而自己并没有去重写这个方法。</p>
<p>PropertyResourceConfigurer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//load Properties</span></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">          还记得我们处理Properties</span></span><br><span class="line"><span class="comment">          InputStream resource </span></span><br><span class="line"><span class="comment">          props.load(resource);</span></span><br><span class="line"><span class="comment">          </span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">          <span class="comment">//就是为了得到可以直接使用prop.getProperty();的Properties</span></span><br><span class="line">			Properties mergedProps = mergeProperties();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Convert the merged properties, if necessary.</span></span><br><span class="line">			convertProperties(mergedProps);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Let the subclass process the properties.</span></span><br><span class="line">			processProperties(beanFactory, mergedProps);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanInitializationException(<span class="string">"Could not load properties"</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>替换${key} 为配置文件中相应的value，配置文件可以是.xml也可以是.properties</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processProperties</span><span class="params">(ConfigurableListableBeanFactory beanFactoryToProcess, Properties props)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">	StringValueResolver valueResolver = <span class="keyword">new</span> PlaceholderResolvingStringValueResolver(props);</span><br><span class="line">	doProcessProperties(beanFactoryToProcess, valueResolver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>深入这个方法了解源码之后，发现其实并不难，但是还是比较繁琐的。</p>
<p>我就讲下思路吧，有兴趣的可以深入源码了解。</p>
<p>因为beanFactory是入参,所以我们可以很容易的得到所有注册好的Bean,遍历Spring中所有的bean，除开自己以外所有的bean，然后查看每一个bean的属性是否有${….}这种结构，如果有就替换，没有就返回原值，不做处理。这样做是不是会很耗时，我想确实挺耗时的吧，但是好在这是在Spring初始化的时候就完成了，而不是在程序上线运转后在动态的加载，否则真的是我的乖乖，Spring的初始化过程做了很多工作，必然是一个很耗时的过程，但是好在他是在项目初始化的时候完成的，而我们后续的所有动态操作都可以在Spring这个巨大的容器中找到相应的信息来帮助我们处理。</p>
<p>看到这里，你知道为什么一开始会报错了吗？</p>
<p>原因很简单，因为我们得到的是所有的Bean，但是我们目前这个PropertyPlaceholderConfigurer实例并不能解析所有的${}占位符结构，因为这个实例并不包含所有的配置文件呀，有些占位符里的key是在另一个实例中，所以自然解析不到。</p>
<p>那么为什么对每一个实例使用了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name=<span class="string">"ignoreUnresolvablePlaceholders"</span> value=<span class="string">"true"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>就可以了呢？</p>
<p>这个配置其实就是忽略到不能解析的占位符，就是说如果我这个实例没法处理我就不处理了，反正还会有下一个实例来处理这个占位符。那么相应的源码在哪呢？</p>
<p>真正解析占位符的是在PropertyPlaceholderHelper中，初始化这个类的时候就在构造方法里把ignoreUnresolvablePlaceholders注入了，默认这个属性是false，也就是一定要解析，解析不了就要抛异常。</p>
<p>我们看看解析的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">parseStringValue</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			String strVal, PlaceholderResolver placeholderResolver, Set&lt;String&gt; visitedPlaceholders)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		StringBuilder result = <span class="keyword">new</span> StringBuilder(strVal);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> startIndex = strVal.indexOf(<span class="keyword">this</span>.placeholderPrefix);</span><br><span class="line">		<span class="keyword">while</span> (startIndex != -<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> endIndex = findPlaceholderEndIndex(result, startIndex);</span><br><span class="line">			<span class="keyword">if</span> (endIndex != -<span class="number">1</span>) &#123;</span><br><span class="line">				String placeholder = result.substring(startIndex + <span class="keyword">this</span>.placeholderPrefix.length(), endIndex);</span><br><span class="line">				String originalPlaceholder = placeholder;</span><br><span class="line">				<span class="keyword">if</span> (!visitedPlaceholders.add(originalPlaceholder)) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">							<span class="string">"Circular placeholder reference '"</span> + originalPlaceholder + <span class="string">"' in property definitions"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// Recursive invocation, parsing placeholders contained in the placeholder key.</span></span><br><span class="line">				placeholder = parseStringValue(placeholder, placeholderResolver, visitedPlaceholders);</span><br><span class="line">				<span class="comment">// Now obtain the value for the fully resolved key...</span></span><br><span class="line">				String propVal = placeholderResolver.resolvePlaceholder(placeholder);</span><br><span class="line">				<span class="keyword">if</span> (propVal == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.valueSeparator != <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">int</span> separatorIndex = placeholder.indexOf(<span class="keyword">this</span>.valueSeparator);</span><br><span class="line">					<span class="keyword">if</span> (separatorIndex != -<span class="number">1</span>) &#123;</span><br><span class="line">						String actualPlaceholder = placeholder.substring(<span class="number">0</span>, separatorIndex);</span><br><span class="line">						String defaultValue = placeholder.substring(separatorIndex + <span class="keyword">this</span>.valueSeparator.length());</span><br><span class="line">						propVal = placeholderResolver.resolvePlaceholder(actualPlaceholder);</span><br><span class="line">						<span class="keyword">if</span> (propVal == <span class="keyword">null</span>) &#123;</span><br><span class="line">							propVal = defaultValue;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (propVal != <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="comment">// Recursive invocation, parsing placeholders contained in the</span></span><br><span class="line">					<span class="comment">// previously resolved placeholder value.</span></span><br><span class="line">					propVal = parseStringValue(propVal, placeholderResolver, visitedPlaceholders);</span><br><span class="line">					result.replace(startIndex, endIndex + <span class="keyword">this</span>.placeholderSuffix.length(), propVal);</span><br><span class="line">					<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">						logger.trace(<span class="string">"Resolved placeholder '"</span> + placeholder + <span class="string">"'"</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					startIndex = result.indexOf(<span class="keyword">this</span>.placeholderPrefix, startIndex + propVal.length());</span><br><span class="line">				&#125;</span><br><span class="line">              <span class="comment">//*********处理不能解析的情况</span></span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.ignoreUnresolvablePlaceholders) &#123;</span><br><span class="line">					<span class="comment">// Proceed with unprocessed value.</span></span><br><span class="line">					startIndex = result.indexOf(<span class="keyword">this</span>.placeholderPrefix, endIndex + <span class="keyword">this</span>.placeholderSuffix.length());</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Could not resolve placeholder '"</span> +</span><br><span class="line">							placeholder + <span class="string">"'"</span> + <span class="string">" in string value \""</span> + strVal + <span class="string">"\""</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				visitedPlaceholders.remove(originalPlaceholder);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				startIndex = -<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> result.toString();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到当不能处理的时候，如果ignoreUnresolvablePlaceholders为true，就不会抛出异常，而是返回占位符，就是他还是占位符形式，给到下一个能解析他的PropertyPlaceholderConfigurer来解析他。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2018/01/11/Spring配置文件解析(一)/" data-id="cjc99g1dc000040bz8pkzh5td" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java-WEB/">Java WEB</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaWEB/">JavaWEB</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java基础/">Java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mybatis/">Mybatis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringMVC/">SpringMVC</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js-css/">js&&css</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/01/31/DelegatingFilterProxy/">DelegatingFilterProxy</a>
          </li>
        
          <li>
            <a href="/2018/01/31/--Java中的引用传递/">Java中的引用传递</a>
          </li>
        
          <li>
            <a href="/2018/01/31/--装饰者模式/">装饰者模式(一)</a>
          </li>
        
          <li>
            <a href="/2018/01/24/--CSS笔记（一）/">CSS笔记（一）</a>
          </li>
        
          <li>
            <a href="/2018/01/24/--JDK1.8中接口的新特性/">JDK1.8中接口的新特性</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>