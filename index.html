<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>迷途书童的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="厚积薄发">
<meta property="og:type" content="website">
<meta property="og:title" content="迷途书童的博客">
<meta property="og:url" content="https://cong96.github.io/index.html">
<meta property="og:site_name" content="迷途书童的博客">
<meta property="og:description" content="厚积薄发">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="迷途书童的博客">
<meta name="twitter:description" content="厚积薄发">
  
    <link rel="alternate" href="/atom.xml" title="迷途书童的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">迷途书童的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">一天进步一点</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://cong96.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Memory Leak" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/29/Memory Leak/" class="article-date">
  <time datetime="2017-11-29T13:13:04.268Z" itemprop="datePublished">2017-11-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java基础/">Java基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/29/Memory Leak/">Memory</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="内存的释放"><a href="#内存的释放" class="headerlink" title="内存的释放"></a>内存的释放</h3><p>  内存的释放，也即清理那些不可达的对象，是由GC决定和执行的，所以GC会监控每一个对象的状态，包括申请、引用、被引用和赋值等。<strong>释放对象的根本原则就是对象不会再被使用</strong>：</p>
<ul>
<li>​    给对象赋予了空值null，之后再没有调用过。</li>
<li>​    另一个是给对象赋予了新值，这样重新分配了内存空间。</li>
</ul>
<p>​    通常，会认为在堆上分配对象的代价比较大，但是GC却优化了这一操作：C++中，在堆上分配一块内存，会查找一块适用的内存加以分配，如果对象销毁，这块内存就可以重用；而Java中，就想一条长的带子，每分配一个新的对象，Java的“堆指针”就向后移动到尚未分配的区域。所以，Java分配内存的效率，可与C++媲美。</p>
<p>​    但是这种工作方式有一个问题：如果频繁的申请内存，资源将会耗尽。这时GC就介入了进来，它会回收空间，并使堆中的对象排列更紧凑。这样，就始终会有足够大的内存空间可以分配。</p>
<p>​    gc清理时的引用计数方式：当引用连接至新对象时，引用计数+1；当某个引用离开作用域或被设置为null时，引用计数-1，GC发现这个计数为0时，就回收其占用的内存。这个开销会在引用程序的整个生命周期发生，并且不能处理循环引用的情况。所以这种方式只是用来说明GC的工作方式，而不会被任何一种Java虚拟机应用。</p>
<p>​    多数GC采用一种自适应的清理方式（加上其他附加的用于提升速度的技术），主要依据是找出任何“活”的对象，然后采用“自适应的、分代的、停止-复制、标记-清理”式的垃圾回收器。具体不介绍太多，这不是本文重点。</p>
<h3 id="Java中的内存泄漏"><a href="#Java中的内存泄漏" class="headerlink" title="Java中的内存泄漏"></a>Java中的内存泄漏</h3><p>​    Java中的内存泄露，广义并通俗的说，就是：不再会被使用的对象的内存不能被回收，就是内存泄露。</p>
<p>Java中的内存泄露与C++中的表现有所不同。</p>
<p>​    在C++中，所有被分配了内存的对象，不再使用后，都必须程序员手动的释放他们。所以，每个类，都会含有一个析构函数，作用就是完成清理工作，如果我们忘记了某些对象的释放，就会造成内存泄露。</p>
<p>​    但是在Java中，我们不用（也没办法）自己释放内存，无用的对象由GC自动清理，这也极大的简化了我们的编程工作。但，实际有时候一些不再会被使用的对象，在GC看来不能被释放，就会造成内存泄露。</p>
<p>​    我们知道，对象都是有生命周期的，有的长，有的短，<strong>如果长生命周期的对象持有短生命周期的引用，就很可能会出现内存泄露</strong>。</p>
<p>For Example:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         <span class="keyword">return</span> (E) elementData[--size];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>Should Be</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">          E e = (E) elementData[--size];</span><br><span class="line">          elementData[size] = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">return</span> e;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="How-To-Fix-Memory-Leak"><a href="#How-To-Fix-Memory-Leak" class="headerlink" title="How To Fix Memory Leak"></a>How To Fix Memory Leak</h3><p>我们知道Java语言中，内存管理是交给JVM实现的，那么如果我们想一定程度上控制内存管理，以达到解决内存泄漏的问题呢？Java给我们提供了相关的API，我们来看下他们可以提供那些功能，看看靠不靠谱，能不能解决内存泄漏的问题。</p>
<ul>
<li><p>gc()</p>
<p>先看System.gc()的API</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">运行垃圾回收器。 </span><br><span class="line">调用 gc 方法暗示着 Java 虚拟机做了一些努力来回收未用对象，以便能够快速地重用这些对象当前占用的内存。当控制权从方法调用中返回时，虚拟机已经尽最大努力从所有丢弃的对象中回收了空间。 </span><br><span class="line"></span><br><span class="line">调用 System.gc() 实际上等效于调用： </span><br><span class="line"></span><br><span class="line"> Runtime.getRuntime().gc()</span><br></pre></td></tr></table></figure>
<p>我们看到上面的描述是说JVM努力回收未用对象，JVM已经尽最大努力从所有丢弃的对象中回收了空间。这是什么意思呢，这就是告诉我们，我这个方法不一定靠谱，我只是尽力回收，不能保证一定回收。</p>
<p>为什么只是尽力而不能确保呢：因为，不同的JVM实现者可能使用不同的算法管理GC。通常，GC的线程的优先级别较低。JVM调用GC的策略也有很多种，有的是内存使用到达一定程度时，GC才开始工作，也有定时执行的，有的是平缓执行GC，有的是中断式执行GC。但通常来说，我们不需要关心这些。除非在一些特定的场合，GC的执行影响应用程序的性能，例如对于基于Web的实时系统，如网络游戏等，用户不希望GC突然中断应用程序执行而进行垃圾回收，那么我们需要调整GC的参数，让GC能够通过平缓的方式释放内存，例如将垃圾回收分解为一系列的小步骤执行，Sun提供的HotSpot JVM就支持这一特性。</p>
</li>
<li><p><strong>finalize()</strong></p>
<p>Object finalize()  Explain in Java API</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。子类重写 finalize 方法，以配置系统资源或执行其他清除。 </span><br><span class="line">finalize 的常规协定是：当 JavaTM 虚拟机已确定尚未终止的任何线程无法再通过任何方法访问此对象时，将调用此方法，除非由于准备终止的其他某个对象或类的终结操作执行了某个操作。finalize 方法可以采取任何操作，其中包括再次使此对象对其他线程可用；不过，finalize 的主要目的是在不可撤消地丢弃对象之前执行清除操作。例如，表示输入/输出连接的对象的 finalize 方法可执行显式 I/O 事务，以便在永久丢弃对象之前中断连接。 </span><br><span class="line"></span><br><span class="line">Object 类的 finalize 方法执行非特殊性操作；它仅执行一些常规返回。Object 的子类可以重写此定义。 </span><br><span class="line"></span><br><span class="line">Java 编程语言不保证哪个线程将调用某个给定对象的 finalize 方法。但可以保证在调用 finalize 时，调用 finalize 的线程将不会持有任何用户可见的同步锁定。如果 finalize 方法抛出未捕获的异常，那么该异常将被忽略，并且该对象的终结操作将终止。 </span><br><span class="line"></span><br><span class="line">在启用某个对象的 finalize 方法后，将不会执行进一步操作，直到 Java 虚拟机再次确定尚未终止的任何线程无法再通过任何方法访问此对象，其中包括由准备终止的其他对象或类执行的可能操作，在执行该操作时，对象可能被丢弃。 </span><br><span class="line"></span><br><span class="line">对于任何给定对象，Java 虚拟机最多只调用一次 finalize 方法。 </span><br><span class="line"></span><br><span class="line">finalize 方法抛出的任何异常都会导致此对象的终结操作停止，但可以通过其他方法忽略它。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">​</span><br><span class="line"></span><br><span class="line">**finalize 的常规协定是：当 JavaTM 虚拟机已确定尚未终止的任何线程无法再通过任何方法访问此对象时，将调用此方法，除非由于准备终止的其他某个对象或类的终结操作执行了某个操作。finalize 方法可以采取任何操作，其中包括再次使此对象对其他线程可用；不过，finalize 的主要目的是在不可撤消地丢弃对象之前执行清除操作。例如，表示输入/输出连接的对象的 finalize 方法可执行显式 I/O 事务，以便在永久丢弃对象之前中断连接。 **</span><br><span class="line"></span><br><span class="line">​</span><br><span class="line"></span><br><span class="line">在 C/C++、Pascal和其他几种多种用途的编程语言中，开发者有责任在内存管理上发挥积极的作用。例如，如果你为一个对象或数据结构分配了内存，那么当你不再使用它时必须释放掉该内存。</span><br><span class="line"></span><br><span class="line">在 Java 中，当你创建一个对象时，Java 虚拟机（JVM）为该对象分配内存、调用构造函数并开始跟踪你使用的对象。当你停止使用一个对象（就是说，当没有对该对象有效的引用时），JVM 通过垃圾回收器将该对象标记为释放状态。</span><br><span class="line"></span><br><span class="line">当垃圾回收器将要释放一个对象的内存时，它调用该对象的finalize() 方法（如果该对象定义了此方法）。垃圾回收器以独立的低优先级的方式运行，只有当其他线程挂起等待该内存释放的情况出现时，它才开始运行释放对象的内存。（事实上，你可以调用System.gc() 方法强制垃圾回收器来释放这些对象的内存。）</span><br><span class="line"></span><br><span class="line">在以上的描述中，有一些重要的事情需要注意。首先，只有当垃圾回收器释放该对象的内存时，才会执行finalize()。如果在 Applet 或应用程序退出之前垃圾回收器没有释放内存，垃圾回收器将不会调用finalize()。</span><br><span class="line"></span><br><span class="line">其次，除非垃圾回收器认为你的 Applet 或应用程序需要额外的内存，否则它不会试图释放不再使用的对象的内存。换句话说，这是完全可能的：一个 Applet 给少量的对象分配内存，没有造成严重的内存需求，于是垃圾回收器没有释放这些对象的内存就退出了。</span><br><span class="line"></span><br><span class="line">**显然，如果你为某个对象定义了finalize() 方法，JVM 可能不会调用它，因为垃圾回收器不曾释放过那些对象的内存。调用System.gc() 也不会起作用，因为它仅仅是给 JVM 一个建议而不是命令。**</span><br><span class="line"></span><br><span class="line">如果finalize() 不是析构函数，JVM 不一定会调用它，你可能会疑惑它是否在任何情况下都有好处。事实上，在 Java 1.0 中它并没有太多的优点。</span><br><span class="line"></span><br><span class="line">根据 Java 文档，finalize() 是一个用于释放非 Java 资源的方法。但是，**JVM 有很大的可能不调用对象的finalize() 方法，因此很难证明使用该方法释放资源是有效的。**</span><br><span class="line"></span><br><span class="line">Java 1.1 通过提供一个System.runFinalizersOnExit() 方法部分地解决了这个问题。（不要将这个方法与 Java 1.0 中的System.runFinalizations() 方法相混淆。）不象System.gc() 方法那样，System.runFinalizersOnExit() 方法并不立即试图启动垃圾回收器。而是当应用程序或 Applet 退出时，它调用每个对象的finalize() 方法。</span><br><span class="line"></span><br><span class="line">正如你可能猜测的那样，通过调用System.runFinalizersOnExit() 方法强制垃圾回收器清除所有独立对象的内存，当清除代码执行时可能会引起明显的延迟。现在建立一个示例 Applet 来演示 Java 垃圾回收器和finalize() 方法是如何相互作用的。</span><br><span class="line"></span><br><span class="line">我们看FileInputStream这个类就重写了finalize()</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">    protected void finalize() throws IOException &#123;</span><br><span class="line">        if ((fd != null) &amp;&amp;  (fd != FileDescriptor.in)) &#123;</span><br><span class="line">            /* if fd is shared, the references in FileDescriptor</span><br><span class="line">             * will ensure that finalizer is only called when</span><br><span class="line">             * safe to do so. All references using the fd have</span><br><span class="line">             * become unreachable. We can call close()</span><br><span class="line">             */</span><br><span class="line">            close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>API Document给出的解释是：确保在不再引用文件输入流时调用其 close 方法。 </p>
<p>但是在上面我们已经分析过了，如果你为某个对象定义了finalize() 方法，JVM 可能不会调用它，因为垃圾回收器不曾释放过那些对象的内存。调用System.gc() 也不会起作用，因为它仅仅是给 JVM 一个建议而不是命令。也就是说，即使你的想法很美好，在finalize里执行了close方法，想来保证再不使用这个对象的时候能够确保关闭资源，但是很遗憾的是，即使不再使用这个对象了，也无法保证这个finalize方法会成功运行。finalize的运行和GC垃圾回收器有关，但是遗憾的是即使你显示的调用System.gc()来视图触发JVM来执行垃圾回收的动作，但是事实却往往不如我们所愿，GC回收操作可能并不会执行，也就意味着这个文件输入流资源一直会被占用，不被释放掉。</p>
<p>我们回想我们学习FileInputStream的时候，我们要求在使用完毕这个对象的时候一定要确保程序调用close方法来关闭资源。</p>
<p>还记得我们是怎样确保一定关闭资源的吗。</p>
<p>使用try-finally结构实现。</p>
<p>​</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1.Java语言与C++等不同，Java程序员是无法参与内存管理的，内存管理由JVM完成。</p>
<p>在 Java 中，当你创建一个对象时，Java 虚拟机（JVM）为该对象分配内存、调用构造函数并开始跟踪你使用的对象。当你停止使用一个对象（就是说，当没有对该对象有效的引用时），JVM 通过垃圾回收器将该对象标记为释放状态。</p>
<p>2.gc()和finalize() 不可靠，具体还是要看JVM的。这两个方法都不一定会起到我们预想的作用，很多时候是不能，所以并不建议使用。</p>
<p>3.到底如何避免内存泄漏呢</p>
<p>为了避免内存泄漏，我们应该将不用的对象都显式的置为null。</p>
<p>但是将对象设置为null，会减少内存占用吗？</p>
<p>但是你置为null了，就会马上释放内存吗？很显然还是不会的呀，我们无法预知GC到底什么时候来回收，所以不能避免。</p>
<p>但是，并不能说置为null是毫无用处的。</p>
<p>以下来源于知乎：</p>
<ul>
<li>手动设置null对释放对象有用，但用处不大，如果手动设置到自动设置（局部变量消亡或者被设置成其它值）之间发生了GC，那就有用，没发生GC就没用。</li>
<li>但是已经分配给new Object()的内存还是存在的，只是没有了引用指向这块内存，会被系统优先GC（但是不定时）。另外，设置NULL我觉得纯属于好习惯，避免后面胡乱使用而已。</li>
<li>不会，设置为null，只是栈中指向的引用为Null，但是new出来的对象还是存在于堆里面的，按照目前的GC算法。要等survior1 or survior2满的时候，JVM才会调用GC命令清除对应survior区的对象，将没有栈指向的对象给回收掉。所以回收内存不是实时的，要看survior区的大小和应用中创建对象的速度来看。</li>
</ul>
<p>可以得出结论：</p>
<p> 设置为null无法减少内存占用，但是他应该是可以加快垃圾回收的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2017/11/29/Memory Leak/" data-id="cjal2slah0000c4bzynilv2fb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ResultSetHandler" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/26/ResultSetHandler/" class="article-date">
  <time datetime="2017-11-26T08:57:57.064Z" itemprop="datePublished">2017-11-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Mybatis/">Mybatis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/26/ResultSetHandler/">ResultSetHandler</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="ResultSetHandler介绍"><a href="#ResultSetHandler介绍" class="headerlink" title="ResultSetHandler介绍"></a>ResultSetHandler介绍</h3><p>ResultSetHandler是处理结果集的接口，在我看来他的实现类DefaultResultSetHandler是最难理解的一个组件，之所以复杂是因为Mybatis中ResultMap的设计非常强大，他可以满足用户的很多需求。</p>
<p>MyBatis是基于“数据库结构不可控”的思想建立的，也就是我们希望数据库遵循第三范式或BCNF，但实际事与愿违，那么结果集映射就是MyBatis为我们提供这种理想与现实间转换的手段了，为了实现这一灵活的转化，给用户带来便利，Mybatis做了很多努力，这些努力的具体实现大多都体现在DefaultResultSetHandler这个类中。所以在后面我们会通过查询过程的Debug来好好分析这个类。</p>
<p>我们先看看ResultSetHandler接口的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResultSetHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">handleResultSets</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">handleOutputParameters</span><span class="params">(CallableStatement cs)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个接口只定义了两个方法</p>
<p>handleResultSets就是用来处理结果集的方法，如何将数据库执行后返回的结果集转化为我们在Mapper文件中定义的ResultMap对应的返回，就是通过这个方法实现的。</p>
<p>handleOutputParameters这个方法目前还没有用到，因为目前还没有使用到存储过程。</p>
<h3 id="handleResultSets"><a href="#handleResultSets" class="headerlink" title="handleResultSets"></a>handleResultSets</h3><p>我们接着分析查询的过程</p>
<p>现在代码已经执行到了这个阶段</p>
<p>PreparedStatementHandler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">   PreparedStatement ps = (PreparedStatement) statement;</span><br><span class="line"><span class="comment">//执行数据库操作</span></span><br><span class="line">   ps.execute();</span><br><span class="line">   <span class="comment">//调用handleResultSets处理结果集</span></span><br><span class="line">   <span class="keyword">return</span> resultSetHandler.&lt;E&gt; handleResultSets(ps);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>执行ps.execute();后</p>
<p>控制台如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Setting autocommit to <span class="keyword">false</span> on JDBC Connection [com.mysql.jdbc.JDBC4Connection@<span class="number">2</span>ed2d9cb]</span><br><span class="line">==&gt;  Preparing: select * <span class="function">from t_user where t_id <span class="title">in</span> <span class="params">( ? , ? , ? )</span> </span></span><br><span class="line"><span class="function"></span>==&gt; Parameters: <span class="number">1</span>(Integer), <span class="number">3</span>(Integer), <span class="number">25</span>(Integer)</span><br></pre></td></tr></table></figure>
<p>进入handleResultSets方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">handleResultSets</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">   ErrorContext.instance().activity(<span class="string">"handling results"</span>).object(mappedStatement.getId());</span><br><span class="line">   	<span class="comment">//先新建一个存放最终的结果的ArrayList</span></span><br><span class="line">   <span class="keyword">final</span> List&lt;Object&gt; multipleResults = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> resultSetCount = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//得到ResultSet结果集， 然后对ResultSetMetaData元数据封装一下</span></span><br><span class="line">   ResultSetWrapper rsw = getFirstResultSet(stmt);</span><br><span class="line"><span class="comment">//得到该SqlMapper配置文件指定的ResultMap</span></span><br><span class="line">   List&lt;ResultMap&gt; resultMaps = mappedStatement.getResultMaps();</span><br><span class="line">   <span class="keyword">int</span> resultMapCount = resultMaps.size();</span><br><span class="line">  <span class="comment">//校验ResultMap的数量，不能为0或者不存在，如果是，则会抛出异常</span></span><br><span class="line">   validateResultMapsCount(rsw, resultMapCount);</span><br><span class="line">   <span class="keyword">while</span> (rsw != <span class="keyword">null</span> &amp;&amp; resultMapCount &gt; resultSetCount) &#123;</span><br><span class="line">     <span class="comment">//依次从List集合中按index取ResultMap</span></span><br><span class="line">     ResultMap resultMap = resultMaps.get(resultSetCount);</span><br><span class="line">     <span class="comment">//然后加入针对ResultMap处理结果集的方法</span></span><br><span class="line">     handleResultSet(rsw, resultMap, multipleResults, <span class="keyword">null</span>);</span><br><span class="line">     rsw = getNextResultSet(stmt);</span><br><span class="line">     cleanUpAfterHandlingResultSet();</span><br><span class="line">     resultSetCount++;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   String[] resultSets = mappedStatement.getResulSets();</span><br><span class="line">   <span class="keyword">if</span> (resultSets != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="keyword">while</span> (rsw != <span class="keyword">null</span> &amp;&amp; resultSetCount &lt; resultSets.length) &#123;</span><br><span class="line">       ResultMapping parentMapping = nextResultMaps.get(resultSets[resultSetCount]);</span><br><span class="line">       <span class="keyword">if</span> (parentMapping != <span class="keyword">null</span>) &#123;</span><br><span class="line">         String nestedResultMapId = parentMapping.getNestedResultMapId();</span><br><span class="line">         ResultMap resultMap = configuration.getResultMap(nestedResultMapId);</span><br><span class="line">         handleResultSet(rsw, resultMap, <span class="keyword">null</span>, parentMapping);</span><br><span class="line">       &#125;</span><br><span class="line">       rsw = getNextResultSet(stmt);</span><br><span class="line">       cleanUpAfterHandlingResultSet();</span><br><span class="line">       resultSetCount++;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> collapseSingleResultList(multipleResults);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>getFirstResultSet</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ResultSetWrapper <span class="title">getFirstResultSet</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  </span><br><span class="line">    ResultSet rs = stmt.getResultSet();</span><br><span class="line">    <span class="keyword">while</span> (rs == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// move forward to get the first resultset in case the driver</span></span><br><span class="line">      <span class="comment">// doesn't return the resultset as the first result (HSQLDB 2.1)</span></span><br><span class="line">      <span class="keyword">if</span> (stmt.getMoreResults()) &#123;</span><br><span class="line">        rs = stmt.getResultSet();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stmt.getUpdateCount() == -<span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">// no more results. Must be no resultset</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rs != <span class="keyword">null</span> ? <span class="keyword">new</span> ResultSetWrapper(rs, configuration) : <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法就是为了得到ResultSet结果集，如果成功得到结果集，就将结果集封装一下，返回封装好的ResultSetWrapper对象</p>
<p>这个方法里面用到了一些原生JDBC的API方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">getResultSet</span><br><span class="line">ResultSet getResultSet()</span><br><span class="line">                       throws SQLException以 ResultSet 对象的形式获取当前结果。每个结果只应调用一次此方法。 </span><br><span class="line"></span><br><span class="line">返回：</span><br><span class="line">以 ResultSet 对象的形式返回当前结果；如果结果是更新计数或没有更多的结果，则返回 null </span><br><span class="line">抛出： </span><br><span class="line">SQLException - 如果发生数据库访问错误，或者在已关闭的 Statement 上调用此方法</span><br><span class="line">另请参见：</span><br><span class="line">execute(java.lang.String)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">getMoreResults</span><br><span class="line">boolean getMoreResults(int current)</span><br><span class="line">                       throws SQLException将此 Statement 对象移动到下一个结果，根据给定标志指定的指令处理所有当前 ResultSet 对象；如果下一个结果为 ResultSet 对象，则返回 true。 </span><br><span class="line">当以下表达式为 true 时没有更多结果： </span><br><span class="line"></span><br><span class="line">     // stmt is a Statement object</span><br><span class="line">     ((stmt.getMoreResults(current) == false) &amp;&amp; (stmt.getUpdateCount() == -1))</span><br><span class="line"> </span><br><span class="line">参数：</span><br><span class="line">current - 下列 Statement 常量之一，这些常量指示将对使用 getResultSet 方法获取的当前 ResultSet 对象发生的操作：Statement.CLOSE_CURRENT_RESULT、Statement.KEEP_CURRENT_RESULT 或 Statement.CLOSE_ALL_RESULTS </span><br><span class="line">返回：</span><br><span class="line">如果下一个结果为 ResultSet 对象，则返回 true；如果其为更新计数或者不存在更多的结果，则返回 false </span><br><span class="line">抛出： </span><br><span class="line">SQLException - 如果发生数据库访问错误，在已关闭的 Statement 上调用此方法，或者提供的参数不是以下参数之一：Statement.CLOSE_CURRENT_RESULT、Statement.KEEP_CURRENT_RESULT 或 Statement.CLOSE_ALL_RESULTS </span><br><span class="line">SQLFeatureNotSupportedException - 如果 DatabaseMetaData.supportsMultipleOpenResults 返回 false，并且 Statement.KEEP_CURRENT_RESULT 或 Statement.CLOSE_ALL_RESULTS 作为参数提供。</span><br><span class="line">从以下版本开始： </span><br><span class="line">1.4 </span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">getUpdateCount</span><br><span class="line">int getUpdateCount()</span><br><span class="line">                   throws SQLException以更新计数的形式获取当前结果；如果结果为 ResultSet 对象或没有更多结果，则返回 -1。每个结果只应调用一次此方法。 </span><br><span class="line"></span><br><span class="line">返回：</span><br><span class="line">以更新计数的形式返回当前结果；如果当前结果为 ResultSet 对象或没有更多结果，则返回 -1 </span><br><span class="line">抛出： </span><br><span class="line">SQLException - 如果发生数据库访问错误，或者在已关闭的 Statement 上调用此方法</span><br><span class="line">另请参见：</span><br><span class="line">execute(java.lang.String)</span><br></pre></td></tr></table></figure>
<p>我们也有必要了解这个封装的对象ResultSetWrapper</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResultSetWrapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ResultSet resultSet;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> TypeHandlerRegistry typeHandlerRegistry;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; columnNames = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; classNames = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;JdbcType&gt; jdbcTypes = <span class="keyword">new</span> ArrayList&lt;JdbcType&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Map&lt;Class&lt;?&gt;, TypeHandler&lt;?&gt;&gt;&gt; typeHandlerMap = <span class="keyword">new</span> HashMap&lt;String, Map&lt;Class&lt;?&gt;, TypeHandler&lt;?&gt;&gt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> Map&lt;String, List&lt;String&gt;&gt; mappedColumnNamesMap = <span class="keyword">new</span> HashMap&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> Map&lt;String, List&lt;String&gt;&gt; unMappedColumnNamesMap = <span class="keyword">new</span> HashMap&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ResultSetWrapper</span><span class="params">(ResultSet rs, Configuration configuration)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="comment">//注入了TypeHandlerRegistry,TypeHandler的注册中心</span></span><br><span class="line">    <span class="keyword">this</span>.typeHandlerRegistry = configuration.getTypeHandlerRegistry();</span><br><span class="line">    <span class="comment">//注入了ResultSet</span></span><br><span class="line">    <span class="keyword">this</span>.resultSet = rs;</span><br><span class="line">    <span class="comment">//得到ResultSet的元数据 可用于获取关于 ResultSet 对象中列的类型和属性信息的对象。</span></span><br><span class="line">    <span class="keyword">final</span> ResultSetMetaData metaData = rs.getMetaData();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> columnCount = metaData.getColumnCount();</span><br><span class="line">    <span class="comment">//对元数据的相关有用信息进行封装</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= columnCount; i++) &#123;</span><br><span class="line">      <span class="comment">//将返回的元数据的ColumnName添加到一个String类型的ArrayList中，如果SQL中使用了AS ColumnLable就取ColumnLable，否则就取ColumnName.</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      getColumnLabel</span></span><br><span class="line"><span class="comment">String getColumnLabel(int column)</span></span><br><span class="line"><span class="comment">                      throws SQLException获取用于打印输出和显示的指定列的建议标题。建议标题通常由 SQL AS 子句来指定。如果未指定 SQL AS，则从 getColumnLabel 返回的值将和 getColumnName 方法返回的值相同。</span></span><br><span class="line"><span class="comment">                      </span></span><br><span class="line"><span class="comment">                      getColumnName</span></span><br><span class="line"><span class="comment">String getColumnName(int column)</span></span><br><span class="line"><span class="comment">                     throws SQLException获取指定列的名称。 </span></span><br><span class="line"><span class="comment">      </span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      </span><br><span class="line">      columnNames.add(configuration.isUseColumnLabel() ? metaData.getColumnLabel(i) : metaData.getColumnName(i));</span><br><span class="line">     </span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      getColumnType</span></span><br><span class="line"><span class="comment">int getColumnType(int column)</span></span><br><span class="line"><span class="comment">                  throws SQLException获取指定列的 SQL 类型。</span></span><br><span class="line"><span class="comment">      得到元数据指定Column的SQL 类型类型，将类型也存储到一个List集合中</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      jdbcTypes.add(JdbcType.forCode(metaData.getColumnType(i)));</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      getColumnClassName</span></span><br><span class="line"><span class="comment">String getColumnClassName(int column)</span></span><br><span class="line"><span class="comment">                          throws SQLException如果调用方法 ResultSet.getObject 从列中获取值，则返回构造其实例的 Java 类的完全限定名称。ResultSet.getObject 可能返回此方法所返回的类的子类。 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">column - 第一列是 1，第二个列是 2，…… </span></span><br><span class="line"><span class="comment">返回：</span></span><br><span class="line"><span class="comment">Java 编程语言中类的完全限定名称，方法 ResultSet.getObject 将使用该名称获取指定列中的值。此名称为用于自定义映射关系的类名称。 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      </span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="comment">//将列对应的类完全限定名也加入一个List中</span></span><br><span class="line">      classNames.add(metaData.getColumnClassName(i));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>handleResultSet</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleResultSet</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, List&lt;Object&gt; multipleResults, ResultMapping parentMapping)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//是否有父Mapper</span></span><br><span class="line">     <span class="keyword">if</span> (parentMapping != <span class="keyword">null</span>) &#123;</span><br><span class="line">       handleRowValues(rsw, resultMap, <span class="keyword">null</span>, RowBounds.DEFAULT, parentMapping);</span><br><span class="line">     &#125; </span><br><span class="line">     <span class="comment">//如果没有</span></span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">//且ResultHandler为空，即Method参数列表中没有ResultHandler</span></span><br><span class="line">       <span class="keyword">if</span> (resultHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">//新建一个DefaultResultHandler</span></span><br><span class="line">         DefaultResultHandler defaultResultHandler = <span class="keyword">new</span> DefaultResultHandler(objectFactory);</span><br><span class="line">        <span class="comment">//然后将新的resultHandler注入到handleRowValues中，对结果集进行处理</span></span><br><span class="line">         handleRowValues(rsw, resultMap, defaultResultHandler, rowBounds, <span class="keyword">null</span>);</span><br><span class="line">         multipleResults.add(defaultResultHandler.getResultList());</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         handleRowValues(rsw, resultMap, resultHandler, rowBounds, <span class="keyword">null</span>);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     closeResultSet(rsw.getResultSet()); <span class="comment">// issue #228 (close resultsets)</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>handleRowValues</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleRowValues</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler resultHandler, RowBounds rowBounds, ResultMapping parentMapping)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (resultMap.hasNestedResultMaps()) &#123;</span><br><span class="line">     ensureNoRowBounds();</span><br><span class="line">     checkResultHandler();</span><br><span class="line">     handleRowValuesForNestedResultMap(rsw, resultMap, resultHandler, rowBounds, parentMapping);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     handleRowValuesForSimpleResultMap(rsw, resultMap, resultHandler, rowBounds, parentMapping);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>handleRowValuesForSimpleResultMap</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleRowValuesForSimpleResultMap</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler resultHandler, RowBounds rowBounds, ResultMapping parentMapping)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">//临时存储结果的上下文</span></span><br><span class="line">    DefaultResultContext resultContext = <span class="keyword">new</span> DefaultResultContext();</span><br><span class="line">    <span class="comment">//这个方法与RowBounds有关，目前没有理解这个方法，但是这个方法目前不是特别重要。</span></span><br><span class="line">    skipRows(rsw.getResultSet(), rowBounds);</span><br><span class="line">    <span class="comment">//判断是否需要继续执行</span></span><br><span class="line">    <span class="comment">//shouldProcessMoreRows会去校验上下文的标志位以及行数是否超过RowBounds的限制</span></span><br><span class="line">    <span class="comment">// rsw.getResultSet().next()就很好理解了,看下API的解释就明了了</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    next</span></span><br><span class="line"><span class="comment">boolean next()</span></span><br><span class="line"><span class="comment">             throws SQLException将光标从当前位置向前移一行。ResultSet 光标最初位于第一行之前；第一次调用 next 方法使第一行成为当前行；第二次调用使第二行成为当前行，依此类推。 </span></span><br><span class="line"><span class="comment">当调用 next 方法返回 false 时，光标位于最后一行的后面。任何要求当前行的 ResultSet 方法调用将导致抛出 SQLException。如果结果集的类型是 TYPE_FORWARD_ONLY，则其 JDBC 驱动程序实现对后续 next 调用是返回 false 还是抛出 SQLException 将由供应商指定。 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如果对当前行开启了输入流，则调用 next 方法将隐式关闭它。读取新行时，将清除 ResultSet 对象的警告链。 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">返回：</span></span><br><span class="line"><span class="comment">如果新的当前行有效，则返回 true；如果不存在下一行，则返回 false </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//当执行了rsw.getResultSet().next()后，第一个结果集就出来了</span></span><br><span class="line">    <span class="comment">//控制台新增输出： </span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    &lt;==    Columns: t_id, t_name, address</span></span><br><span class="line"><span class="comment">&lt;==        Row: 1, kobe, los</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span> (shouldProcessMoreRows(resultContext, rowBounds) &amp;&amp; rsw.getResultSet().next()) &#123;</span><br><span class="line">      <span class="comment">//这个方法目前没有深究，但是看到Discriminated我想应该是校验是否在SqlMapper中用到了discriminate把，之后测试了这一情况再来细说</span></span><br><span class="line">      ResultMap discriminatedResultMap = resolveDiscriminatedResultMap(rsw.getResultSet(), resultMap, <span class="keyword">null</span>);</span><br><span class="line">      <span class="comment">//这里终于到了正式处理结果集的时候了，</span></span><br><span class="line">      Object rowValue = getRowValue(rsw, discriminatedResultMap);</span><br><span class="line">      storeObject(resultHandler, resultContext, rowValue, parentMapping, rsw.getResultSet());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>getRowValue(rsw, discriminatedResultMap)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">getRowValue</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ResultLoaderMap lazyLoader = <span class="keyword">new</span> ResultLoaderMap();</span><br><span class="line">  <span class="comment">//创建我们要返回的对象类型，这里是User</span></span><br><span class="line">    Object resultObject = createResultObject(rsw, resultMap, lazyLoader, <span class="keyword">null</span>);</span><br><span class="line">  <span class="comment">// 创建的实例不为空而且也不是基本类型（泛指） </span></span><br><span class="line">  <span class="keyword">if</span> (resultObject != <span class="keyword">null</span> &amp;&amp; !typeHandlerRegistry.hasTypeHandler(resultMap.getType())) &#123;</span><br><span class="line">      <span class="comment">//构造出一个Mybatis自己定义的MetaObject</span></span><br><span class="line">      <span class="keyword">final</span> MetaObject metaObject = configuration.newMetaObject(resultObject);</span><br><span class="line">    <span class="comment">//判断是否有指定构造方法</span></span><br><span class="line">      <span class="keyword">boolean</span> foundValues = resultMap.getConstructorResultMappings().size() &gt; <span class="number">0</span>;</span><br><span class="line"> 	<span class="comment">//判断是否有autoMapping，如果没有执行if下的语句，目前还没有弄清楚autoMapping是什么属性</span></span><br><span class="line">    <span class="keyword">if</span> (shouldApplyAutomaticMappings(resultMap, !AutoMappingBehavior.NONE.equals(configuration.getAutoMappingBehavior()))) &#123;      </span><br><span class="line">      <span class="comment">//处理没有显式用result节点声明的ColumnName</span></span><br><span class="line">        foundValues = applyAutomaticMappings(rsw, resultMap, metaObject, <span class="keyword">null</span>) || foundValues;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">//处理显式使用result节点声明的ColumnName</span></span><br><span class="line">      foundValues = applyPropertyMappings(rsw, resultMap, metaObject, lazyLoader, <span class="keyword">null</span>) || foundValues;</span><br><span class="line">      foundValues = lazyLoader.size() &gt; <span class="number">0</span> || foundValues;</span><br><span class="line">      resultObject = foundValues ? resultObject : <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">return</span> resultObject;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>createResultObject(ResultSetWrapper rsw, ResultMap resultMap, ResultLoaderMap lazyLoader, String</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">createResultObject</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, ResultLoaderMap lazyLoader, String columnPrefix)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> List&lt;Class&lt;?&gt;&gt; constructorArgTypes = <span class="keyword">new</span> ArrayList&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> List&lt;Object&gt; constructorArgs = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">    <span class="keyword">final</span> Object resultObject = createResultObject(rsw, resultMap, constructorArgTypes, constructorArgs, columnPrefix);</span><br><span class="line">  <span class="comment">//创建的实例不为空而且也不是基本类型（泛指）</span></span><br><span class="line">    <span class="keyword">if</span> (resultObject != <span class="keyword">null</span> &amp;&amp; !typeHandlerRegistry.hasTypeHandler(resultMap.getType())) &#123;</span><br><span class="line">      <span class="keyword">final</span> List&lt;ResultMapping&gt; propertyMappings = resultMap.getPropertyResultMappings();</span><br><span class="line">      <span class="comment">//就看下propertyMappings里面是不是带有查询，即select属性</span></span><br><span class="line">	<span class="comment">//propertyMappings 很显然就对应ResultMap节点中的Result节点</span></span><br><span class="line">      <span class="keyword">for</span> (ResultMapping propertyMapping : propertyMappings) &#123;</span><br><span class="line">        <span class="comment">//如果带有select属性而且指定了是懒加载</span></span><br><span class="line">        <span class="keyword">if</span> (propertyMapping.getNestedQueryId() != <span class="keyword">null</span> &amp;&amp; propertyMapping.isLazy()) &#123; <span class="comment">// issue gcode #109 &amp;&amp; issue #149</span></span><br><span class="line">          <span class="comment">//具体这种方式是如何创建的，目前还没有测试过，后续再细说</span></span><br><span class="line">          <span class="keyword">return</span> configuration.getProxyFactory().createProxy(resultObject, lazyLoader, configuration, objectFactory, constructorArgTypes, constructorArgs);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultObject;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>createResultObject</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">createResultObject</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs, String columnPrefix)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">//先得到ResultMap要返回的类型，也就是我们在Mapper文件中对ResultMap配置时的type属性</span></span><br><span class="line">  <span class="keyword">final</span> Class&lt;?&gt; resultType = resultMap.getType();</span><br><span class="line">  <span class="comment">//这个目前测试的都是为null的，看这个命名应该是ResultMap中有指定对应的返回类型的构造方法吧</span></span><br><span class="line">  <span class="keyword">final</span> List&lt;ResultMapping&gt; constructorMappings = resultMap.getConstructorResultMappings();</span><br><span class="line">  <span class="comment">//如果对应的返回类型不是JavaBean或者集合类型等，而是基本类型或者是他的一些包装类和时间日期等类型</span></span><br><span class="line">  <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(resultType)) &#123;</span><br><span class="line">  <span class="comment">//创建基本类型的返回类型的实例</span></span><br><span class="line">    <span class="keyword">return</span> createPrimitiveResultObject(rsw, resultMap, columnPrefix);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果指定了构造方法，使用构造方法来创建实例</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (constructorMappings.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> createParameterizedResultObject(rsw, resultType, constructorMappings, constructorArgTypes, constructorArgs, columnPrefix);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//要不然使用objectFactory来创建实例</span></span><br><span class="line">    <span class="keyword">return</span> objectFactory.create(resultType);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>objectFactory.create(resultType)</strong></p>
<p>DefaultObjectFactory</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> create(type, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(Class&lt;T&gt; type, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; classToCreate = resolveInterface(type);</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="comment">// we know types are assignable</span></span><br><span class="line">    T created = (T) instantiateClass(classToCreate, constructorArgTypes, constructorArgs);</span><br><span class="line">    <span class="keyword">return</span> created;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">instantiateClass</span><span class="params">(Class&lt;T&gt; type, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Constructor&lt;T&gt; constructor;</span><br><span class="line">      <span class="comment">//如果没有在ResultMap中指定构造方法,Mybatis默认该类只有默认的无参构造方法</span></span><br><span class="line">      <span class="keyword">if</span> (constructorArgTypes == <span class="keyword">null</span> || constructorArgs == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        getDeclaredConstructor</span></span><br><span class="line"><span class="comment">public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</span></span><br><span class="line"><span class="comment">                                      throws NoSuchMethodException,</span></span><br><span class="line"><span class="comment">                                             SecurityException返回一个 Constructor 对象，该对象反映此 Class 对象所表示的类或接口的指定构造方法。parameterTypes 参数是 Class 对象的一个数组，它按声明顺序标识构造方法的形参类型。 如果此 Class 对象表示非静态上下文中声明的内部类，则形参类型作为第一个参数包括显示封闭的实例。 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">parameterTypes - 参数数组 </span></span><br><span class="line"><span class="comment">返回：</span></span><br><span class="line"><span class="comment">带有指定参数列表的构造方法的 Constructor 对象 </span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//这里调用该方法时没有指定参数，意思即试图返回该类的无参构造方法，如果没有无参构造方法，就会抛出异常，然后再后面的catch住，后抛出给用户</span></span><br><span class="line">        constructor = type.getDeclaredConstructor();</span><br><span class="line">        <span class="keyword">if</span> (!constructor.isAccessible()) &#123;</span><br><span class="line">          constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果存在无参构造方法，就直接创建一个实例且返回</span></span><br><span class="line">        <span class="keyword">return</span> constructor.newInstance();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果有指定构造方法，试图返回相应的有参构造方法，如果失败，抛出异常后catch住重新抛出给用户</span></span><br><span class="line">      constructor = type.getDeclaredConstructor(constructorArgTypes.toArray(<span class="keyword">new</span> Class[constructorArgTypes.size()]));</span><br><span class="line">      <span class="keyword">if</span> (!constructor.isAccessible()) &#123;</span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> constructor.newInstance(constructorArgs.toArray(<span class="keyword">new</span> Object[constructorArgs.size()]));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      StringBuilder argTypes = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">      <span class="keyword">if</span> (constructorArgTypes != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; argType : constructorArgTypes) &#123;</span><br><span class="line">          argTypes.append(argType.getSimpleName());</span><br><span class="line">          argTypes.append(<span class="string">","</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      StringBuilder argValues = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">      <span class="keyword">if</span> (constructorArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object argValue : constructorArgs) &#123;</span><br><span class="line">          argValues.append(String.valueOf(argValue));</span><br><span class="line">          argValues.append(<span class="string">","</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ReflectionException(<span class="string">"Error instantiating "</span> + type + <span class="string">" with invalid types ("</span> + argTypes + <span class="string">") or values ("</span> + argValues + <span class="string">"). Cause: "</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>当我们分析完这段代码的时候，我们就可以很清楚的知道为什么当我们没有在ResultMap中显式的指定构造方法时，如果我们对我们的JavaBean创建了一个有参构造方法而此时没有显式的给出无参构造方法，这时运行程序，就会抛出Error instantiating异常。</p>
<p>有些同学可能会觉得看源码的用处不大，甚至是浪费时间，但是我不这样觉得，看源码还是有很多好处的。</p>
<p>1、看源码我们可以学习框架的设计思想，学习设计模式。</p>
<p>2、看源码可以加深对JDK API的认识，再复杂的代码都是基于JDK API写出来的，对JDK API的熟悉度会一定程度决定你的编码质量。</p>
<p>3、看源码虽然确实很花时间，但是看了源码之后我们才真正的做到了知其然，也知其所以然，这是一个热爱的代码，热爱编程了必须要有的专研精神，看了源码，我们就知道了，这个框架到底为什么要这样用，为什么那样配置就不对，为什么会报这个错误，这样我们才能利用用框架工具，而不是被框架牵着走。</p>
<p>啰嗦完了，继续往下看。</p>
<p><strong>configuration.newMetaObject(resultObject)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MetaObject <span class="title">newMetaObject</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> MetaObject.forObject(object, objectFactory, objectWrapperFactory);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MetaObject <span class="title">forObject</span><span class="params">(Object object, ObjectFactory objectFactory, ObjectWrapperFactory objectWrapperFactory)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> SystemMetaObject.NULL_META_OBJECT;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> MetaObject(object, objectFactory, objectWrapperFactory);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="title">MetaObject</span><span class="params">(Object object, ObjectFactory objectFactory, ObjectWrapperFactory objectWrapperFactory)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.originalObject = object;</span><br><span class="line">   <span class="keyword">this</span>.objectFactory = objectFactory;</span><br><span class="line">   <span class="keyword">this</span>.objectWrapperFactory = objectWrapperFactory;</span><br><span class="line"><span class="comment">//如果object已经是封装过的ObjectWarpper,就不需要再封装了，直接转化为ObjectWarpper类型就好了</span></span><br><span class="line">   <span class="keyword">if</span> (object <span class="keyword">instanceof</span> ObjectWrapper) &#123;</span><br><span class="line">     <span class="keyword">this</span>.objectWrapper = (ObjectWrapper) object;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果是已经封装了，去Factory里取</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (objectWrapperFactory.hasWrapperFor(object)) &#123;</span><br><span class="line">     <span class="keyword">this</span>.objectWrapper = objectWrapperFactory.getWrapperFor(<span class="keyword">this</span>, object);</span><br><span class="line">   &#125; </span><br><span class="line">   <span class="comment">//如果是Map类型，创建一个MapWrapper</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (object <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">     <span class="keyword">this</span>.objectWrapper = <span class="keyword">new</span> MapWrapper(<span class="keyword">this</span>, (Map) object);</span><br><span class="line">   &#125; </span><br><span class="line">   <span class="comment">//如果是Collection类型，一定要注意哦，Collection和Map是平级的哦，Map可不属于Collection</span></span><br><span class="line">   <span class="comment">//Collection下面有List Set等</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (object <span class="keyword">instanceof</span> Collection) &#123;</span><br><span class="line">     <span class="keyword">this</span>.objectWrapper = <span class="keyword">new</span> CollectionWrapper(<span class="keyword">this</span>, (Collection) object);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">//否则创建一个JavaBean 普通Java对象的包装类</span></span><br><span class="line">     <span class="keyword">this</span>.objectWrapper = <span class="keyword">new</span> BeanWrapper(<span class="keyword">this</span>, object);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>BeanWarpper的创建</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BeanWrapper</span><span class="params">(MetaObject metaObject, Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(metaObject);</span><br><span class="line">    <span class="keyword">this</span>.object = object;</span><br><span class="line">    <span class="keyword">this</span>.metaClass = MetaClass.forClass(object.getClass());</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MetaClass <span class="title">forClass</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MetaClass(type);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">MetaClass</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.reflector = Reflector.forClass(type);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>this.reflector = Reflector.forClass(type);</p>
<p>这里的reflector是MetaClass的一个属性对应的类是Reflector,是Mybatis处理反射最重要的类。</p>
<p>Reflector</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Reflector <span class="title">forClass</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (classCacheEnabled) &#123;</span><br><span class="line">      <span class="comment">// synchronized (clazz) removed see issue #461</span></span><br><span class="line">      Reflector cached = REFLECTOR_MAP.get(clazz);</span><br><span class="line">      <span class="keyword">if</span> (cached == <span class="keyword">null</span>) &#123;</span><br><span class="line">        cached = <span class="keyword">new</span> Reflector(clazz);</span><br><span class="line">        REFLECTOR_MAP.put(clazz, cached);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> cached;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Reflector(clazz);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="title">Reflector</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">    type = clazz;</span><br><span class="line">   <span class="comment">//添加默认的无参构造方法</span></span><br><span class="line">    addDefaultConstructor(clazz);</span><br><span class="line">   <span class="comment">//添加Get方法 </span></span><br><span class="line">   addGetMethods(clazz);</span><br><span class="line">   <span class="comment">//添加Set方法 </span></span><br><span class="line">   addSetMethods(clazz);</span><br><span class="line">   <span class="comment">//添加Field属性 </span></span><br><span class="line">   addFields(clazz);</span><br><span class="line">    readablePropertyNames = getMethods.keySet().toArray(<span class="keyword">new</span> String[getMethods.keySet().size()]);</span><br><span class="line">    writeablePropertyNames = setMethods.keySet().toArray(<span class="keyword">new</span> String[setMethods.keySet().size()]);</span><br><span class="line">   <span class="comment">//下面的两个put元素的操作是很重要的，我们看到他们把对应的PropertyName的大写作为Key,</span></span><br><span class="line">   <span class="comment">//把PropertyName作为Value存入这个HashMap中</span></span><br><span class="line">    <span class="keyword">for</span> (String propName : readablePropertyNames) &#123;</span><br><span class="line">      caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (String propName : writeablePropertyNames) &#123;</span><br><span class="line">      caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>applyAutomaticMappings</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">applyAutomaticMappings</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, MetaObject metaObject, String columnPrefix)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">//得到没有显式声明的ColumnName 的 List</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;String&gt; unmappedColumnNames = rsw.getUnmappedColumnNames(resultMap, columnPrefix);</span><br><span class="line">    <span class="keyword">boolean</span> foundValues = <span class="keyword">false</span>;</span><br><span class="line">  <span class="comment">//后续的赋值操作比较简单，就不详细分析了</span></span><br><span class="line">    <span class="keyword">for</span> (String columnName : unmappedColumnNames) &#123;</span><br><span class="line">      String propertyName = columnName;</span><br><span class="line">      <span class="keyword">if</span> (columnPrefix != <span class="keyword">null</span> &amp;&amp; columnPrefix.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// When columnPrefix is specified,</span></span><br><span class="line">        <span class="comment">// ignore columns without the prefix.</span></span><br><span class="line">        <span class="keyword">if</span> (columnName.toUpperCase(Locale.ENGLISH).startsWith(columnPrefix)) &#123;</span><br><span class="line">          propertyName = columnName.substring(columnPrefix.length());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//对这句代码还是有必要分析一下的，因为这里就是驼峰命名可以不显式声明ColumnName的原因所在</span></span><br><span class="line">      <span class="keyword">final</span> String property = metaObject.findProperty(propertyName, configuration.isMapUnderscoreToCamelCase());</span><br><span class="line">      <span class="keyword">if</span> (property != <span class="keyword">null</span> &amp;&amp; metaObject.hasSetter(property)) &#123;</span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt; propertyType = metaObject.getSetterType(property);</span><br><span class="line">        <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(propertyType)) &#123;</span><br><span class="line">          <span class="keyword">final</span> TypeHandler&lt;?&gt; typeHandler = rsw.getTypeHandler(propertyType, columnName);</span><br><span class="line">          <span class="keyword">final</span> Object value = typeHandler.getResult(rsw.getResultSet(), columnName);</span><br><span class="line">          <span class="keyword">if</span> (value != <span class="keyword">null</span> || configuration.isCallSettersOnNulls()) &#123; <span class="comment">// issue #377, call setter on nulls</span></span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span> || !propertyType.isPrimitive()) &#123;</span><br><span class="line">              metaObject.setValue(property, value);</span><br><span class="line">            &#125;</span><br><span class="line">            foundValues = <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> foundValues;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>getUnmappedColumnNames</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getUnmappedColumnNames</span><span class="params">(ResultMap resultMap, String columnPrefix)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">   List&lt;String&gt; unMappedColumnNames = unMappedColumnNamesMap.get(getMapKey(resultMap, columnPrefix));</span><br><span class="line">   <span class="keyword">if</span> (unMappedColumnNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">     loadMappedAndUnmappedColumnNames(resultMap, columnPrefix);</span><br><span class="line">     unMappedColumnNames = unMappedColumnNamesMap.get(getMapKey(resultMap, columnPrefix));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> unMappedColumnNames;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadMappedAndUnmappedColumnNames</span><span class="params">(ResultMap resultMap, String columnPrefix)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">   List&lt;String&gt; mappedColumnNames = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">   List&lt;String&gt; unmappedColumnNames = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">   <span class="keyword">final</span> String upperColumnPrefix = columnPrefix == <span class="keyword">null</span> ? <span class="keyword">null</span> : columnPrefix.toUpperCase(Locale.ENGLISH);</span><br><span class="line">   <span class="keyword">final</span> Set&lt;String&gt; mappedColumns = prependPrefixes(resultMap.getMappedColumns(), upperColumnPrefix);</span><br><span class="line">   <span class="keyword">for</span> (String columnName : columnNames) &#123;</span><br><span class="line">     <span class="keyword">final</span> String upperColumnName = columnName.toUpperCase(Locale.ENGLISH);</span><br><span class="line">     <span class="keyword">if</span> (mappedColumns.contains(upperColumnName)) &#123;</span><br><span class="line">       mappedColumnNames.add(upperColumnName);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       unmappedColumnNames.add(columnName);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   mappedColumnNamesMap.put(getMapKey(resultMap, columnPrefix), mappedColumnNames);</span><br><span class="line">   unMappedColumnNamesMap.put(getMapKey(resultMap, columnPrefix), unmappedColumnNames);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>loadMappedAndUnmappedColumnNames这个方法将没有显式的在ResultMap节点中的Result节点声明的property和显式声明的property分别存到unmappedColumnNames和unmappedColumnNames中。</p>
<p><strong>findProperty(propertyName, configuration.isMapUnderscoreToCamelCase())</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">final</span> String property = metaObject.findProperty(propertyName, configuration.isMapUnderscoreToCamelCase()); </span><br><span class="line"><span class="comment">//如果设置了数据库列名使用驼峰命名可以不用显式声明result，会把列名的下划线去掉，使其与JavaBean 属性名相同</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">findProperty</span><span class="params">(String name, <span class="keyword">boolean</span> useCamelCaseMapping)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (useCamelCaseMapping) &#123;</span><br><span class="line">      name = name.replace(<span class="string">"_"</span>, <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> findProperty(name);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>如果设置了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;setting name=<span class="string">"mapUnderscoreToCamelCase"</span> value=<span class="string">"true"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>上述的useCamelCaseMapping就是true了</p>
<p><strong>applyPropertyMappings</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">applyPropertyMappings</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, MetaObject metaObject, ResultLoaderMap lazyLoader, String columnPrefix)</span></span></span><br><span class="line"><span class="function">     <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> List&lt;String&gt; mappedColumnNames = rsw.getMappedColumnNames(resultMap, columnPrefix);</span><br><span class="line">   <span class="keyword">boolean</span> foundValues = <span class="keyword">false</span>;</span><br><span class="line">   <span class="keyword">final</span> List&lt;ResultMapping&gt; propertyMappings = resultMap.getPropertyResultMappings();</span><br><span class="line">   <span class="keyword">for</span> (ResultMapping propertyMapping : propertyMappings) &#123;</span><br><span class="line">     <span class="keyword">final</span> String column = prependPrefix(propertyMapping.getColumn(), columnPrefix);</span><br><span class="line">     <span class="keyword">if</span> (propertyMapping.isCompositeResult() </span><br><span class="line">         || (column != <span class="keyword">null</span> &amp;&amp; mappedColumnNames.contains(column.toUpperCase(Locale.ENGLISH))) </span><br><span class="line">         || propertyMapping.getResultSet() != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">//我们主要需要看的是这个方法的具体实现，其他的都比较好理解，</span></span><br><span class="line">       Object value = getPropertyMappingValue(rsw.getResultSet(), metaObject, propertyMapping, lazyLoader, columnPrefix);</span><br><span class="line">       <span class="keyword">final</span> String property = propertyMapping.getProperty(); <span class="comment">// issue #541 make property optional</span></span><br><span class="line">       <span class="keyword">if</span> (value != NO_VALUE &amp;&amp; property != <span class="keyword">null</span> &amp;&amp; (value != <span class="keyword">null</span> || configuration.isCallSettersOnNulls())) &#123; <span class="comment">// issue #377, call setter on nulls</span></span><br><span class="line">         <span class="keyword">if</span> (value != <span class="keyword">null</span> || !metaObject.getSetterType(property).isPrimitive()) &#123;</span><br><span class="line">           metaObject.setValue(property, value);</span><br><span class="line">         &#125;</span><br><span class="line">         foundValues = <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> foundValues;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>getPropertyMappingValue</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">getPropertyMappingValue</span><span class="params">(ResultSet rs, MetaObject metaResultObject, ResultMapping propertyMapping, ResultLoaderMap lazyLoader, String columnPrefix)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">//如果result节点中select属性存在</span></span><br><span class="line">  <span class="keyword">if</span> (propertyMapping.getNestedQueryId() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//在本次查询中是不会用到这个方法的，因为result节点中并没有</span></span><br><span class="line">    <span class="keyword">return</span> getNestedQueryMappingValue(rs, metaResultObject, propertyMapping, lazyLoader, columnPrefix);</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">//这一分支应该是这个select属性对应的查询结果ResultMap中的result节点依然有select属性，当然目前还没有验证</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (propertyMapping.getResultSet() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    addPendingChildRelation(rs, metaResultObject, propertyMapping);</span><br><span class="line">    <span class="keyword">return</span> NO_VALUE;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propertyMapping.getNestedResultMapId() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// the user added a column attribute to a nested result map, ignore it</span></span><br><span class="line">    <span class="keyword">return</span> NO_VALUE;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> TypeHandler&lt;?&gt; typeHandler = propertyMapping.getTypeHandler();</span><br><span class="line">    <span class="keyword">final</span> String column = prependPrefix(propertyMapping.getColumn(), columnPrefix);</span><br><span class="line">    <span class="keyword">return</span> typeHandler.getResult(rs, column);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们的ResultMap是这样的</p>
<p>。。。待补充</p>
<p>那么就会用到这个方法</p>
<p><strong>getNestedQueryMappingValue</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">getNestedQueryMappingValue</span><span class="params">(ResultSet rs, MetaObject metaResultObject, ResultMapping propertyMapping, ResultLoaderMap lazyLoader, String columnPrefix)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String nestedQueryId = propertyMapping.getNestedQueryId();</span><br><span class="line">    <span class="keyword">final</span> String property = propertyMapping.getProperty();</span><br><span class="line">    <span class="keyword">final</span> MappedStatement nestedQuery = configuration.getMappedStatement(nestedQueryId);</span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; nestedQueryParameterType = nestedQuery.getParameterMap().getType();</span><br><span class="line">  <span class="comment">//得到该result节点对应column的值，这个值将作为select对应的select Mapper的参数传入  </span></span><br><span class="line">  <span class="keyword">final</span> Object nestedQueryParameterObject = prepareParameterForNestedQuery(rs, propertyMapping, nestedQueryParameterType, columnPrefix);</span><br><span class="line">    Object value = NO_VALUE;</span><br><span class="line">    <span class="keyword">if</span> (nestedQueryParameterObject != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">final</span> BoundSql nestedBoundSql = nestedQuery.getBoundSql(nestedQueryParameterObject);</span><br><span class="line">      <span class="keyword">final</span> CacheKey key = executor.createCacheKey(nestedQuery, nestedQueryParameterObject, RowBounds.DEFAULT, nestedBoundSql);</span><br><span class="line">      <span class="comment">//ofType  如果没有指定ofType,应该会取selct Mapper中对应的ResultMap Type把，这个做实验就知道会不会这样取了</span></span><br><span class="line">      <span class="keyword">final</span> Class&lt;?&gt; targetType = propertyMapping.getJavaType();</span><br><span class="line">      <span class="keyword">if</span> (executor.isCached(nestedQuery, key)) &#123;</span><br><span class="line">        executor.deferLoad(nestedQuery, metaResultObject, property, key, targetType);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> ResultLoader resultLoader = <span class="keyword">new</span> ResultLoader(configuration, executor, nestedQuery, nestedQueryParameterObject, targetType, key, nestedBoundSql);</span><br><span class="line">        <span class="comment">//如果是懒加载，不要立即查出结果，先缓存</span></span><br><span class="line">        <span class="keyword">if</span> (propertyMapping.isLazy()) &#123;</span><br><span class="line">          lazyLoader.addLoader(property, metaResultObject, resultLoader);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//执行查询，得到结果</span></span><br><span class="line">          value = resultLoader.loadResult();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>loadResult</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">loadResult</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">//selectList并不难理解</span></span><br><span class="line">   List&lt;Object&gt; list = selectList();</span><br><span class="line">  <span class="comment">//extractObjectFromList就是转化下返回的类型</span></span><br><span class="line">   resultObject = resultExtractor.extractObjectFromList(list, targetType);</span><br><span class="line">   <span class="keyword">return</span> resultObject;</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="keyword">private</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">   Executor localExecutor = executor;</span><br><span class="line">   <span class="keyword">if</span> (Thread.currentThread().getId() != <span class="keyword">this</span>.creatorThreadId || localExecutor.isClosed()) &#123;</span><br><span class="line">     localExecutor = newExecutor();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> localExecutor.&lt;E&gt; query(mappedStatement, parameterObject, RowBounds.DEFAULT, Executor.NO_RESULT_HANDLER, cacheKey, boundSql);</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (localExecutor != executor) &#123;</span><br><span class="line">       localExecutor.close(<span class="keyword">false</span>);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>extractObjectFromList</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">extractObjectFromList</span><span class="params">(List&lt;Object&gt; list, Class&lt;?&gt; targetType)</span> </span>&#123;</span><br><span class="line">    Object value = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (targetType != <span class="keyword">null</span> &amp;&amp; targetType.isAssignableFrom(list.getClass())) &#123;</span><br><span class="line">      value = list;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetType != <span class="keyword">null</span> &amp;&amp; objectFactory.isCollection(targetType)) &#123;</span><br><span class="line">      value = objectFactory.create(targetType);</span><br><span class="line">      MetaObject metaObject = configuration.newMetaObject(value);</span><br><span class="line">      metaObject.addAll(list);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetType != <span class="keyword">null</span> &amp;&amp; targetType.isArray()) &#123;</span><br><span class="line">      Class&lt;?&gt; arrayComponentType = targetType.getComponentType();</span><br><span class="line">      Object array = Array.newInstance(arrayComponentType, list.size());</span><br><span class="line">      <span class="keyword">if</span> (arrayComponentType.isPrimitive()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">          Array.set(array, i, list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        value = array;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        value = list.toArray((Object[])array);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Statement returned more than one row, where no more than one was expected."</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.size() == <span class="number">1</span>) &#123;</span><br><span class="line">        value = list.get(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>到这里对ResultSetHandler的讲解就稍微告一段落了</p>
<p>目前还有MapKey(差实验)，鉴别器（），缓存，懒加载还没有讲到。</p>
<p>ResultSetHandler是Mybatis最复杂的一部分，它对应着ResultMap的处理，而ResultMap的配置也是配置文件中最难的。</p>
<p>在这里再说下我之前的一个疑问，也是自己对泛型没有很好的理解到位。</p>
<p>当我第一次看到这段代码时</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    PreparedStatement ps = (PreparedStatement) statement;</span><br><span class="line">    ps.execute();</span><br><span class="line">    <span class="keyword">return</span> resultSetHandler.&lt;E&gt; handleResultSets(ps);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>我对这行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> resultSetHandler.&lt;E&gt; handleResultSets(ps);</span><br></pre></td></tr></table></figure>
<p>是蛮疑惑的，resultSetHandler.\<e> handleResultSets(ps);</e></p>
<p>这种在调用方法前使用泛型的，代表这个方法肯定是泛型方法，否则肯定是不能这样用的。</p>
<p>但是我们发现在DefaultResultSetHandler中这个方法的返回类型是List\<object>,并不是一个泛型方法呀？</object></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">handleResultSets</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>但是依然在返回给我们结果的时候进行了强制的类型转化，也就是实现了泛型方法的效果。</p>
<p>这是为什么呢？在一开始我是十分想不通的。</p>
<p>当然在ResultSetHandler接口中，这是一个泛型方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">handleResultSets</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException</span>;</span><br></pre></td></tr></table></figure>
<p>这说明实现了这个接口的方法，即使在实现类指定了某个具体的类型，还是具有泛型方法的特性的，还是会被当做泛型方法的。</p>
<p>至于为什么会这样，我的理解是，只要实现的方法是泛型方法，即使实现类里明确指定了特定的返回类型，依然会在编译时期，完成类型的强制转化，依然是具有泛型方法特性的。</p>
<p>最后，我们举个例子来验证一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wangcc.MyJavaSE.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResultSetHandler</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">handleResultSets</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultResultSetHandler</span> <span class="keyword">implements</span> <span class="title">ResultSetHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">handleResultSets</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">		list.add(<span class="string">"Kobe"</span>);</span><br><span class="line">		list.add(<span class="string">"james"</span>);</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		ResultSetHandler resultSetHandler = <span class="keyword">new</span> DefaultResultSetHandler();</span><br><span class="line">		List&lt;String&gt; list = resultSetHandler.&lt;String&gt;handleResultSets();</span><br><span class="line">		<span class="keyword">for</span> (String str : list) &#123;</span><br><span class="line">			System.out.println(str);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个测试类是可以正常运行的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2017/11/26/ResultSetHandler/" data-id="cjagxqj7t0000jgbzuk47h3az" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ParameterHandler" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/26/ParameterHandler/" class="article-date">
  <time datetime="2017-11-26T08:57:18.135Z" itemprop="datePublished">2017-11-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Mybatis/">Mybatis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/26/ParameterHandler/">ParameterHandler</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="ParameterHandler介绍"><a href="#ParameterHandler介绍" class="headerlink" title="ParameterHandler介绍"></a>ParameterHandler介绍</h3><p>ParameterHandler是用来设置参数规则的。当StatementHandler使用prepare()方法后，接下来就是使用它来设置参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ParameterHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">Object <span class="title">getParameterObject</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setParameters</span><span class="params">(PreparedStatement ps)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个接口只定义了两个方法，其中setParameters方法是设置参数的，getParameterObject是获取参数的。</p>
<p>而且这个接口目前只有一个实现类DefaultParameterHandler。</p>
<h3 id="setParameters方法的具体实现"><a href="#setParameters方法的具体实现" class="headerlink" title="setParameters方法的具体实现"></a>setParameters方法的具体实现</h3><p>我们接着下一篇分析的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Statement <span class="title">prepareStatement</span><span class="params">(StatementHandler handler, Log statementLog)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt;</span><br><span class="line">  <span class="comment">//得到JDBC Connection</span></span><br><span class="line">    Connection connection = getConnection(statementLog);</span><br><span class="line">  <span class="comment">//这里就要到了上面说到的StatementHandler的一个重要方法perpare方法，用来预编译sql</span></span><br><span class="line">  stmt = handler.prepare(connection);</span><br><span class="line">  <span class="comment">//调用了paramterize方法</span></span><br><span class="line">    handler.parameterize(stmt);</span><br><span class="line">    <span class="keyword">return</span> stmt;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parameterize</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    delegate.parameterize(statement);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里的delegate属性是PrepareStatementHandler</p>
<p>所以调用的是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parameterize</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  parameterHandler.setParameters((PreparedStatement) statement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>parameterHandler在初始化PrepareStatementHandler对象时就在调用其父类BaseStatementHandler构造方法时就已经初始化了，对应一个DefaultParameterHandler实例。</p>
<p>好了，我们终于可以好好分析一下setParameters方法了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParameters</span><span class="params">(PreparedStatement ps)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ErrorContext.instance().activity(<span class="string">"setting parameters"</span>).object(mappedStatement.getParameterMap().getId());</span><br><span class="line">   <span class="comment">// parameterMappings  是对#&#123;&#125; 里给出的参数信息的封装，即这个SQL是个参数化SQL（SQL语句中带占位符?）时会存在</span></span><br><span class="line">    List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">   <span class="comment">//如果是参数化SQL，便要设置参数</span></span><br><span class="line">   <span class="keyword">if</span> (parameterMappings != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterMappings.size(); i++) &#123;</span><br><span class="line">        ParameterMapping parameterMapping = parameterMappings.get(i);</span><br><span class="line">        <span class="comment">//如果参数的类型不是OUT类型，CallableStatementHandler会用到</span></span><br><span class="line">        <span class="comment">//因为存储过程才存在输出参数，所以当参数不是输出参数的时候，就需要设置</span></span><br><span class="line">        <span class="keyword">if</span> (parameterMapping.getMode() != ParameterMode.OUT) &#123;</span><br><span class="line">          Object value;</span><br><span class="line">          <span class="comment">//在本次查询中，对应的不是一个Bean，对应的是一个additionalParameters Map对象，所以这里的property不是Bean的属性，而是经过封装的Key（可以通过Key找到对应的Value,该Value就是我们要找的值）</span></span><br><span class="line">         <span class="comment">//如果是Bean 则通过属性的反射来得到Value</span></span><br><span class="line">          String propertyName = parameterMapping.getProperty();</span><br><span class="line">          <span class="comment">//如果propertyName是additionalParameters中的key</span></span><br><span class="line">          <span class="keyword">if</span> (boundSql.hasAdditionalParameter(propertyName)) &#123; <span class="comment">// issue #448 ask first for additional params</span></span><br><span class="line">            <span class="comment">//通过Key来得到Map中的Value</span></span><br><span class="line">            value = boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">          &#125;<span class="comment">//如果不是additionalParameters中的Key，而且传入参数是null，那value就为null</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (parameterObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">            value = <span class="keyword">null</span>;</span><br><span class="line">          &#125; </span><br><span class="line">          <span class="comment">//如果在typeHandlerRegistry中已经注册了这个参数的Class对象，即他是Primitive类型或者是String ByteArray 等等 26个类型 也就是说不是JavaBean 也不是Map List类型时。value直接等于Method传进来的参数</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">            value = parameterObject;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//否则就是Map（Method穿进行的原始参数是List类型或者是Array类型时，这时已经被封装成了Map类型了）类型或者是Bean 通过封装的MataObject对象，用propertyName得到相应的Value,Bean通过反射得到，Map类型则是通过Key得到Value</span></span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            MetaObject metaObject = configuration.newMetaObject(parameterObject);</span><br><span class="line">            value = metaObject.getValue(propertyName);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//在通过SqlSource的parse方法得到paramterMappings的具体实现中，我们会得到parameterMapping的TypeHandler</span></span><br><span class="line">		<span class="comment">//本次查询中TypeHandler均为IntegerTypeHandler          </span></span><br><span class="line">          TypeHandler typeHandler = parameterMapping.getTypeHandler();</span><br><span class="line">          <span class="comment">//得到相应parameterMapping的JdbcType,如果没有在#&#123;&#125;中显式的指定JdbcType，则为null</span></span><br><span class="line">          JdbcType jdbcType = parameterMapping.getJdbcType();</span><br><span class="line">          <span class="comment">//如果得到的value为null并且jdbcType也是null的时候，jdbcType就会成为configuration.getJdbcTypeForNull();  即OTHER，所以我们在编写Mapper配置文件的Insert或者Update类型的SqlMapper时，如果某个#&#123;propertyName&#125;对应的Value是null的话，插入数据库是会报错的，</span></span><br><span class="line"><span class="comment">// 因为此时的JdbcType是Other,执行setNull时会报错，</span></span><br><span class="line">          </span><br><span class="line">       <span class="comment">//java.sql.SQLException: 无效的列类型: 1111 </span></span><br><span class="line">          <span class="comment">//1111 就是OTHER对应的sqlType</span></span><br><span class="line">         <span class="comment">// 所以Value为null的情况下，我们需要指定JdbcType</span></span><br><span class="line">          <span class="keyword">if</span> (value == <span class="keyword">null</span> &amp;&amp; jdbcType == <span class="keyword">null</span>) jdbcType = configuration.getJdbcTypeForNull();</span><br><span class="line">          <span class="comment">//这一行实现了具体的ps.set***</span></span><br><span class="line">          typeHandler.setParameter(ps, i + <span class="number">1</span>, value, jdbcType);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>daga</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeHandler.setParameter(ps, i + <span class="number">1</span>, value, jdbcType);</span><br></pre></td></tr></table></figure>
<p>BaseTypeHandler是IntegerTypeHandler和其他TypeHandler的父类</p>
<p>其中setParameter就是在BaseTypeHandler中实现的，这个设计依然采用了模板设计模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParameter</span><span class="params">(PreparedStatement ps, <span class="keyword">int</span> i, T parameter, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">//当传入的参数是null时</span></span><br><span class="line">    <span class="keyword">if</span> (parameter == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (jdbcType == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TypeException(<span class="string">"JDBC requires that the JdbcType must be specified for all nullable parameters."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//执行PreparedStatement的setNull方法</span></span><br><span class="line">        ps.setNull(i, jdbcType.TYPE_CODE);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TypeException(<span class="string">"Error setting null for parameter #"</span> + i + <span class="string">" with JdbcType "</span> + jdbcType + <span class="string">" . "</span> +</span><br><span class="line">        		<span class="string">"Try setting a different JdbcType for this parameter or a different jdbcTypeForNull configuration property. "</span> +</span><br><span class="line">        		<span class="string">"Cause: "</span> + e, e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//如果value不是null，则进行参数设置，这是个抽象方法，具体的实现在子类中</span></span><br><span class="line">      setNonNullParameter(ps, i, parameter, jdbcType);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>ps.setNull</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">setNull</span><br><span class="line">void setNull(int parameterIndex,</span><br><span class="line">             int sqlType)</span><br><span class="line">             throws SQLException将指定参数设置为 SQL NULL。 </span><br><span class="line">注：必须指定参数的 SQL 类型。 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">parameterIndex - 第一个参数是 1，第二个参数是 2，……</span><br><span class="line">sqlType - java.sql.Types 中定义的 SQL 类型代码 </span><br><span class="line">抛出： </span><br><span class="line">SQLException - 如果 parameterIndex 不对应于 SQL 语句中的参数标记；如果发生数据库访问错误，或者在关闭的 PreparedStatement 上调用此方法 </span><br><span class="line">SQLFeatureNotSupportedException - 如果 sqlType 是 ARRAY、BLOB、CLOB、DATALINK、JAVA_OBJECT、NCHAR、NCLOB、NVARCHAR、LONGNVARCHAR、REF、ROWID、SQLXML 或 STRUCT 数据类型之一并且 JDBC 驱动程序不支持此数据类型</span><br></pre></td></tr></table></figure>
<p>当SQL类型代码为1111(OTHER)时，就会出现报错：java.sql.SQLException: 无效的列类型: 1111 </p>
<p>此时就需要在#{}设置JdbcType。<br>IntegerTypeHandler中的setNonNullParameter方法具体实现，很简单</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public void setNonNullParameter(PreparedStatement ps, int i, Integer parameter, JdbcType jdbcType)</span><br><span class="line">      throws SQLException &#123;</span><br><span class="line">    ps.setInt(i, parameter);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2017/11/26/ParameterHandler/" data-id="cjagxkvwt000118bzsdm2bzo8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-StatementHandler" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/26/StatementHandler/" class="article-date">
  <time datetime="2017-11-26T08:57:18.134Z" itemprop="datePublished">2017-11-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Mybatis/">Mybatis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/26/StatementHandler/">StatementHandler</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>我们接着看四大组件的StatementHandler。</p>
<p>首先还是来看代码</p>
<p>接上一篇末尾</p>
<p>SimpleExecutor的doQuery</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Configuration configuration = ms.getConfiguration();</span><br><span class="line">    <span class="comment">//在这里初始化了除了Excutor的其他三大组件，注意了，这行代码完成的工作很重要，而Executor对象则在初始化得到DefaultSqlSession对象的时候就已经注入到其中了。</span></span><br><span class="line">    StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">    <span class="keyword">return</span> handler.&lt;E&gt;query(stmt, resultHandler);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    closeStatement(stmt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码我们已经知道初始化StatementHandler的时机了，那么下面我们就来看看StatementHandler的构造以及具体实现吧。</p>
<h3 id="StatementHandler介绍"><a href="#StatementHandler介绍" class="headerlink" title="StatementHandler介绍"></a>StatementHandler介绍</h3><p>先看看接口的组成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StatementHandler</span> </span>&#123;</span><br><span class="line"><span class="comment">//prepare方法是用来编译SQL的</span></span><br><span class="line">  <span class="function">Statement <span class="title">prepare</span><span class="params">(Connection connection)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="comment">//设置参数化Sql ps.setParameter()</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">parameterize</span><span class="params">(Statement statement)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">batch</span><span class="params">(Statement statement)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(Statement statement)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="function">BoundSql <span class="title">getBoundSql</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">ParameterHandler <span class="title">getParameterHandler</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有几个重要的方法，prepare,parameterize和query，update，他们的作用是不一样的。</p>
<p>在MyBatis实现了statementHandler的有四个类：</p>
<p>RoutingStatementHandler，这是一个封装类，它不提供具体的实现，只是根据Executor的类型，创建不同的类型StatementHandler。</p>
<p>SimpleStatementHandler，这个类对应于JDBC的Statement对象，用于没有预编译参数的SQL的运行。</p>
<p>PreparedStatementHandler 这个用于预编译参数SQL的运行。</p>
<p>CallableStatementHandler 它将实存储过程的调度。</p>
<p>在MyBatis中，Configuration对象会采用new RoutingStatementHandler()来生成StatementHandler对象，换句话说我们真正使用的是RoutingStatementHandler对象，然后它会根据Executor的类型去创建对应具体的statementHandler对象（SimpleStatementHandler，PreparedStatementHandler和CallableStatementHandler）。</p>
<p><strong>然后利用具体statementHandler的方法完成所需要的功能。那么这个具体的statementHandler是保存在RoutingStatementHandler对象的delegate属性的，所以当我们拦截statementHandler的时候就要常常访问它了。</strong></p>
<h3 id="StatementHandler的初始化"><a href="#StatementHandler的初始化" class="headerlink" title="StatementHandler的初始化"></a>StatementHandler的初始化</h3><p>很明显从上述代码中可以看出，StatementHandler是通过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br></pre></td></tr></table></figure>
<p>初始化的。</p>
<p>那我们就来看看这行代码的具体实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StatementHandler <span class="title">newStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//生成一个StatementHandler实例，StatementHandler有多个实现类,具体调用哪个实现类，通过mappedStatement的相关信息决定，我们后面会具体分析。RoutingStatementHandler只是一个路由信息类。具体的实现类还需要看情况。</span></span><br><span class="line">  StatementHandler statementHandler = <span class="keyword">new</span> RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">  <span class="comment">//这行代码就不多讲了，之前讲Mybatis插件的时候已经讲过了</span></span><br><span class="line">  statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br><span class="line">  <span class="keyword">return</span> statementHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RoutingStatementHandler的构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RoutingStatementHandler</span><span class="params">(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//我们实际使用的StatementHandler实例对象有三种，分别对应三种原生JDBC的Statement</span></span><br><span class="line">  <span class="comment">//分别是Statement (通过查询)  PreparedStatement （预编译的Statement 执行参数化查询 数据库系统会对sql语句进行预编译处理（如果JDBC驱动支持的话），预处理语句将被预先编译好，这条预编译的sql查询语句能在将来的查询中重用）和CallableStatement (存储过程)</span></span><br><span class="line">  <span class="comment">//关于PreparedStatement Statement的区别后面会有文章来专门介绍。</span></span><br><span class="line">  	<span class="comment">//我们这里根据StatementType，调用的是  delegate = new PreparedStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">switch</span> (ms.getStatementType()) &#123;</span><br><span class="line">     <span class="keyword">case</span> STATEMENT:</span><br><span class="line">       delegate = <span class="keyword">new</span> SimpleStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> PREPARED:</span><br><span class="line">       delegate = <span class="keyword">new</span> PreparedStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> CALLABLE:</span><br><span class="line">       delegate = <span class="keyword">new</span> CallableStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">default</span>:</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Unknown statement type: "</span> + ms.getStatementType());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>我们接着看PreparedStatementHandler构造方法的具体实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PreparedStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//这里调用了PreparedStatementHandler的父类BaseStatementHandler的构造方法，上述的三个类都继承了这个类，这个类的构造方法初始化了很多东西，是非常重要的，这里的设计，很明显的使用了模板方法模式。</span></span><br><span class="line">  <span class="keyword">super</span>(executor, mappedStatement, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">BaseStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//依赖倒转</span></span><br><span class="line">    <span class="keyword">this</span>.configuration = mappedStatement.getConfiguration();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">this</span>.executor = executor;</span><br><span class="line">    <span class="keyword">this</span>.mappedStatement = mappedStatement;</span><br><span class="line">    <span class="keyword">this</span>.rowBounds = rowBounds;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.typeHandlerRegistry = configuration.getTypeHandlerRegistry();</span><br><span class="line">    <span class="keyword">this</span>.objectFactory = configuration.getObjectFactory();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (boundSql == <span class="keyword">null</span>) &#123; <span class="comment">// issue #435, get the key before calculating the statement</span></span><br><span class="line">      generateKeys(parameterObject);</span><br><span class="line">      boundSql = mappedStatement.getBoundSql(parameterObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.boundSql = boundSql;</span><br><span class="line"><span class="comment">//初始化parameterHandler和resultSetHandler，就是在这里初始化了剩下的两大组件，而这两大组件都是statementHandler的属性</span></span><br><span class="line">    <span class="keyword">this</span>.parameterHandler = configuration.newParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">    <span class="keyword">this</span>.resultSetHandler = configuration.newResultSetHandler(executor, mappedStatement, rowBounds, parameterHandler, resultHandler, boundSql);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="SimpleExecutor的prepareStatement方法"><a href="#SimpleExecutor的prepareStatement方法" class="headerlink" title="SimpleExecutor的prepareStatement方法"></a>SimpleExecutor的prepareStatement方法</h4><p>得到handler对象后，方法继续往下执行，  stmt = prepareStatement(handler, ms.getStatementLog());</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Statement <span class="title">prepareStatement</span><span class="params">(StatementHandler handler, Log statementLog)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt;</span><br><span class="line">  <span class="comment">//得到JDBC Connection</span></span><br><span class="line">    Connection connection = getConnection(statementLog);</span><br><span class="line">  <span class="comment">//这里就要到了上面说到的StatementHandler的一个重要方法perpare方法，用来预编译sql</span></span><br><span class="line">  stmt = handler.prepare(connection);</span><br><span class="line">    handler.parameterize(stmt);</span><br><span class="line">    <span class="keyword">return</span> stmt;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Statement <span class="title">prepare</span><span class="params">(Connection connection)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> delegate.prepare(connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="BaseStatementHandler的prepare"><a href="#BaseStatementHandler的prepare" class="headerlink" title="BaseStatementHandler的prepare"></a>BaseStatementHandler的prepare</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Statement <span class="title">prepare</span><span class="params">(Connection connection)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  ErrorContext.instance().sql(boundSql.getSql());</span><br><span class="line">  Statement statement = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    statement = instantiateStatement(connection);</span><br><span class="line">    setStatementTimeout(statement);</span><br><span class="line">    setFetchSize(statement);</span><br><span class="line">    <span class="keyword">return</span> statement;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    closeStatement(statement);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    closeStatement(statement);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Error preparing statement.  Cause: "</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>instantiateStatement抽象方法</p>
<p>很明显又是模板方法模式</p>
<h4 id="PreparedStatementHandler-的instantiateStatement"><a href="#PreparedStatementHandler-的instantiateStatement" class="headerlink" title="PreparedStatementHandler 的instantiateStatement"></a>PreparedStatementHandler 的instantiateStatement</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Statement <span class="title">instantiateStatement</span><span class="params">(Connection connection)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  String sql = boundSql.getSql();</span><br><span class="line">  <span class="comment">//如果需要生成相应的键值，这次Debug并没有要求键值，</span></span><br><span class="line">  <span class="keyword">if</span> (mappedStatement.getKeyGenerator() <span class="keyword">instanceof</span> Jdbc3KeyGenerator) &#123;</span><br><span class="line">    String[] keyColumnNames = mappedStatement.getKeyColumns();</span><br><span class="line">    <span class="keyword">if</span> (keyColumnNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> connection.prepareStatement(sql, PreparedStatement.RETURN_GENERATED_KEYS);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> connection.prepareStatement(sql, keyColumnNames);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">//如果在Mapper配置文件中设置了resultSetType,</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (mappedStatement.getResultSetType() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> connection.prepareStatement(sql, mappedStatement.getResultSetType().getValue(), ResultSet.CONCUR_READ_ONLY);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//这种就是我们在使用原生JDBC时最常用的方法了</span></span><br><span class="line">    <span class="keyword">return</span> connection.prepareStatement(sql);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PreparedStatement <span class="title">prepareStatement</span><span class="params">(String sql,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">int</span> resultSetType,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">int</span> resultSetConcurrency)</span></span></span><br><span class="line"><span class="function">                                   <span class="keyword">throws</span> SQLException</span></span><br></pre></td></tr></table></figure>
<p>其中两个参数的意义是：  </p>
<p>resultSetType 是设置 ResultSet 对象的类型可滚动，或者是不可滚动。取值如下：         ResultSet.TYPE_FORWARD_ONLY 只能向前滚动 </p>
<p>​   ResultSet.TYPE_SCROLL_INSENSITIVE 和 Result.TYPE_SCROLL_SENSITIVE 这两个 方法都能够实现任意的前后滚动，使用各种移动的 ResultSet 指针的方法。二者的区别在于前者对于修改不敏感，而后者对于修改敏感。  resultSetConcurency 是设置 ResultSet 对象能够修改的，取值如下：  </p>
<p>​       ResultSet.CONCUR_READ_ONLY 设置为只读类型的参数。  </p>
<p>​       ResultSet.CONCUR_UPDATABLE 设置为可修改类型的参数。  </p>
<p>所以prepare方法就是完成SQL的预编译，只是把原生JDBC预编译的过程封装了一下，比较容易理解。</p>
<p>​   </p>
<h4 id="handler-parameterize-stmt"><a href="#handler-parameterize-stmt" class="headerlink" title="handler.parameterize(stmt);"></a>handler.parameterize(stmt);</h4><p>上面我们在prepare方法里面预编译了SQL。那么我们这个时候希望设置参数。在Statement中我们是使用parameterize方法进行设置参数的。</p>
<p>RoutingStatementHandler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parameterize</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  delegate.parameterize(statement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于具体的实现要涉及到Mybatis的另一个重要组件，接下来会有专门的博客来介绍。</p>
<h4 id="handler-query-stmt-resultHandler"><a href="#handler-query-stmt-resultHandler" class="headerlink" title="handler.\query(stmt, resultHandler);"></a>handler.\<e>query(stmt, resultHandler);</e></h4><p>当Statement经过stmt = prepareStatement(handler, ms.getStatementLog());</p>
<p>处理后（使用了prepare预编译，使用了parameterize设置参数）,</p>
<p>将其传给query(stmt, resultHandler);得到我们想要的返回内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;  </span><br><span class="line">   PreparedStatement ps = (PreparedStatement) statement; </span><br><span class="line">  <span class="comment">//执行查询操作</span></span><br><span class="line">   ps.execute();</span><br><span class="line">  <span class="comment">//通过ResultSetHandler来处理结果集</span></span><br><span class="line">   <span class="keyword">return</span> resultSetHandler.&lt;E&gt; handleResultSets(ps);  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这个的具体实现以后会细说，到这里，一次完整的查询就结束了。</p>
<p>通过了四大组件的配合，才完成了这一次最简单的查询。</p>
<p>在得到DefaultSqlSession对象时初始化了Executor执行器。</p>
<p>然后在调用Executor的doQuery方法查询的时候，会初始化StatementHandler对象，</p>
<p>然后在初始化StatementHandler的过程中，会初始化ParameterHandler和ResultSetHandler对象，</p>
<p>生成的StatementHandler对象会保存这两个对象的引用。</p>
<p>直到这时，Executor的职责就差不多完成了，通过其他的三大组件来完成接下来的数据库查询工作并返回结果。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>StatementHandler是MyBatis四大对象里面最重要的对象，它的方法是十分重要的，也是我们插件的基础。</p>
<hr>
<p><strong>当我们需要改变sql的时候，显然我们要在预编译SQL(prepare方法前加入修改的逻辑)。</strong></p>
<p><strong>当我们需要修改参数的时候我们可以在调用parameterize方法前修改逻辑。或者使用ParameterHandler来改造设置参数。</strong></p>
<p><strong>我们需要控制组装结果集的时候，也可以在query方法前后加入逻辑，或者使用ResultHandler来改造组装结果。</strong></p>
<p><strong>懂的这些方法，才能理解我需要拦截什么对象，如何处理插件，这是MyBatis的核心内容。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2017/11/26/StatementHandler/" data-id="cjagxkvwl000018bzhwm0ziq3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Executor" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/26/Executor/" class="article-date">
  <time datetime="2017-11-26T08:57:18.132Z" itemprop="datePublished">2017-11-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Mybatis/">Mybatis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/26/Executor/">Executor</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前在用到Mybatis插件的时候就有提到过要好好分析下Mybatis的四大组件，但是由于之前一直在弄公司的消息服务器集群搭建的事情，就耽搁了好一阵子。现在终于有时间了，我们就来好好看看Mybatis的源码。</p>
<h3 id="从一次查询过程说起"><a href="#从一次查询过程说起" class="headerlink" title="从一次查询过程说起"></a>从一次查询过程说起</h3><p>上一次我们我们讲述了Mapper接口以及命令模式的具体命令类MapperMethod。</p>
<p>我们接着之前的分析继续往下走这个查询过程。</p>
<p>接下来就该来到DefaultSqlSession类了。</p>
<p>SqlSession.selectList接MapperMethod</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//1.从confguration(构造DefaultSQLSession使用了建造者模式，configuration对象就是实际具体的建造者)对象中得到MappedStatement对象</span></span><br><span class="line">    MappedStatement ms = configuration.getMappedStatement(statement);</span><br><span class="line">    <span class="comment">//2.使用执行器来进行查询的工作，现在我们的重心就到了Executor执行器上了</span></span><br><span class="line">    List&lt;E&gt; result = executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error querying database.  Cause: "</span> + e, e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述分析，我们得知了，真正的查询操作是通过Executor执行器代劳的。</p>
<h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><p>在上述代码中，我们可以知道Executor对象是DefaultSqlSession类中的一个属性，那么首先，我们就得知道Executor是怎么初始化的。</p>
<p>我们从得到DefatulSqlSession的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlSession session= sessionFactory.openSession();</span><br></pre></td></tr></table></figure>
<p>这行代码为入口分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> sessionFactory.openSession();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> SqlSession <span class="title">openSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> openSessionFromDataSource(configuration.getDefaultExecutorType(), <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> SqlSession <span class="title">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">    Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> Environment environment = configuration.getEnvironment();</span><br><span class="line">      <span class="keyword">final</span> TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">      tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">      <span class="comment">//1、在这里初始化了executor</span></span><br><span class="line">      <span class="keyword">final</span> Executor executor = configuration.newExecutor(tx, execType);</span><br><span class="line">      <span class="comment">//2、并将executor作为DefaultSqlSession构造方法的实参传入，Executor和SqlSession的联系就是在这里生成的。</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      closeTransaction(tx); <span class="comment">// may have fetched a connection so lets call close()</span></span><br><span class="line">      <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error opening session.  Cause: "</span> + e, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>configuration.newExecutor(tx, execType);</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</span><br><span class="line">  executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">  executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">  Executor executor;</span><br><span class="line">  <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果没有显式的设置，则使用SimpleExecutor,一般都是使用这个Executor</span></span><br><span class="line">    executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果是缓存了的执行器，就新建缓存专用的执行器。</span></span><br><span class="line">  <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">    </span><br><span class="line">    executor = <span class="keyword">new</span> CachingExecutor(executor);</span><br><span class="line">  &#125;</span><br><span class="line">  executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">  <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法通过Mybatis相关配置文件中设置的ExecutorType来决定(如果没有显式的设置，则使用默认的Type)到底生成哪种Executor。</p>
<p>这里对几种Executor进行介绍一下，并说明用使用显式配置时该如何配置</p>
<p>SimpleExecutor – SIMPLE 就是普通的执行器。</p>
<p>ReuseExecutor -执行器会重用预处理语句（prepared statements）</p>
<p>BatchExecutor –它是批量执行器</p>
<p>这些就是mybatis的三种执行器。你可以通过配置文件的settings里面的元素defaultExecutorType，配置它，默认是采用SimpleExecutor</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"defaultExecutorType"</span> <span class="attr">value</span>=<span class="string">"SIMPLE"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果你在Spring运用它，那么你可以这么配置它：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionTemplateBatch"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionTemplate"</span>&gt;</span>       </span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">ref</span>=<span class="string">"sqlSessionFactory"</span> /&gt;</span>    </span><br><span class="line"><span class="comment">&lt;!--更新采用批量的executor --&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span> <span class="attr">value</span>=<span class="string">"BATCH"</span>/&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="继续分析查询过程"><a href="#继续分析查询过程" class="headerlink" title="继续分析查询过程"></a>继续分析查询过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//1.从confguration(构造DefaultSQLSession使用了建造者模式，configuration对象就是实际具体的建造者)对象中得到MappedStatement对象</span></span><br><span class="line">    MappedStatement ms = configuration.getMappedStatement(statement);</span><br><span class="line">    <span class="comment">//2.使用执行器来进行查询的工作，现在我们的重心就到了Executor执行器上了</span></span><br><span class="line">    List&lt;E&gt; result = executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error querying database.  Cause: "</span> + e, e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>1.warpCollection是对Method参数的又一次处理，我们看看具体做了些什么</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> Object <span class="title">wrapCollection</span><span class="params">(<span class="keyword">final</span> Object object)</span> </span>&#123;</span><br><span class="line"><span class="comment">//我们看到如果经过MapperMethod封装的参数的类型是List类型的话</span></span><br><span class="line">   <span class="keyword">if</span> (object <span class="keyword">instanceof</span> List) &#123;</span><br><span class="line">     StrictMap&lt;Object&gt; map = <span class="keyword">new</span> StrictMap&lt;Object&gt;();</span><br><span class="line">     <span class="comment">//将object作为Value存入map中，而且Key为list,StrictMap继承了HashMap，并且该HashMap的Key是String类型的，这一层封装的意义就在于限定该map的Key只能为String类型</span></span><br><span class="line">     <span class="comment">//这里更需要引起我们注意的是这里的Key为list，当你第一眼看到这个list的时候会想到什么呢，</span></span><br><span class="line">     <span class="comment">//反正我是一下就想到了在使用动态sql的foreach节点时候出现过list，所以，为了能够对Mapper配置文件中的list对应的对象群出来，这里先将list设置好，这就为什么当参数是List类型时候放入Map时的Key设为list了。</span></span><br><span class="line">      map.put(<span class="string">"list"</span>, object);</span><br><span class="line">     <span class="keyword">return</span> map;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object != <span class="keyword">null</span> &amp;&amp; object.getClass().isArray()) &#123;</span><br><span class="line">     StrictMap&lt;Object&gt; map = <span class="keyword">new</span> StrictMap&lt;Object&gt;();</span><br><span class="line">    <span class="comment">//当数组类型时，放入map中，Key为array，理由同上</span></span><br><span class="line">     map.put(<span class="string">"array"</span>, object);</span><br><span class="line">     <span class="keyword">return</span> map;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> object;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>warpCollection这个方法的作用就是：</p>
<p>将List或者Array类型转化为Map类型的，并且存入Map时一定要给限定相应的Key，至于为什么要转为Map类型的，当我们分析到后面的时候自然就会有答案了，现在不用深究。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static class StrictMap&lt;V&gt; extends HashMap&lt;String, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = -5741767162221585340L;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public V get(Object key) &#123;</span><br><span class="line">      if (!super.containsKey(key)) &#123;</span><br><span class="line">        throw new BindingException(&quot;Parameter &apos;&quot; + key + &quot;&apos; not found. Available parameters are &quot; + this.keySet());</span><br><span class="line">      &#125;</span><br><span class="line">      return super.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2.query方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">   <span class="comment">//1.  BoundSql是对sql的封装，是MappedStatement对Mapper配置文件提取后将SQL的相关信息封装后都集中了BoundSql中，具体是怎么集中封装的，下面会分析</span></span><br><span class="line">   BoundSql boundSql = ms.getBoundSql(parameterObject);</span><br><span class="line">   CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line">   <span class="keyword">return</span> query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>​    </p>
<ul>
<li>1.MappedStatement的getBoundSql</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BoundSql <span class="title">getBoundSql</span><span class="params">(Object parameterObject)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//2 DynamicSqlSource的getBoundSql</span></span><br><span class="line">    BoundSql boundSql = sqlSource.getBoundSql(parameterObject);</span><br><span class="line">    List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">  <span class="comment">//将得到的paramterMappings放入到BoundSql对象中，这点是非常重要的</span></span><br><span class="line">    <span class="keyword">if</span> (parameterMappings == <span class="keyword">null</span> || parameterMappings.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      boundSql = <span class="keyword">new</span> BoundSql(configuration, boundSql.getSql(), parameterMap.getParameterMappings(), parameterObject);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><ul>
<li>2.DynamicSqlSource的getBoundSql(因为使用了动态SQL，所以使用的DynamicSqlSource，关于各种情况具体是怎么封装sql的，也就是关于BoundSql对象以及SqlSource接口和相应的一些实现类，会有一个专门的博客介绍，对于Mybatis源码的一些关键类，都应该有单独的博客介绍，但是我们还是先有一个大体的认识)</li>
</ul>
</li>
</ul>
<p>​    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BoundSql <span class="title">getBoundSql</span><span class="params">(Object parameterObject)</span> </span>&#123;</span><br><span class="line">   DynamicContext context = <span class="keyword">new</span> DynamicContext(configuration, parameterObject);</span><br><span class="line">	<span class="comment">//3.将Mapper配置文件中的SQL组装起来，在初始化的过程中，该SQL对应的处理节点分成了两个StaticSqlNode，和一个ForEachSqlNode。</span></span><br><span class="line">  rootSqlNode.apply(context);</span><br><span class="line">   SqlSourceBuilder sqlSourceParser = <span class="keyword">new</span> SqlSourceBuilder(configuration);</span><br><span class="line">   Class&lt;?&gt; parameterType = parameterObject == <span class="keyword">null</span> ? Object.class : parameterObject.getClass();</span><br><span class="line">  <span class="comment">//4.得到SqlSource对象，最重要的是parse方法让我们得到paramtermappings,这个对象对我们执行参数化sql时非常重要</span></span><br><span class="line">   SqlSource sqlSource = sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings());</span><br><span class="line">   BoundSql boundSql = sqlSource.getBoundSql(parameterObject);</span><br><span class="line">   <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : context.getBindings().entrySet()) &#123;</span><br><span class="line">     boundSql.setAdditionalParameter(entry.getKey(), entry.getValue());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> boundSql;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><ul>
<li>3.DynamicContext的创建</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PARAMETER_OBJECT_KEY = <span class="string">"_parameter"</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DATABASE_ID_KEY = <span class="string">"_databaseId"</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DynamicContext</span><span class="params">(Configuration configuration, Object parameterObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parameterObject != <span class="keyword">null</span> &amp;&amp; !(parameterObject <span class="keyword">instanceof</span> Map)) &#123;</span><br><span class="line">      MetaObject metaObject = configuration.newMetaObject(parameterObject);</span><br><span class="line">      bindings = <span class="keyword">new</span> ContextMap(metaObject);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      bindings = <span class="keyword">new</span> ContextMap(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    bindings.put(PARAMETER_OBJECT_KEY, parameterObject);</span><br><span class="line">    bindings.put(DATABASE_ID_KEY, configuration.getDatabaseId());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里没有特别难理解的地方，就是DynamicContext中有个ContextMap类型（同样继承了HashMap）的属性bindings,这个属性是非常重要的，然后将两个元素放入这个Map中，这里需要注意的是我们会将Method封装参数放入Map中，并且对应的Key是_parameter。一看到_parameter,我们肯定就想到了在学习编写Mapper配置文件中使用过这个。</p>
<p>3.(1)MixedSqlNode</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">private</span> List&lt;SqlNode&gt; contents;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MixedSqlNode</span><span class="params">(List&lt;SqlNode&gt; contents)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.contents = contents;</span><br><span class="line">  &#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(DynamicContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (SqlNode sqlNode : contents) &#123;</span><br><span class="line">      sqlNode.apply(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里的contents就对应的两个StaticSqlNode和一个ForEachSqlNode，如何拼接ForEachSqlNode,以及如何提取ps.setParameter()所用到的信息是问题的关键。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(DynamicContext context)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; bindings = context.getBindings();</span><br><span class="line">    <span class="keyword">final</span> Iterable&lt;?&gt; iterable = evaluator.evaluateIterable(collectionExpression, bindings);</span><br><span class="line">    <span class="keyword">if</span> (!iterable.iterator().hasNext()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> first = <span class="keyword">true</span>;</span><br><span class="line">    applyOpen(context);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Object o : iterable) &#123;</span><br><span class="line">      DynamicContext oldContext = context;</span><br><span class="line">      <span class="keyword">if</span> (first) &#123;</span><br><span class="line">        context = <span class="keyword">new</span> PrefixedContext(context, <span class="string">""</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (separator != <span class="keyword">null</span>) &#123;</span><br><span class="line">          context = <span class="keyword">new</span> PrefixedContext(context, separator);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          context = <span class="keyword">new</span> PrefixedContext(context, <span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> uniqueNumber = context.getUniqueNumber();</span><br><span class="line">      <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123; <span class="comment">// Issue #709 </span></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) </span><br><span class="line">        Map.Entry&lt;Object, Object&gt; mapEntry = (Map.Entry&lt;Object, Object&gt;) o;</span><br><span class="line">        applyIndex(context, mapEntry.getKey(), uniqueNumber);</span><br><span class="line">        applyItem(context, mapEntry.getValue(), uniqueNumber);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        applyIndex(context, i, uniqueNumber);</span><br><span class="line">        applyItem(context, o, uniqueNumber);</span><br><span class="line">      &#125;</span><br><span class="line">      contents.apply(<span class="keyword">new</span> FilteredDynamicContext(configuration, context, index, item, uniqueNumber));</span><br><span class="line">      <span class="keyword">if</span> (first) first = !((PrefixedContext) context).isPrefixApplied();</span><br><span class="line">      context = oldContext;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    applyClose(context);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><ul>
<li>4.最后我们需要了解下parse方法，注意这个方法的具体实现里面得到了paramterMappings，这是非常重要的。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSource <span class="title">parse</span><span class="params">(String originalSql, Class&lt;?&gt; parameterType, Map&lt;String, Object&gt; additionalParameters)</span> </span>&#123;</span><br><span class="line">  ParameterMappingTokenHandler handler = <span class="keyword">new</span> ParameterMappingTokenHandler(configuration, parameterType, additionalParameters);</span><br><span class="line">  <span class="comment">//在这个过程中会把 #&#123;&#125; 里的信息赋给paramterMappings</span></span><br><span class="line">  GenericTokenParser parser = <span class="keyword">new</span> GenericTokenParser(<span class="string">"#&#123;"</span>, <span class="string">"&#125;"</span>, handler);</span><br><span class="line">  String sql = parser.parse(originalSql);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> StaticSqlSource(configuration, sql, handler.getParameterMappings());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2.BaseExecutor的query方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">   BoundSql boundSql = ms.getBoundSql(parameter);</span><br><span class="line">   <span class="comment">//生成一个CacheKey</span></span><br><span class="line">   CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);</span><br><span class="line">   <span class="keyword">return</span> query(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>终于分析到这个方法的最后一行代码了。</p>
<p>BaseExecutor的query方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">"executing a query"</span>).object(ms.getId());</span><br><span class="line">  <span class="keyword">if</span> (closed) <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Executor was closed."</span>);</span><br><span class="line">  <span class="keyword">if</span> (queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">    clearLocalCache();</span><br><span class="line">  &#125;</span><br><span class="line">  List&lt;E&gt; list;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    queryStack++;</span><br><span class="line">    <span class="comment">//查看是不是已经有查询过了，有的话直接在本地缓存中取出来</span></span><br><span class="line">    list = resultHandler == <span class="keyword">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//如果是存储过程，需要把输出处理一下，具体处理目前没有细看</span></span><br><span class="line">      handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//如果没有本地缓存或者使用了resultHandler，需要到数据库中去查。</span></span><br><span class="line">      list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    queryStack--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (queryStack == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (DeferredLoad deferredLoad : deferredLoads) &#123;</span><br><span class="line">      deferredLoad.load();</span><br><span class="line">    &#125;</span><br><span class="line">    deferredLoads.clear(); <span class="comment">// issue #601</span></span><br><span class="line">    <span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">      clearLocalCache(); <span class="comment">// issue #482</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>queryFromDatabase</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">queryFromDatabase</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  List&lt;E&gt; list;</span><br><span class="line">  localCache.putObject(key, EXECUTION_PLACEHOLDER);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    localCache.removeObject(key);</span><br><span class="line">  &#125;</span><br><span class="line">  localCache.putObject(key, list);</span><br><span class="line">  <span class="keyword">if</span> (ms.getStatementType() == StatementType.CALLABLE) &#123;</span><br><span class="line">    localOutputParameterCache.putObject(key, parameter);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SimpleExecutor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Configuration configuration = ms.getConfiguration();</span><br><span class="line">    <span class="comment">//在这里初始化了除了Excutor的其他三大组件，注意了，这行代码完成的工作很重要，而Executor对象则在初始化得到DefaultSqlSession对象的时候就已经注入到其中了。</span></span><br><span class="line">    StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">    <span class="keyword">return</span> handler.&lt;E&gt;query(stmt, resultHandler);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    closeStatement(stmt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法里面，我们完成了得到结果的所有流程。</p>
<p>1、我们先得到Configuration对象。</p>
<p>2、利用COnfiguration对象去生成其他三大组件对象，用三大组件对象完成查询的具体操作。</p>
<p>3、利用三大组件进行具体得到结果</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2017/11/26/Executor/" data-id="cjagxkvx3000418bzusslgccb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Mapper接口" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/26/Mapper接口/" class="article-date">
  <time datetime="2017-11-25T16:59:25.391Z" itemprop="datePublished">2017-11-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Mybatis/">Mybatis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/26/Mapper接口/">Mapper接口</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前在说到Mybatis插件的时候说以后要好好分析下Mybatis的四大组件，之前一直在为公司忙搭建RocketMQ消息集群的事情，就耽误了一段时间，最近终于有时间来分析下了，要分析四大组件，还是要从一次完整的查询过程说起，把Mybatis的核心源码都过一遍。</p>
<h3 id="从一次查询说起"><a href="#从一次查询说起" class="headerlink" title="从一次查询说起"></a>从一次查询说起</h3><p>我们做一次Mybatis的查询测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	SqlSession session = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		session = MybatisUtil.getCurrentSession();</span><br><span class="line">		UserDao userDao = session.getMapper(UserDao.class);</span><br><span class="line">		List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">		list.add(<span class="number">1</span>);</span><br><span class="line">		list.add(<span class="number">3</span>);</span><br><span class="line">		list.add(<span class="number">25</span>);</span><br><span class="line">		List&lt;User&gt; userList = userDao.queryList(list);</span><br><span class="line">		System.out.println(JSON.toJSONString(userList));</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (session != <span class="keyword">null</span>)</span><br><span class="line">			session.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的Mapper配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.wangcc.mybatis.dao.UserDao&quot;&gt;</span><br><span class="line">&lt;resultMap type=&quot;User&quot; id=&quot;UserMapper&quot;&gt;</span><br><span class="line">&lt;result property=&quot;id&quot; column=&quot;t_id&quot;/&gt;</span><br><span class="line">&lt;result property=&quot;name&quot; column=&quot;t_name&quot;/&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line">&lt;select id=&quot;queryList&quot; resultMap=&quot;UserMapper&quot;&gt;</span><br><span class="line">select * from t_user where t_id in </span><br><span class="line">&lt;foreach collection=&quot;list&quot; item=&quot;uId&quot; index=&quot;index&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;#&#123;uId&#125;&lt;/foreach&gt;</span><br><span class="line"></span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;insert id=&quot;insert&quot; parameterType=&quot;User&quot;&gt;</span><br><span class="line"></span><br><span class="line">insert into t_user (t_name,address) values(#&#123;name&#125;,#&#123;address&#125;)</span><br><span class="line">&lt;/insert&gt;</span><br><span class="line">&lt;insert id=&quot;batchInsert&quot; &gt;</span><br><span class="line">insert into t_user (t_name,address) values &lt;foreach collection=&quot;list&quot; item=&quot;user&quot; separator=&quot;,&quot;&gt;</span><br><span class="line">(#&#123;user.name&#125;,#&#123;user.address&#125;)</span><br><span class="line">&lt;/foreach&gt;</span><br><span class="line"></span><br><span class="line">&lt;/insert&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>
<p>如果你是初次使用Mybatis，那么你一定会好奇为什么这里的UserDao都是接口并不是具体的实现类。</p>
<p>而如果你熟悉JDK动态代理，那么一看到这种接口可以直接执行方法的情况，那么肯定是用了代理，那么虽然我们能够知道为什么可以直接执行，但是我们也要了解他具体是怎么实现的。我们就以</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UserDao userDao = session.getMapper(UserDao.class);</span><br></pre></td></tr></table></figure>
<p>为Debug入口。</p>
<p>进入getMapper方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> configuration.&lt;T&gt;getMapper(type, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现还是调用了构建SqlSession的最重要的对象Configuration的方法。</p>
<p>DefaultSqlSession对象中保存着Configuration对象的引用。</p>
<p>进入到Configuration中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> mapperRegistry.getMapper(type, sqlSession);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现是调用的MapperRegistry对象（Configuration保存着其引用，在初始化Mybatis的配置文件的时候，就会将所有的Mapper接口注册到MapperRegistry的Map\<class<?>, MapperProxyFactory&lt;?&gt;&gt; knownMappersz这个HashMap对象中，在注册的过程中Mapper接口会被封装为MapperProxyFactory对象）</class<?></p>
<p>我们看看MapperRegistry中的geMapper方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//在knownMappers中查找是否已经注册了，如果没有注册直接抛出异常，注册Mapper接口是在初始化Mybatis配置文件时必须就要完成的工作，不能在调用getMapper的时候再动态去注册</span></span><br><span class="line">    <span class="keyword">final</span> MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">    <span class="keyword">if</span> (mapperProxyFactory == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Type "</span> + type + <span class="string">" is not known to the MapperRegistry."</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">return</span> mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Error getting mapper instance. Cause: "</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>进入newInstance方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line"><span class="comment">//封装了一个MapperProxy对象,即组合模式，为了解耦，我们一般能不用继承就不用继续，尽量使用组合，这里MapperProxy是实现了InvocationHandler接口的类</span></span><br><span class="line">   <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy&lt;T&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">   <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p> newInstance(mapperProxy) 得到Mapper接口的代理对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到现在，如何得到Mapper接口的代理对象的流程就走完了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2017/11/26/Mapper接口/" data-id="cjafl8ufi00005sbzeieu2sxd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-MapperMethod" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/26/MapperMethod/" class="article-date">
  <time datetime="2017-11-25T16:59:07.345Z" itemprop="datePublished">2017-11-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Mybatis/">Mybatis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/26/MapperMethod/">MapperMethod</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>我们接着上面继续分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		SqlSession session = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			session = MybatisUtil.getCurrentSession();</span><br><span class="line">			UserDao userDao = session.getMapper(UserDao.class);</span><br><span class="line">			List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">			list.add(<span class="number">1</span>);</span><br><span class="line">			list.add(<span class="number">3</span>);</span><br><span class="line">			list.add(<span class="number">25</span>);</span><br><span class="line">          </span><br><span class="line">			List&lt;User&gt; userList = userDao.queryList(list);</span><br><span class="line">			System.out.println(JSON.toJSONString(userList));</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (session != <span class="keyword">null</span>)</span><br><span class="line">				session.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>我们都这一句代码进行DEBUG</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; userList = userDao.queryList(list);</span><br></pre></td></tr></table></figure>
<p>首先，我们会进入MapperProxy这个类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">     <span class="comment">//如果方法是Object类自带的方法，比如没有被重写的equals toString, hashcode 等，还是执行原来的方法</span></span><br><span class="line">  <span class="comment">// getDeclaringClass()返回表示声明由此 Method 对象表示的方法的类或接口的 Class 对象。</span></span><br><span class="line">  <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果不是object的自带方法，先去  Map&lt;Method, MapperMethod&gt; methodCache中找是否已经存在这个method了，没有就将method封装成MapperMethod存进mehtodCache中然后返回MapperMethod。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);</span><br><span class="line">  <span class="comment">//然后执行MapprMehtod的execute方法</span></span><br><span class="line">  <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看看cachedMapperMethod</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> MapperMethod <span class="title">cachedMapperMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line"><span class="comment">//当method是第一次调用时,我们无法在methodCache中得到MapperMethod,我们就得新创建一个MapperMethod</span></span><br><span class="line">  MapperMethod mapperMethod = methodCache.get(method);</span><br><span class="line">  <span class="keyword">if</span> (mapperMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//创建一个MapperMethod,这里是关键。</span></span><br><span class="line">    mapperMethod = <span class="keyword">new</span> MapperMethod(mapperInterface, method, sqlSession.getConfiguration());</span><br><span class="line">    methodCache.put(method, mapperMethod);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mapperMethod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>终于到了我们重点要讲解的MapperMethod类了</p>
<p>我们先看MapperMethod构造方法，初始化了他的两个属性，command和method</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MapperMethod</span><span class="params">(Class&lt;?&gt; mapperInterface, Method method, Configuration config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.command = <span class="keyword">new</span> SqlCommand(config, mapperInterface, method);</span><br><span class="line">    <span class="keyword">this</span>.method = <span class="keyword">new</span> MethodSignature(config, method);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这两个属性非常的重要，要详细的介绍的话需要大量的篇幅，所以先放在一旁。</p>
<p>我们先看具体的执行方法execute</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">   Object result;</span><br><span class="line">   <span class="keyword">if</span> (SqlCommandType.INSERT == command.getType()) &#123;</span><br><span class="line">     Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">     result = rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SqlCommandType.UPDATE == command.getType()) &#123;</span><br><span class="line">     Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">     result = rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SqlCommandType.DELETE == command.getType()) &#123;</span><br><span class="line">     Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">     result = rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">   &#125; </span><br><span class="line">  <span class="comment">//很明显我们的SqlCommandType是SELECT类型</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (SqlCommandType.SELECT == command.getType()) &#123;</span><br><span class="line">    <span class="comment">//是否返回类型是void类型并且Method参数列表中包含resultHandler,具体的判断在文末分析</span></span><br><span class="line">     <span class="keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">       executeWithResultHandler(sqlSession, args);</span><br><span class="line">       result = <span class="keyword">null</span>;</span><br><span class="line">     &#125; </span><br><span class="line">    <span class="comment">//我们调用的方法的返回类型是List，会走这个分支。我们看下method.returnsMany的具体实现吧。</span></span><br><span class="line">    <span class="comment">//这里的method是MapperMethod的属性MethodSignature对象</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMany()) &#123;</span><br><span class="line">       result = executeForMany(sqlSession, args);</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMap()) &#123;</span><br><span class="line">       result = executeForMap(sqlSession, args);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">       result = sqlSession.selectOne(command.getName(), param);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Unknown execution method for: "</span> + command.getName());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (result == <span class="keyword">null</span> &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Mapper method '"</span> + command.getName() </span><br><span class="line">         + <span class="string">" attempted to return null from a method with a primitive return type ("</span> + method.getReturnType() + <span class="string">")."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>executeForMany</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">Object <span class="title">executeForMany</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">  List&lt;E&gt; result;</span><br><span class="line">  <span class="comment">//这个方法我们非常有必要分析一下,这个方法封装了我们调用的Mapper接口Method的参数列表对应实参</span></span><br><span class="line">  Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">  <span class="keyword">if</span> (method.hasRowBounds()) &#123;</span><br><span class="line">    RowBounds rowBounds = method.extractRowBounds(args);</span><br><span class="line"> <span class="comment">//终于到了我们的DefaultSqlSession的方法了</span></span><br><span class="line">    result = sqlSession.&lt;E&gt;selectList(command.getName(), param, rowBounds);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = sqlSession.&lt;E&gt;selectList(command.getName(), param);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// issue #510 Collections &amp; arrays support</span></span><br><span class="line">  <span class="keyword">if</span> (!method.getReturnType().isAssignableFrom(result.getClass())) &#123;</span><br><span class="line">    <span class="keyword">if</span> (method.getReturnType().isArray()) &#123;</span><br><span class="line">      <span class="keyword">return</span> convertToArray(result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> convertToDeclaredCollection(sqlSession.getConfiguration(), result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>convertArgsToSqlCommandParam</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">convertArgsToSqlCommandParam</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">   	</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> paramCount = params.size();</span><br><span class="line">   <span class="comment">//没有参数 </span></span><br><span class="line">   <span class="keyword">if</span> (args == <span class="keyword">null</span> || paramCount == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125; </span><br><span class="line">   <span class="comment">//有一个参数，而且不是@Param注解修饰的参数</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (!hasNamedParameters &amp;&amp; paramCount == <span class="number">1</span>) &#123;</span><br><span class="line">     <span class="comment">//直接返回形参对应的实参</span></span><br><span class="line">        <span class="keyword">return</span> args[params.keySet().iterator().next()];</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   否则</span></span><br><span class="line"><span class="comment">   多个参数或者一个参数但是使用@param注解</span></span><br><span class="line"><span class="comment">   就要按以下方法操作</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">	</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Map&lt;String, Object&gt; param = <span class="keyword">new</span> ParamMap&lt;Object&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : params.entrySet()) &#123;</span><br><span class="line">          <span class="comment">//如果是使用@param注解的，则put的Key是@param(value)里的Value,如果不是，则put的Key就是int类型的，put的Value自然都是Method形参对应的实参（args[entry.getKey()] entry.getKey() Key都是从0-i-1的int类型，代表顺序，结合getParams方法分析就明了，了解了这些，对于Mybatis中传递参数的三种方式也就理解了</span></span><br><span class="line">          http:<span class="comment">//blog.csdn.net/shasiqq/article/details/51305666</span></span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line">          param.put(entry.getValue(), args[entry.getKey()]);</span><br><span class="line">          <span class="comment">// issue #71, add param names as param1, param2...but ensure backward compatibility</span></span><br><span class="line">          <span class="comment">//但要确保向后兼容性</span></span><br><span class="line">          <span class="keyword">final</span> String genericParamName = <span class="string">"param"</span> + String.valueOf(i + <span class="number">1</span>);</span><br><span class="line">          <span class="keyword">if</span> (!param.containsKey(genericParamName)) &#123;</span><br><span class="line">            param.put(genericParamName, args[entry.getKey()]);</span><br><span class="line">          &#125;</span><br><span class="line">          i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> param;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里我们需要了解params对象到底是怎样得来的，他的具体实现是怎样的。</p>
<p>​      </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">this</span>.params = Collections.unmodifiableSortedMap(getParams(method, <span class="keyword">this</span>.hasNamedParameters));</span><br><span class="line"><span class="function"><span class="keyword">private</span> SortedMap&lt;Integer, String&gt; <span class="title">getParams</span><span class="params">(Method method, <span class="keyword">boolean</span> hasNamedParameters)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> SortedMap&lt;Integer, String&gt; params = <span class="keyword">new</span> TreeMap&lt;Integer, String&gt;();</span><br><span class="line">     <span class="keyword">final</span> Class&lt;?&gt;[] argTypes = method.getParameterTypes();</span><br><span class="line">           <span class="comment">//如果是@param修饰的，则put的Value是@param(value)中的Value</span></span><br><span class="line">         <span class="comment">//如果不是，则put的Value就是当前parms这个Map的size</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; argTypes.length; i++) &#123;</span><br><span class="line">       <span class="keyword">if</span> (!RowBounds.class.isAssignableFrom(argTypes[i]) &amp;&amp; !ResultHandler.class.isAssignableFrom(argTypes[i])) &#123;</span><br><span class="line">         String paramName = String.valueOf(params.size());</span><br><span class="line">         <span class="keyword">if</span> (hasNamedParameters) &#123;</span><br><span class="line">           paramName = getParamNameFromAnnotation(method, i, paramName);</span><br><span class="line">         &#125;</span><br><span class="line">         params.put(i, paramName);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> params;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> String <span class="title">getParamNameFromAnnotation</span><span class="params">(Method method, <span class="keyword">int</span> i, String paramName)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> Object[] paramAnnos = method.getParameterAnnotations()[i];</span><br><span class="line">     <span class="keyword">for</span> (Object paramAnno : paramAnnos) &#123;</span><br><span class="line">       <span class="keyword">if</span> (paramAnno <span class="keyword">instanceof</span> Param) &#123;</span><br><span class="line">         paramName = ((Param) paramAnno).value();</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> paramName;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>下面是分析上述方法时用到的Method和Class类中的方法介绍：</p>
<p>Method</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getParameterTypes</span><br><span class="line">public Class&lt;?&gt;[] getParameterTypes()按照声明顺序返回 Class 对象的数组，这些对象描述了此 Method 对象所表示的方法的形参类型。如果底层方法不带参数，则返回长度为 0 的数组。 </span><br><span class="line"></span><br><span class="line">返回：</span><br><span class="line">此对象所表示的方法的参数类型</span><br></pre></td></tr></table></figure>
<p>Class</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">isAssignableFrom</span><br><span class="line">public boolean isAssignableFrom(Class&lt;?&gt; cls)判定此 Class 对象所表示的类或接口与指定的 Class 参数所表示的类或接口是否相同，或是否是其超类或超接口。如果是则返回 true；否则返回 false。如果该 Class 表示一个基本类型，且指定的 Class 参数正是该 Class 对象，则该方法返回 true；否则返回 false。 </span><br><span class="line">特别地，通过身份转换或扩展引用转换，此方法能测试指定 Class 参数所表示的类型能否转换为此 Class 对象所表示的类型。有关详细信息，请参阅 Java Language Specification 的第 5.1.1 和 5.1.4 节。 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">cls - 要检查的 Class 对象 </span><br><span class="line">返回：</span><br><span class="line">表明 cls 类型的对象能否赋予此类对象的 boolean 值 </span><br><span class="line">抛出： </span><br><span class="line">NullPointerException - 如果指定的 Class 参数为 null。</span><br><span class="line">从以下版本开始： </span><br><span class="line">JDK1.1 </span><br><span class="line"></span><br><span class="line">getComponentType</span><br><span class="line">public Class&lt;?&gt; getComponentType()返回表示数组组件类型的 Class。如果此类不表示数组类，则此方法返回 null。 </span><br><span class="line"></span><br><span class="line">返回：</span><br><span class="line">如果此类是数组，则返回表示此类组件类型的 Class</span><br><span class="line">从以下版本开始： </span><br><span class="line">JDK1.1 </span><br><span class="line">另请参见：</span><br><span class="line">Array</span><br></pre></td></tr></table></figure>
<p>hasNamedParams判断Mapper接口中的指定方法中的参数列表中是否有@Param注解修饰</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasNamedParams</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> hasNamedParams = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    getParameterAnnotations() </span></span><br><span class="line"><span class="comment">        返回表示按照声明顺序对此 Method 对象所表示方法的形参进行注释的那个数组的数组。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">final</span> Object[][] paramAnnos = method.getParameterAnnotations();</span><br><span class="line">    <span class="keyword">for</span> (Object[] paramAnno : paramAnnos) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Object aParamAnno : paramAnno) &#123;</span><br><span class="line">        <span class="comment">//看是否参数有@Param注解修饰</span></span><br><span class="line">        <span class="keyword">if</span> (aParamAnno <span class="keyword">instanceof</span> Param) &#123;</span><br><span class="line">          hasNamedParams = <span class="keyword">true</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hasNamedParams;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getParameterAnnotations</span><br><span class="line">public Annotation[][] getParameterAnnotations()返回表示按照声明顺序对此 Method 对象所表示方法的形参进行注释(应该是注解把)的那个数组的数组。（如果底层方法没有参数，则返回长度为零的数组。如果该方法有一个或多个参数，则为每个不带注释的参数返回长度为零的嵌套数组。）返回数组中包含的注释对象是可序列化的。此方法的调用者可以随意修改返回的数组；这不会对其他调用者返回的数组产生任何影响。 </span><br><span class="line"></span><br><span class="line">返回：</span><br><span class="line">表示按声明顺序对此 Method 对象所表示方法的形参进行注释的那个数组的数组</span><br></pre></td></tr></table></figure>
<ul>
<li>是否Method返回类型是void类型并且Method参数列表中包含resultHandler</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//select语句，Method的返回类型如果是void而且参数列表中有参数类型是ResultHandler</span></span><br><span class="line"><span class="keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">              <span class="keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">        executeWithResultHandler(sqlSession, args);</span><br><span class="line">        result = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasResultHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (resultHandlerIndex != <span class="keyword">null</span>);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.resultHandlerIndex = getUniqueParamIndex(method, ResultHandler.class);</span><br></pre></td></tr></table></figure>
<p>getUniqueParamIndex分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原来是个很简单的方法就是判断是否参数列表中是否有参数类型为ResultHandler的，有就返回index，没有就是null</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Integer <span class="title">getUniqueParamIndex</span><span class="params">(Method method, Class&lt;?&gt; paramType)</span> </span>&#123;</span><br><span class="line">      Integer index = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">final</span> Class&lt;?&gt;[] argTypes = method.getParameterTypes();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; argTypes.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (paramType.isAssignableFrom(argTypes[i])) &#123;</span><br><span class="line">          <span class="keyword">if</span> (index == <span class="keyword">null</span>) &#123;</span><br><span class="line">            index = i;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(method.getName() + <span class="string">" cannot have multiple "</span> + paramType.getSimpleName() + <span class="string">" parameters"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>1.MapperMethod的execute方法的作用</p>
<ul>
<li><p>首先是将Method方法的实参封装成Object对象</p>
</li>
<li><p>然后调用DefaultSqlSession中的方法，将上述的Object对象以及command.getName()   （name = ms.getId();  SqlCommand对象中的name即是该Method对应XML配置文件中SQL的的唯一标示）作为参数 传入方法中,上述两个参数是必须要传递的</p>
<p>本例是使用了selectList方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = sqlSession.&lt;E&gt;selectList(command.getName(), param);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>2.Mybatis为什么要设计MapperMethod类呢？</p>
<p>其实经过这一分析，如果熟悉设计模式的人就会发现，这是使用了命令模式。</p>
<p>什么是命令模式呢，命令模式就是让请求发送者与接收者解耦</p>
<p><strong>命令模式可以将请求发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求</strong>。</p>
<pre><code>在命令模式结构图中包含如下几个角色：
   ● Command（抽象命令类）：抽象命令类一般是一个抽象类或接口，在其中声明了用于执行请求的execute()等方法，通过这些方法可以调用请求接收者的相关操作。
   ● ConcreteCommand（具体命令类）：具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中。在实现execute()方法时，将调用接收者对象的相关操作(Action)。
   ● Invoker（调用者）：调用者即请求发送者，它通过命令对象来执行请求。一个调用者并不需要在设计时确定其接收者，因此它只与抽象命令类之间存在关联关系。在程序运行时可以将一个具体命令对象注入其中，再调用具体命令对象的execute()方法，从而实现间接调用请求接收者的相关操作。
   ● Receiver（接收者）：接收者执行与请求相关的操作，它具体实现对请求的业务处理。
   命令模式的本质是对请求进行封装，一个请求对应于一个命令，将发出命令的责任和执行命令的责任分割开。每一个命令都是一个操作：请求的一方发出请求要求执行一个操作；接收的一方收到请求，并执行相应的操作。命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求如何被接收、操作是否被执行、何时被执行，以及是怎么被执行的。
   命令模式的关键在于引入了抽象命令类，请求发送者针对抽象命令类编程，只有实现了抽象命令类的具体命令才与请求接收者相关联。在最简单的抽象命令类中只包含了一个抽象的execute()方法，每个具体命令类将一个Receiver类型的对象作为一个实例变量进行存储，从而具体指定一个请求的接收者，不同的具体命令类提供了execute()方法的不同实现，并调用不同接收者的请求处理方法。
</code></pre><p>这里的调用者就是MapperProxy</p>
<p>接受者是DefaultSqlSession</p>
<p>而具体的命令类是MapperMethod</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2017/11/26/MapperMethod/" data-id="cjafl30bb0000k0bzqgqvzzlo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Mybatis插件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/22/Mybatis插件/" class="article-date">
  <time datetime="2017-11-22T15:52:37.741Z" itemprop="datePublished">2017-11-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Mybatis/">Mybatis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/22/Mybatis插件/">Mybatis组件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>前言：最近项目有个需求，需要将所有产品的ID和Name组成Map传递到前台,以ID为key，以Name为Value。</p>
<p>即需要达到可以通过map.get(id)方便地获取name的值的效果。</p>
<p>然后就开始测试在Mybatis中哪种方法可行。首先看看直接使用resultType=”map”</p>
<p>Mapper文件如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">"testMap"</span> resultType=<span class="string">"map"</span>&gt;</span><br><span class="line"> select    id,name from coach </span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<p>CoachDao接口定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Map&lt;Object, Object&gt; testMap();</span><br></pre></td></tr></table></figure>
<p>测试方法如下：特意没有引入Spring，只有Mybatis方便DebugMybatis源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testMap() &#123;</span><br><span class="line">	SqlSession session = null;</span><br><span class="line">	System.out.println(&quot;Dd&quot;);</span><br><span class="line">	try &#123;</span><br><span class="line"></span><br><span class="line">		session = MybatisUtil.getCurrentSession();</span><br><span class="line">		CoachDao mapper = session.getMapper(CoachDao.class);</span><br><span class="line">		Map&lt;Object, Object&gt; map = mapper.testMap();</span><br><span class="line">		System.out.println(JSON.toJSONString(map));</span><br><span class="line"></span><br><span class="line">	&#125; catch (Exception e) &#123;</span><br><span class="line">		// TODO: handle exception</span><br><span class="line">		logger.error(&quot;testMap Error:&#123;&#125;&quot;, e);</span><br><span class="line">	&#125; finally &#123;</span><br><span class="line">		session.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们debug观察下这次sql的执行过程。</p>
<p>我们从debug到MapperMethod这个类开始看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public Object execute(SqlSession sqlSession, Object[] args) &#123;</span><br><span class="line">   Object result;</span><br><span class="line">   if (SqlCommandType.INSERT == command.getType()) &#123;</span><br><span class="line">     Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">     result = rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">   &#125; else if (SqlCommandType.UPDATE == command.getType()) &#123;</span><br><span class="line">     Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">     result = rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">   &#125; else if (SqlCommandType.DELETE == command.getType()) &#123;</span><br><span class="line">     Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">     result = rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">   &#125; else if (SqlCommandType.SELECT == command.getType()) &#123;</span><br><span class="line">     if (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">       executeWithResultHandler(sqlSession, args);</span><br><span class="line">       result = null;</span><br><span class="line">     &#125; else if (method.returnsMany()) &#123;</span><br><span class="line">       result = executeForMany(sqlSession, args);</span><br><span class="line">     &#125; else if (method.returnsMap()) &#123;</span><br><span class="line">       result = executeForMap(sqlSession, args);</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">       result = sqlSession.selectOne(command.getName(), param);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     throw new BindingException(&quot;Unknown execution method for: &quot; + command.getName());</span><br><span class="line">   &#125;</span><br><span class="line">   if (result == null &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</span><br><span class="line">     throw new BindingException(&quot;Mapper method &apos;&quot; + command.getName() </span><br><span class="line">         + &quot; attempted to return null from a method with a primitive return type (&quot; + method.getReturnType() + &quot;).&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   return result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>显然我们这里执行的是SqlCommandType.SELECT == command.getType()这一个分支的。</p>
<p>我们看看这个分支的流程，首先要判断是否参数中包含ResultHandler类型的参数，</p>
<p>然后判断是否是返回Collection容器类型或者数组类型，</p>
<p>接着判断是否Method方法参数中带有@MapKey注解且返回类型为Map,看到这里我们会想到这个是否能够实现我们想要的功能呢，这个我们接下来会测试。</p>
<p>然后终于到达我们我们要走的分支</p>
<p>执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = sqlSession.selectOne(command.getName(), param);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">selectOne</span><span class="params">(String statement, Object parameter)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Popular vote was to return null on 0 results and throw exception on too many.</span></span><br><span class="line">  List&lt;T&gt; list = <span class="keyword">this</span>.&lt;T&gt;selectList(statement, parameter);</span><br><span class="line">  <span class="keyword">if</span> (list.size() == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> TooManyResultsException(<span class="string">"Expected one result (or null) to be returned by selectOne(), but found: "</span> + list.size());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现实际上Mybatis给我们返回的是一个List，只不过当执行selectOne时，需要sql执行后返回的List集合中只有一个元素。而在这里我们知道上面的sql返回的是多行结果集，而多行结果集在没有经过插件处理的时候显然返回的List中有多个结果，这个时候就会报错。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.ibatis.exceptions.TooManyResultsException: <span class="function">Expected one <span class="title">result</span> <span class="params">(or <span class="keyword">null</span>)</span> to be returned by <span class="title">selectOne</span><span class="params">()</span>, but found: 13</span></span><br></pre></td></tr></table></figure>
<p>所以第一种方案不行。</p>
<p>那我们把方法的返回类型改一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Map&lt;Object, Object&gt;&gt; testMap();</span><br></pre></td></tr></table></figure>
<p>可以保证程序正确运行，但是是List类型返回值而且其中的每一个Map是由两个元素构成的，分别以ID和NAME为键，即（”id”:123）、(“name”:”Jack”)的形式保存在Map中的。与我们想要的Map结构也不相同，虽然可以转化为我们想要的Map，但是这种转化不是很优雅，我们得找到一个更优雅更通用的方法。</p>
<ul>
<li><p>MapKey注解</p>
<p>​    那我们接着来试试之前用到的MapKey注解看能不能达到我想要的效果呢，查阅相关资料，我们开始尝试。</p>
<p>我们更改方法,将方法带上注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MapKey</span>(<span class="string">"ID"</span>)</span><br><span class="line"><span class="keyword">public</span> Map&lt;Integer, Map&lt;String, Object&gt;&gt; testMapKey();</span><br></pre></td></tr></table></figure>
<p>@MapKey(“ID”)这个注解表示最外层Map的key为查询结果中字段名为“id”的值。</p>
<p>那此刻只要Mybatis有把Value设为查询结果中的name字段的值不就好了吗。</p>
<p>但是很遗憾的是，Mybatis并没有直接实现这个功能。</p>
<p>我们看selectMap源码，当我们在没有对查询结果使用插件的时候，我们存进Map的Value只能是我们查询结果集的指定返回类型。而我们这里resultType=“map”，也就是说返回的类型就是Map。那你说我们把resultType=“string”就可以了把，很显然，这里存在问题，因为我们的结果包含两列，不可能做到resulType=“string” 。所以使用MapKey注解也是无法达到我们想要的效果的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public &lt;K, V&gt; Map&lt;K, V&gt; selectMap(String statement, Object parameter, String mapKey, RowBounds rowBounds) &#123;</span><br><span class="line">  final List&lt;?&gt; list = selectList(statement, parameter, rowBounds);</span><br><span class="line">  final DefaultMapResultHandler&lt;K, V&gt; mapResultHandler = new DefaultMapResultHandler&lt;K, V&gt;(mapKey,</span><br><span class="line">      configuration.getObjectFactory(), configuration.getObjectWrapperFactory());</span><br><span class="line">  final DefaultResultContext context = new DefaultResultContext();</span><br><span class="line">  for (Object o : list) &#123;</span><br><span class="line">    context.nextResultObject(o);</span><br><span class="line">    mapResultHandler.handleResult(context);</span><br><span class="line">  &#125;</span><br><span class="line">  Map&lt;K, V&gt; selectedMap = mapResultHandler.getMappedResults();</span><br><span class="line">  return selectedMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看看使用MapKey注解的返回情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">==&gt;  Preparing: select id,name from coach </span><br><span class="line">==&gt; Parameters: </span><br><span class="line">&lt;==    Columns: ID, NAME</span><br><span class="line">&lt;==        Row: <span class="number">12</span>, phil jackson</span><br><span class="line">&lt;==        Row: <span class="number">17</span>, phil jackson</span><br><span class="line">&lt;==        Row: <span class="number">1</span>, jackson</span><br><span class="line">&lt;==        Row: <span class="number">14</span>, phil jackson</span><br><span class="line">&lt;==        Row: <span class="number">18</span>, phil jackson</span><br><span class="line">&lt;==        Row: <span class="number">2</span>, jackson</span><br><span class="line">&lt;==        Row: <span class="number">10</span>, jackson</span><br><span class="line">&lt;==        Row: <span class="number">13</span>, phil jackson</span><br><span class="line">&lt;==        Row: <span class="number">15</span>, phil jackson</span><br><span class="line">&lt;==        Row: <span class="number">16</span>, phil jackson1</span><br><span class="line">&lt;==        Row: <span class="number">5</span>, jackson</span><br><span class="line">&lt;==        Row: <span class="number">3</span>, jackson</span><br><span class="line">&lt;==        Row: <span class="number">11</span>, jackson</span><br><span class="line">&lt;==      Total: <span class="number">13</span></span><br><span class="line">&#123;<span class="number">1</span>:&#123;<span class="string">"ID"</span>:<span class="number">1</span>,<span class="string">"NAME"</span>:<span class="string">"jackson"</span>&#125;,<span class="number">2</span>:&#123;<span class="string">"ID"</span>:<span class="number">2</span>,<span class="string">"NAME"</span>:<span class="string">"jackson"</span>&#125;,<span class="number">3</span>:&#123;<span class="string">"ID"</span>:<span class="number">3</span>,<span class="string">"NAME"</span>:<span class="string">"jackson"</span>&#125;,<span class="number">5</span>:&#123;<span class="string">"ID"</span>:<span class="number">5</span>,<span class="string">"NAME"</span>:<span class="string">"jackson"</span>&#125;,<span class="number">10</span>:&#123;<span class="string">"ID"</span>:<span class="number">10</span>,<span class="string">"NAME"</span>:<span class="string">"jackson"</span>&#125;,<span class="number">11</span>:&#123;<span class="string">"ID"</span>:<span class="number">11</span>,<span class="string">"NAME"</span>:<span class="string">"jackson"</span>&#125;,<span class="number">12</span>:&#123;<span class="string">"ID"</span>:<span class="number">12</span>,<span class="string">"NAME"</span>:<span class="string">"phil jackson"</span>&#125;,<span class="number">13</span>:&#123;<span class="string">"ID"</span>:<span class="number">13</span>,<span class="string">"NAME"</span>:<span class="string">"phil jackson"</span>&#125;,<span class="number">14</span>:&#123;<span class="string">"ID"</span>:<span class="number">14</span>,<span class="string">"NAME"</span>:<span class="string">"phil jackson"</span>&#125;,<span class="number">15</span>:&#123;<span class="string">"ID"</span>:<span class="number">15</span>,<span class="string">"NAME"</span>:<span class="string">"phil jackson"</span>&#125;,<span class="number">16</span>:&#123;<span class="string">"ID"</span>:<span class="number">16</span>,<span class="string">"NAME"</span>:<span class="string">"phil jackson1"</span>&#125;,<span class="number">17</span>:&#123;<span class="string">"ID"</span>:<span class="number">17</span>,<span class="string">"NAME"</span>:<span class="string">"phil jackson"</span>&#125;,<span class="number">18</span>:&#123;<span class="string">"ID"</span>:<span class="number">18</span>,<span class="string">"NAME"</span>:<span class="string">"phil jackson"</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>从结果集我们可以看出，以ID作为Key，但是Value是上面一种情况的Map集合，结构仍然为（（”id”:123）、(“name”:”Jack”)）显然是不符合要求的。</p>
</li>
</ul>
<p>也就是说，很遗憾，我们的这种需求Mybatis并没有直接的支持，那我们该怎么办呢，这时候就需要用到Mybatis留给我们的重要接口Mybatis中的拦截器，通过使用提供给用户可以自定义实现特殊功能，其功能特别强大。我们可以在Mybatis最重要的四大组件中使用拦截器（通过动态代理和反射注解等技术实现,这三个技术就是框架的核心，其定义就不多说了），让我们能够自定义的对四大组件的功能进行丰富和更改等。</p>
<p>在说拦截器之前，我们需要说一下四大组件</p>
<p>这部分后续补充</p>
<h3 id="二-Mybatis中的拦截器"><a href="#二-Mybatis中的拦截器" class="headerlink" title="二.Mybatis中的拦截器"></a>二.Mybatis中的拦截器</h3><p>现在我们来看Mybatis中的拦截器，Mybatis很贴心的为我们提供了Interceptor接口，作为一个优秀的开源框架，Mybatis和Spring一样都很好的遵守了开闭原则。基本都是面向接口的编程，特别是Spring，你会发现是Spring中大量的运用了模板方法模式来设计。在Mybatis中，我们要自定义我们的拦截器只需要实现这个接口。那我们首先就来瞅瞅这个接口都定义了哪些方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Object <span class="title">plugin</span><span class="params">(Object target)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>plugin方法是拦截器用于封装目标对象的，通过该方法我们可以返回目标对象本身，也可以返回一个它的代理。当返回的是代理的时候我们可以对其中的方法进行拦截来调用intercept方法(因为intercept方法的参数Invocation封装了原对象的相关信息)，当然也可以调用其他方法。setProperties方法是用于在Mybatis配置文件中指定一些属性的。       定义自己的Interceptor最重要的是要实现plugin方法和intercept方法，在plugin方法中我们可以决定是否要进行拦截进而决定要返回一个什么样的目标对象。而intercept方法就是要进行拦截的时候要执行的方法。而对于plugin方法而言，其实Mybatis已经为我们提供了一个实现。Mybatis中有一个叫做Plugin的类，里面有一个静态方法wrap(Object target,Interceptor interceptor)，通过该方法可以决定要返回的对象是目标对象还是对应的代理。Mybatis已经尽可能的帮我们做的更多了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">public class Plugin implements InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">  private Object target;</span><br><span class="line">  private Interceptor interceptor;</span><br><span class="line">  private Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap;</span><br><span class="line"></span><br><span class="line">  private Plugin(Object target, Interceptor interceptor, Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap) &#123;</span><br><span class="line">    this.target = target;</span><br><span class="line">    this.interceptor = interceptor;</span><br><span class="line">    this.signatureMap = signatureMap;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static Object wrap(Object target, Interceptor interceptor) &#123;</span><br><span class="line">    Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor);</span><br><span class="line">    Class&lt;?&gt; type = target.getClass();</span><br><span class="line">    Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);</span><br><span class="line">    if (interfaces.length &gt; 0) &#123;</span><br><span class="line">      return Proxy.newProxyInstance(</span><br><span class="line">          type.getClassLoader(),</span><br><span class="line">          interfaces,</span><br><span class="line">          new Plugin(target, interceptor, signatureMap));</span><br><span class="line">    &#125;</span><br><span class="line">    return target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass());</span><br><span class="line">      if (methods != null &amp;&amp; methods.contains(method)) &#123;</span><br><span class="line">        return interceptor.intercept(new Invocation(target, method, args));</span><br><span class="line">      &#125;</span><br><span class="line">      return method.invoke(target, args);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      throw ExceptionUtil.unwrapThrowable(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private static Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; getSignatureMap(Interceptor interceptor) &#123;</span><br><span class="line">    Intercepts interceptsAnnotation = interceptor.getClass().getAnnotation(Intercepts.class);</span><br><span class="line">    if (interceptsAnnotation == null) &#123; // issue #251</span><br><span class="line">      throw new PluginException(&quot;No @Intercepts annotation was found in interceptor &quot; + interceptor.getClass().getName());      </span><br><span class="line">    &#125;</span><br><span class="line">    Signature[] sigs = interceptsAnnotation.value();</span><br><span class="line">    Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = new HashMap&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt;();</span><br><span class="line">    for (Signature sig : sigs) &#123;</span><br><span class="line">      Set&lt;Method&gt; methods = signatureMap.get(sig.type());</span><br><span class="line">      if (methods == null) &#123;</span><br><span class="line">        methods = new HashSet&lt;Method&gt;();</span><br><span class="line">        signatureMap.put(sig.type(), methods);</span><br><span class="line">      &#125;</span><br><span class="line">      try &#123;</span><br><span class="line">        Method method = sig.type().getMethod(sig.method(), sig.args());</span><br><span class="line">        methods.add(method);</span><br><span class="line">      &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">        throw new PluginException(&quot;Could not find method on &quot; + sig.type() + &quot; named &quot; + sig.method() + &quot;. Cause: &quot; + e, e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return signatureMap;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private static Class&lt;?&gt;[] getAllInterfaces(Class&lt;?&gt; type, Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap) &#123;</span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; interfaces = new HashSet&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">    while (type != null) &#123;</span><br><span class="line">      for (Class&lt;?&gt; c : type.getInterfaces()) &#123;</span><br><span class="line">        if (signatureMap.containsKey(c)) &#123;</span><br><span class="line">          interfaces.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      type = type.getSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">    return interfaces.toArray(new Class&lt;?&gt;[interfaces.size()]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先看一下Plugin的wrap方法，它根据当前的Interceptor上面的注解定义哪些接口需要拦截，然后判断当前目标对象是否有实现对应需要拦截的接口，如果没有则返回目标对象本身，如果有则返回一个代理对象。而这个代理对象的InvocationHandler正是一个Plugin。所以当目标对象在执行接口方法时，如果是通过代理对象执行的，则会调用对应InvocationHandler的invoke方法，也就是Plugin的invoke方法。(至于到底为什么会调用这个方法，我相信其实有不少人都不是真的明白，这个我在之前的博客中有说过，因为在调用代理对象的方法的时候实际上调用的就是InvocationHandler的invoke方法，InvocationHandler对象作为代理对象的构造器参数注入，要彻底明白</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">         type.getClassLoader(),</span><br><span class="line">         interfaces,</span><br><span class="line">         <span class="keyword">new</span> Plugin(target, interceptor, signatureMap));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这句话到底做了什么才能彻底理解JDK动态代理</p>
<p>)所以接着我们来看一下该invoke方法的内容。这里invoke方法的逻辑是：如果当前执行的方法是定义好的需要拦截的方法，则把目标对象、要执行的方法以及方法参数封装成一个Invocation对象，再把封装好的Invocation作为参数传递给当前拦截器的intercept方法。如果不需要拦截，则直接调用当前的方法。Invocation中定义了定义了一个proceed方法，其逻辑就是调用当前方法，所以如果在intercept中需要继续调用当前方法的话可以调用invocation的procced方法。</p>
<p>​       这就是Mybatis中实现Interceptor拦截的一个思想，如果用户觉得这个思想有问题或者不能完全满足你的要求的话可以通过实现自己的Plugin来决定什么时候需要代理什么时候需要拦截。以下讲解的内容都是基于Mybatis的默认实现即通过Plugin来管理Interceptor来讲解的。</p>
<p>​       对于实现自己的Interceptor而言有两个很重要的注解，一个是@Intercepts，其值是一个@Signature数组。@Intercepts用于表明当前的对象是一个Interceptor，而@Signature则表明要拦截的接口、方法以及对应的参数类型。</p>
<p>那在真正的去写自己的拦截器之前，我们必须得要知道Mybatis拦截器应该作用在什么地方。</p>
<p>而他又是怎么起作用的。之前我们说过Mybatis拦截器主要是作用在四大组件上的,那么是怎么起作用的呢。</p>
<p>我们还是看源码。</p>
<p>我们在执行一次SQL过程中进行debug，当debug到SimpleExecutor执行器时，执行了doQuery方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException &#123;</span><br><span class="line">  Statement stmt = null;</span><br><span class="line">  try &#123;</span><br><span class="line">    Configuration configuration = ms.getConfiguration();</span><br><span class="line">    StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">    return handler.&lt;E&gt;query(stmt, resultHandler);</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    closeStatement(stmt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们主要看这行代码：</p>
<p>这行代码实际上生生成了除了执行器的其他三大组件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public StatementHandler newStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) &#123;</span><br><span class="line">  StatementHandler statementHandler = new RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">  statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br><span class="line">  return statementHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先new RoutingStatementHandler();看这个类的源码，发现实际上生成了delegate属性的StatementHandler对象,而且实际上的StatementHandler这个组件的方法执行就是执行delegate的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public RoutingStatementHandler(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) &#123;</span><br><span class="line"></span><br><span class="line">   switch (ms.getStatementType()) &#123;</span><br><span class="line">     case STATEMENT:</span><br><span class="line">       delegate = new SimpleStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">       break;</span><br><span class="line">     case PREPARED:</span><br><span class="line">       delegate = new PreparedStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">       break;</span><br><span class="line">     case CALLABLE:</span><br><span class="line">       delegate = new CallableStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">       break;</span><br><span class="line">     default:</span><br><span class="line">       throw new ExecutorException(&quot;Unknown statement type: &quot; + ms.getStatementType());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>我们看构造方法总共有三个可选的StatementHandler。</p>
<p>我们发现这三个StatementHandler都继承了BaseStatementHandler,我们知道在创建一个子类实例对象是一定会先执行父类的构造方法，那我们来看看BaseStatementHandler的构造方法都做了什么工作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">protected BaseStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) &#123;</span><br><span class="line">  this.configuration = mappedStatement.getConfiguration();</span><br><span class="line">  this.executor = executor;</span><br><span class="line">  this.mappedStatement = mappedStatement;</span><br><span class="line">  this.rowBounds = rowBounds;</span><br><span class="line"></span><br><span class="line">  this.typeHandlerRegistry = configuration.getTypeHandlerRegistry();</span><br><span class="line">  this.objectFactory = configuration.getObjectFactory();</span><br><span class="line"></span><br><span class="line">  if (boundSql == null) &#123; // issue #435, get the key before calculating the statement</span><br><span class="line">    generateKeys(parameterObject);</span><br><span class="line">    boundSql = mappedStatement.getBoundSql(parameterObject);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.boundSql = boundSql;</span><br><span class="line"></span><br><span class="line">  this.parameterHandler = configuration.newParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">  this.resultSetHandler = configuration.newResultSetHandler(executor, mappedStatement, rowBounds, parameterHandler, resultHandler, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看这个类的源码，我们会发现，她包含了其他两个组件，并且在构造方法里创建了这两个组件实现类的对象。</p>
<p>我们查看具体创建组件对象的源码，我们都会调用 interceptorChain.pluginAll方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public ParameterHandler newParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql) &#123;</span><br><span class="line">    ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">    parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);</span><br><span class="line">    return parameterHandler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public ResultSetHandler newResultSetHandler(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler,</span><br><span class="line">      ResultHandler resultHandler, BoundSql boundSql) &#123;</span><br><span class="line">    ResultSetHandler resultSetHandler = new DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);</span><br><span class="line">    resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);</span><br><span class="line">    return resultSetHandler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public StatementHandler newStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) &#123;</span><br><span class="line">    StatementHandler statementHandler = new RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">    statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br><span class="line">    return statementHandler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Executor newExecutor(Transaction transaction) &#123;</span><br><span class="line">    return newExecutor(transaction, defaultExecutorType);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Executor newExecutor(Transaction transaction, ExecutorType executorType) &#123;</span><br><span class="line">    executorType = executorType == null ? defaultExecutorType : executorType;</span><br><span class="line">    executorType = executorType == null ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    if (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">      executor = new BatchExecutor(this, transaction);</span><br><span class="line">    &#125; else if (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">      executor = new ReuseExecutor(this, transaction);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      executor = new SimpleExecutor(this, transaction);</span><br><span class="line">    &#125;</span><br><span class="line">    if (cacheEnabled) &#123;</span><br><span class="line">      executor = new CachingExecutor(executor);</span><br><span class="line">    &#125;</span><br><span class="line">    executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    return executor;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>终于找到了使用拦截器的地方了。</p>
<p>我们看看InterceptorChain的源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorChain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;Interceptor&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">      target = interceptor.plugin(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptor</span><span class="params">(Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">    interceptors.add(interceptor);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Interceptor&gt; <span class="title">getInterceptors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableList(interceptors);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类是收集所有拦截器的类，那如何收集所有的拦截器呢，通过配置文件加载到Configuration对象中。</p>
<p>通过如下方式写入Mybatis配置文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">      &lt;plugins&gt;  </span><br><span class="line">        &lt;plugin interceptor=&quot;com.wangcc.ssm.mybatis.interceptor.PageInterceptor&quot;&gt;  </span><br><span class="line">           &lt;property name=&quot;databaseType&quot; value=&quot;Oracle&quot;/&gt;  </span><br><span class="line">       &lt;/plugin&gt;  </span><br><span class="line">   &lt;plugin interceptor=&quot;com.wangcc.ssm.mybatis.interceptor.ParamMapInterceptor&quot;/&gt;  </span><br><span class="line">&lt;/plugins&gt;</span><br></pre></td></tr></table></figure>
<h3 id="三-实现自己的Mybatis拦截器"><a href="#三-实现自己的Mybatis拦截器" class="headerlink" title="三.实现自己的Mybatis拦截器"></a>三.实现自己的Mybatis拦截器</h3><p>好了，回到我们要解决的需求，我们要通过Mybatis拦截器来解决问题了。</p>
<p>通过前面几种情况，我们知道了，Mybatis自带的返回类型处理不能满足我们这个需求的要求。所以我们理所当然的想到，我们使用拦截器的目标是ResultSetHandler。我们知道返回结果是由ResultSetHandler的handleResultSets方法对当前的Statement处理后的返回结果，所以我们如果要改变返回结果的话就需要使用Mybatis的拦截器对ResultSetHandler接口的handleResultSets方法进行拦截。</p>
<p>这个时候我们就确定了该拦截器的注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts</span>(<span class="meta">@Signature</span>(method = <span class="string">"handleResultSets"</span>, type = ResultSetHandler.class, args = &#123; Statement.class &#125;))</span><br></pre></td></tr></table></figure>
<p>在之前分析四大组件对象生成时，说过每一个对象都要调用interceptorChain.pluginAll方法，这里的注解中的type = ResultSetHandler.class会使该拦截器只作用在ResultSetHandler上，但是目前来会对每一个ResultSetHandler都会起作用，所以我们还得在这个拦截器中想办法再做一层过滤，对于不需要拦截的调用Invocation的proceed()方法，而需要拦截的则实现我们自己的逻辑，返回对应的结果。现在我们要想的是怎么做这一层过滤以及怎么实现改变返回结果的效果。</p>
<ul>
<li><p>首先，这个过滤该怎样来实现呢，一般来说，通过parameterObj来过滤， 通过ParameterHandler得到：parameterHandler.getParameterObject();（我们定义的Dao层方法的参数）</p>
<p>​    那这里我们需要给出一个怎样的参数呢：</p>
<p>​    首先他得满足这几个条件</p>
<ul>
<li>（1）    可以指定哪个字段为返回Map的Key；</li>
<li>（2）    可以指定哪个字段为返回Map的Value；</li>
<li>（3）    可以附带其他参数；</li>
</ul>
</li>
</ul>
<p>那我们这里就给出我定义的参数ComplexParamMap</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComplexParamMap</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ParamMap paramMap;</span><br><span class="line">	<span class="keyword">private</span> T obj;<span class="comment">// 使用实体类的属性作为查询参数</span></span><br><span class="line">	<span class="keyword">private</span> Map&lt;String, Object&gt; params = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();<span class="comment">// 其他的参数我们把它分装成一个Map对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParamMap</span> <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 作为Key的字段对应MapParam的Key</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_FIELD = <span class="string">"mapKeyField"</span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 作为Value的字段对应MapParam的Key</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String VALUE_FIELD = <span class="string">"mapValueField"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ParamMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 指定keyField和valueField</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> keyField</span></span><br><span class="line"><span class="comment">	 *            Map中key对应的字段</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> valueField</span></span><br><span class="line"><span class="comment">	 *            Map中value对应的字段</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ParamMap</span><span class="params">(String keyField, String valueField)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.put(KEY_FIELD, keyField);</span><br><span class="line">		<span class="keyword">this</span>.put(VALUE_FIELD, valueField);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用泛型，方便 使用实体类的属性作为查询参数。</p>
<p>定义一个HashMap params 方便我们加入一些独立参数来作为查询参数。</p>
<p>ParamMap paramMap; 指定对应字段为返回Map的Key和Value；</p>
<ul>
<li><p>确定了过滤条件之后,我们就可以开始处理我们的逻辑了。</p>
<p>​    </p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts</span>(<span class="meta">@Signature</span>(method = <span class="string">"handleResultSets"</span>, type = ResultSetHandler.class, args = &#123; Statement.class &#125;))</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParamMapInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(ParamMapInterceptor.class);</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		Object target = invocation.getTarget();</span><br><span class="line">			<span class="comment">//目前Mybatis只有DefaultResultSetHandler这一种ResultSetHandler实现类</span></span><br><span class="line">      <span class="keyword">if</span> (target <span class="keyword">instanceof</span> DefaultResultSetHandler) &#123;</span><br><span class="line">          </span><br><span class="line">			DefaultResultSetHandler resultSetHandler = (DefaultResultSetHandler) target;</span><br><span class="line"></span><br><span class="line">			ParameterHandler parameterHandler = ReflectUtil.getFieldValue(resultSetHandler, <span class="string">"parameterHandler"</span>);</span><br><span class="line">			Object parameterObj = parameterHandler.getParameterObject();</span><br><span class="line">			<span class="keyword">if</span> (parameterObj <span class="keyword">instanceof</span> ComplexParamMap) &#123;</span><br><span class="line">				ComplexParamMap paramMap = (ComplexParamMap) parameterObj;</span><br><span class="line">				Statement stmt = (Statement) invocation.getArgs()[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">				<span class="keyword">return</span> handleResultSet(stmt.getResultSet(), paramMap);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> invocation.proceed();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> Object <span class="title">handleResultSet</span><span class="params">(ResultSet resultSet, ComplexParamMap cmap)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (resultSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">			ParamMap paramMap = cmap.getParamMap();</span><br><span class="line">			String keyField = paramMap.get(ParamMap.KEY_FIELD);</span><br><span class="line">			String valueField = paramMap.get(ParamMap.VALUE_FIELD);</span><br><span class="line">			Map&lt;Object, Object&gt; map = <span class="keyword">new</span> HashMap&lt;Object, Object&gt;();</span><br><span class="line">			<span class="comment">// 因为原方法返回的是List&lt;Object&gt;类型，所以</span></span><br><span class="line">			List&lt;Object&gt; resultList = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">					Object key = resultSet.getObject(keyField);</span><br><span class="line">					Object value = resultSet.getObject(valueField);</span><br><span class="line">					map.put(key, value);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				logger.error(<span class="string">"ParamMapInterceptor 的Method handleResultSet 使用ResultSet时出错"</span>);</span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				closeResultSet(resultSet);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			resultList.add(map);</span><br><span class="line">			<span class="keyword">return</span> resultList;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">closeResultSet</span><span class="params">(ResultSet resultSet)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (resultSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">				resultSet.close();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			logger.error(<span class="string">"关闭ResultSet资源时出错"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到现在我们就算完成了我们的第一个Mybatis拦截器了。</p>
<p>我们将这个拦截器注册到我们的Mybatis配置文件，注意在配置文件中的顺序位置。</p>
<p>然后开始测试，看是否能达到我们的要求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">	public void test() &#123;</span><br><span class="line">		SqlSession session = null;</span><br><span class="line">		System.out.println(&quot;Dd&quot;);</span><br><span class="line">		try &#123;</span><br><span class="line"></span><br><span class="line">			session = MybatisUtil.getCurrentSession();</span><br><span class="line">			CoachDao mapper = session.getMapper(CoachDao.class);</span><br><span class="line">			// Coach coach = mapper.getCoachById(1);</span><br><span class="line">			// System.out.println(coach);</span><br><span class="line">			ComplexParamMap&lt;Coach&gt; cmap = new ComplexParamMap&lt;Coach&gt;();</span><br><span class="line">			Coach coach = new Coach();</span><br><span class="line">			coach.setName(&quot;jackson&quot;);</span><br><span class="line">			ParamMap paramMap = new ParamMap(&quot;name&quot;, &quot;age&quot;);</span><br><span class="line">			cmap.setParamMap(paramMap);</span><br><span class="line">			Map&lt;String, Object&gt; params = new HashMap&lt;String, Object&gt;();</span><br><span class="line">			params.put(&quot;name&quot;, &quot;jackson&quot;);</span><br><span class="line">			cmap.setParams(params);</span><br><span class="line">			cmap.setObj(coach);</span><br><span class="line">			Map&lt;Object, Object&gt; map = mapper.queryMap(cmap);</span><br><span class="line">			System.out.println(JSON.toJSONString(map));</span><br><span class="line">			Page&lt;Coach, ?&gt; page = new Page&lt;&gt;();</span><br><span class="line">			page.setSelf(coach);</span><br><span class="line">			page.setPageSize(4);</span><br><span class="line">			page.setPageNo(2);</span><br><span class="line">			List&lt;Coach&gt; list = mapper.querybyPage(page);</span><br><span class="line">			System.out.println(JSON.toJSONString(list));</span><br><span class="line"></span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			// TODO: handle exception</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; finally &#123;</span><br><span class="line">			session.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>Mapper配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;queryMap&quot; resultType=&quot;map&quot; parameterType=&quot;ComplexParamMap&quot;&gt;</span><br><span class="line">select id,name from coach where name=#&#123;obj.name&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<p>查看输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">==&gt; Parameters: jackson(String)</span><br><span class="line">&lt;==    Columns: ID, NAME</span><br><span class="line">&lt;==        Row: 1, jackson</span><br><span class="line">&lt;==        Row: 2, jackson</span><br><span class="line">&lt;==        Row: 10, jackson</span><br><span class="line">&lt;==        Row: 5, jackson</span><br><span class="line">&lt;==        Row: 3, jackson</span><br><span class="line">&lt;==        Row: 11, jackson</span><br><span class="line">&lt;==      Total: 6</span><br><span class="line">&#123;1:&quot;jackson&quot;,2:&quot;jackson&quot;,3:&quot;jackson&quot;,5:&quot;jackson&quot;,10:&quot;jackson&quot;,11:&quot;jackson&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>完美的结果。</p>
<p>接下来我们再看下在Mybatis中使用广泛的分页插件拦截器。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2017/11/22/Mybatis插件/" data-id="cjab89sco0000ykbziqpn803x" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-HashMap" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/19/HashMap/" class="article-date">
  <time datetime="2017-11-19T10:15:42.019Z" itemprop="datePublished">2017-11-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java基础/">Java基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/19/HashMap/">HashMap</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="JDK7"><a href="#JDK7" class="headerlink" title="JDK7"></a>JDK7</h3><p>之前用JDK7的源码分析过一次HashMap,但是分析的并不完善，只分析了put方法和get方法，有一个很重要的方法 resize()方法并没有分析。</p>
<p>扩容方法resize()方法是一个很重要的方法，当我们调用put方法的时候，如果Hash数组的实际大小已经大于加载因子*容量的时候，我们就需要进行扩容操作，防止Hash冲突堆积太多，影响效率。 </p>
<p>jdk version:jdk1.7.0.0_76</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">           inflateTable(threshold);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">       <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">       <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">       <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">           Object k;</span><br><span class="line">           <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">               V oldValue = e.value;</span><br><span class="line">               e.value = value;</span><br><span class="line">               e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       modCount++;</span><br><span class="line">       addEntry(hash, key, value, i);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">    <span class="comment">//为什么不要移位操作&lt;&lt;</span></span><br><span class="line">    resize(<span class="number">2</span> * table.length);</span><br><span class="line">           hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">           bucketIndex = indexFor(hash, table.length);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       createEntry(hash, key, value, bucketIndex);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>我们看下这个方法的具体实现，然后看看在JDK8中是如何进行改进的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">       Entry[] oldTable = table;</span><br><span class="line">       <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="comment">//如果原来的容量已经是最大容量了,就只能任由他进行HASH碰撞</span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">           threshold = Integer.MAX_VALUE;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">       transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">       table = newTable;</span><br><span class="line">       threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line"><span class="comment">//对Hash数组进行遍历，所有元素遍历</span></span><br><span class="line">     <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">       <span class="comment">//对Hash数组每个元素后面带着的链表进行遍历，采用头插法将元素插入到新的Hash表中。    </span></span><br><span class="line">       <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">         <span class="comment">//先将e的下一个节点保存起来</span></span><br><span class="line">               Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">               <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                   e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">               &#125;</span><br><span class="line">         <span class="comment">//得到节点对应的hash数组的位置</span></span><br><span class="line">               <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">               <span class="comment">//开始头插</span></span><br><span class="line">         <span class="comment">//当前节点的next节点指向原头节点</span></span><br><span class="line">         </span><br><span class="line">         		e.next = newTable[i];</span><br><span class="line">         <span class="comment">//将当前节点置为头结点      </span></span><br><span class="line">         newTable[i] = e;</span><br><span class="line">         	<span class="comment">//将之前保存起来的next节点赋给e，开始下一个重复步骤进行头插</span></span><br><span class="line">               e = next;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>我们看到在JDK7中使用的resize()方法是对一个每个元素都进行重新找到在新的Hash数组的位置，采用的是头插法，也就是说将所有的元素都倒置了。</p>
<h3 id="JDK8"><a href="#JDK8" class="headerlink" title="JDK8"></a>JDK8</h3><p>HashMap和ConcurrentHashMap在JDK8中都进行了巨大的改变。</p>
<p>在HashMap中，为了增加插入删除等操作的效率，我们的HashMap在JDK8中的底层数据结构中增加了红黑树数据结构，当Hash数组的某个元素的链表长度大于8且数组大小大于。。。时，链表会变成红黑树，当链表长度大于8但长度没有超过。。。时会先执行扩容操作，而当扩容的时候，如果发现某个红黑树结构的元素个数小于6时，红黑树又会变成链表，这个具体实现，我们后面再说。</p>
<p>那么为什么我们要选用红黑树这种比较复杂的数据结构呢？</p>
<p>至于树形数据结构对于数组或者链表的优点，我们可以很简单的得出。</p>
<p>但是为什么是选择了红黑树而不是AVL（二叉平衡树）呢。这个就需要我们好好想想了。</p>
<p>红黑树的查询性能略逊色于AVL树，因为他比AVL树会稍微不平衡，也就是说红黑树的查询性能只比相同内容的avl树最多多一次比较，但是，红黑树在插入和删除上完爆avl树，avl树每次插入删除会进行大量的</p>
<p>平衡度计算，而红黑树为了维持红黑性质所做的红黑变换和旋转的开销，相较于avl树为了维持平衡的开销要小得多。</p>
<p>当然，红黑树并不适应所有应用树的领域。如果数据基本上是静态的，那么让他们待在他们能够插入，并且不影响平衡的地方会具有更好的性能。如果数据完全是静态的，例如，做一个哈希表，性能可能会更好一些。</p>
<p>在实际的系统中，例如，需要使用动态规则的防火墙系统，使用红黑树而不是散列表被实践证明具有更好的伸缩性。</p>
<p>简单说，如果你的应用中，搜索的次数远远大于插入和删除，那么选择AVL，如果搜索，插入删除次数几乎差不多，应该选择RB。</p>
<p><strong>红黑树是牺牲了严格的高度平衡的优越条件</strong>为 代价红黑树能够以O(log2 n)的时间复杂度进行搜索、插入、删除操作。此外，由于它的设计，任何不平衡都会在三次旋转之内解决。当然，还有一些更好的，但实现起来更复杂的数据结构 能够做到一步旋转之内达到平衡，但红黑树能够给我们一个比较“便宜”的解决方案。红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更高. </p>
<ul>
<li><p>Node内部类</p>
<p>我们先来看看HashMap的Hash数组的元素的数据结构是怎样的，在JDK7以及以前的版本中，都是使用的Entry作为元素，但是在JDK8中是使用Node,当然他肯定还是得实现Map.Entry\<k,v>这个接口</k,v></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h3><p>我们先关注put方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line">       <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">         <span class="comment">//先看table有没有初始化，没有的话初始化一个Hash数组</span></span><br><span class="line">       <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">           n = (tab = resize()).length;</span><br><span class="line">         <span class="comment">//如果数组元素没有被占用，则该节点赋给该数组元素，即为该数组元素后面的链表的头结点</span></span><br><span class="line">       <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">           tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           Node&lt;K,V&gt; e; K k;</span><br><span class="line">         <span class="comment">//如果链表头结点（Hash数组元素）的key与我们要插入的key相同，可以直接替换value</span></span><br><span class="line">           <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">               ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">               e = p;</span><br><span class="line">         <span class="comment">//如果不是头节点key相同，而且是红黑树类型节点,调用红黑树类型的插入方式</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">               e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">//如果不是直接替换头结点，那么开始进行咔咔的遍历</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                 <span class="comment">//当遍历完了之后还是没找着</span></span><br><span class="line">                   <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="comment">//新建一个node节点指向原最后一个节点的next节点</span></span><br><span class="line">                       p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                     <span class="comment">//如果遍历玩还没找到而且元素大于7了，厉害了，开始变身TreeNode，变成红黑树结构</span></span><br><span class="line">                       <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                           treeifyBin(tab, hash);</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                 <span class="comment">//如果遍历的过程中找到了key相同的，跳出循环</span></span><br><span class="line">                   <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                       ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   p = e;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">         <span class="comment">//然后在这里进行替换原值的操作</span></span><br><span class="line">           <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">               V oldValue = e.value;</span><br><span class="line">               <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                   e.value = value;</span><br><span class="line">               afterNodeAccess(e);</span><br><span class="line">      	<span class="comment">//当e!=null的时候直接返回了，之前我再这里纠结了一下为什么没有++modCount呀</span></span><br><span class="line">             <span class="comment">//fail-fast机制不要遵循了吗</span></span><br><span class="line">             <span class="comment">//仔细一看，扑街，只有当是替换Value的时候，而没有新增的Node节点的时候才会直接返回</span></span><br><span class="line">             <span class="comment">//当是处理TreeNode红黑树节点的时候，方法返回的是null，也就是e==null</span></span><br><span class="line">             <span class="comment">//当需要从链表转化为红黑树的时候，也是新增节点，e指向null的时候才执行。</span></span><br><span class="line">             <span class="comment">//也就是这个方法中所有返回e==null的分支对应的都是新增节点，会在下面的代码中执行++modCount;</span></span><br><span class="line">             <span class="comment">//所有不返回null的分支都对应着修改Value值。</span></span><br><span class="line">             <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        </span><br><span class="line">       ++modCount;</span><br><span class="line">       <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">           resize();</span><br><span class="line">       afterNodeInsertion(evict);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>具体代码就不再次分析了。</p>
<p>put方法的流程：</p>
<p>先确定Key位于哪个Hash桶，如果对应Hash数组中没有元素，直接将这个Node赋给Hash数组中该元素（table[i]=node）,如果找到了对应的Hash桶，如果对应的还是之前的链表结构，则遍历Node链表，如果发现Key已经存在，替换Value,返回，如果没找到，这个时候就需要新增节点了，直接用尾插法插到链表的尾部（这一点和JDK7以及之前插入方法不同，之前的插入方法是头插法）如果链表的长度已经不小于7了，链表的结构要变成红黑树的结构。如果这个hash桶的结构在插入新节点前已经变成了红黑树，则遍历TreeNode组成的红黑树结构，看是否Key已经存在，如果存在则替换，如果没有，则将新节点插入红黑树结构。这个流程我们能够狠轻松的整理出来，但是，如何用代码实现，如何用最少的代码实现，却并没有那么简单。如何用最少的代码，也就是如何找到规律，万物皆有形可测，编写程序就是要找到一些事情的规律，化繁为简。</p>
<ul>
<li>将链表结构改为红黑树结构</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">  <span class="comment">//如果还没有初始化表或者表的长度小于64，那么不急着将链表结构改为红黑树结构，先进行扩容操作。</span></span><br><span class="line">      <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">          resize();</span><br><span class="line">  <span class="comment">//开始转化，转化之前确认这个链表是有元素的</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">          TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//将Node节点转化为TreeNode节点</span></span><br><span class="line">              TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">              <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                  hd = p;</span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//prev是TreeNode的属性</span></span><br><span class="line">                  p.prev = tl;</span><br><span class="line">                <span class="comment">//注意next还是Node的属性</span></span><br><span class="line">                  tl.next = p;</span><br><span class="line">              &#125;</span><br><span class="line">              tl = p;</span><br><span class="line">          &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line"> <span class="comment">//让桶的第一个元素指向新建的红黑树头结点，以后这个桶里的元素就是红黑树而不是链表了</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">              hd.treeify(tab);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">          TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">              next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">              x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">              <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  x.parent = <span class="keyword">null</span>;</span><br><span class="line">                  x.red = <span class="keyword">false</span>;</span><br><span class="line">                  root = x;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                  K k = x.key;</span><br><span class="line">                  <span class="keyword">int</span> h = x.hash;</span><br><span class="line">                  Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">                  <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                      <span class="keyword">int</span> dir, ph;</span><br><span class="line">                      K pk = p.key;</span><br><span class="line">                      <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                          dir = -<span class="number">1</span>;</span><br><span class="line">                      <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                          dir = <span class="number">1</span>;</span><br><span class="line">                      <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                               (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                          dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">                      TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                      <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                          x.parent = xp;</span><br><span class="line">                          <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                              xp.left = x;</span><br><span class="line">                          <span class="keyword">else</span></span><br><span class="line">                              xp.right = x;</span><br><span class="line">                          root = balanceInsertion(root, x);</span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">  <span class="comment">//确保你返回的是root节点</span></span><br><span class="line">          moveRootToFront(tab, root);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>插入红黑树节点</p>
<p>putTreeVal是TreeNode的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">           Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">           TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">           <span class="comment">//这是一个无限循环，我们得看看他的退出条件</span></span><br><span class="line">           <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">             <span class="comment">//dir应该是左子树或右子树的一个判断</span></span><br><span class="line">               <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">             <span class="comment">//如果Node的hash值小于当前节点的值</span></span><br><span class="line">               <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                 <span class="comment">//右子树</span></span><br><span class="line">                   dir = -<span class="number">1</span>;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                 <span class="comment">//左子树</span></span><br><span class="line">                   dir = <span class="number">1</span>;</span><br><span class="line">             <span class="comment">//如果key相等hash值相等，即我们找到了这个节点返回</span></span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                   <span class="keyword">return</span> p;</span><br><span class="line">             <span class="comment">//</span></span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                         <span class="comment">// /**</span></span><br><span class="line">    * Returns x<span class="string">'s Class if it is of the form "class C implements</span></span><br><span class="line"><span class="string">    * Comparable&lt;C&gt;", else null.</span></span><br><span class="line"><span class="string">    */</span></span><br><span class="line"><span class="string">                         (kc = comparableClassFor(k)) == null) ||</span></span><br><span class="line"><span class="string">                        //</span></span><br><span class="line"><span class="string">   /**</span></span><br><span class="line"><span class="string">    * Returns k.compareTo(x) if x matches kc (k'</span>s screened comparable</span><br><span class="line">    * <span class="class"><span class="keyword">class</span>), <span class="title">else</span> 0.</span></span><br><span class="line"><span class="class">    */</span></span><br><span class="line"><span class="class">                        (<span class="title">dir</span> </span>= compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">                                 <span class="comment">//如果当前节点和要添加的节点哈希值相等，但是两个节点的键不是一个类，只好去挨个对比左右孩子 </span></span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                       TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                       searched = <span class="keyword">true</span>;</span><br><span class="line">                       <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                            (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                           ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                            (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                           <span class="keyword">return</span> q;</span><br><span class="line">                   &#125;</span><br><span class="line">                 <span class="comment">//                //哈希值相等，但键无法比较，只好通过特殊的方法给个结果</span></span><br><span class="line"><span class="comment">//这个方法用于 a 和 b 哈希值相同但是无法比较时，直接根据两个引用的地址进行比较</span></span><br><span class="line">   <span class="comment">//这里源码注释也说了，这个树里不要求完全有序，只要插入时使用相同的规则保持平衡即可</span></span><br><span class="line">                   dir = tieBreakOrder(k, pk);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">               <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">                   TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">                   <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                       xp.left = x;</span><br><span class="line">                   <span class="keyword">else</span></span><br><span class="line">                       xp.right = x;</span><br><span class="line">                   xp.next = x;</span><br><span class="line">                   x.parent = x.prev = xp;</span><br><span class="line">                   <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">                       ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">                   moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>红黑树的插入</p>
<p>首先，我们知道，当插入节点的父节点的是黑色时，不用执行任何操作。</p>
<p>所以，要调整的是当插入节点的父节点是红色时，而插入的节点是红色的时候，是不会改变 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点这一条的，主要要注意的就是红色节点的子节点一定是黑节点这一条。</p>
<p>关于它的特性，需要注意的是：</p>
<p>分析之前，我们要牢记一点，插入之前这棵树是从局部到整体都符合红黑树的定义的。</p>
<p>而且我们调整的思路，永远都是先让底层局部符合定义，再逐级往上调整。</p>
<p>再强调一次，下列穷举的情况都是建立在这棵树符合红黑树的定义的情况下。</p>
<ul>
<li><p>当父节点和叔叔节点都是红色</p>
<p>这个时候我们插入一个红色节点，很显然违反了红色节点的子节点是黑色节点这个规定。</p>
<p>这个我们就像某些时刻处理异常一样，先给他把问题抛给上层。将叔叔节点和父节点都变成黑色，祖父节点变成红色。这样做至少保证了从祖父节点开始是局部符合红黑树的定义的（除了根节点是黑色节点不能确定以外），刚开始，我以为这种情况就大功告成了，后来才发现要考虑一种情况，那就是我们能确定这种情况下祖父节点是黑色，那么这种情况下祖父的父节点是红色还是黑色，我们是无法知道的，倘若是红色，那么当祖父变成红色后，就违反了原则了。所以我们要将祖父节点看成是新的当前节点，继续进行调整（因为已经保证祖父节点以下的都满足了）</p>
</li>
<li><p>当父节点是红色 叔叔节点是黑色且插入节点是父节点的左节点</p>
<p>首先，我们说过插入一个新节点的操作是不会影响 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点这一条的，因为默认插入的是红色，但是会影响红色的子节点必须是黑色这一条。</p>
<p>在这种情况下，祖父是黑色，叔叔是黑色，父节点是红色，我们还是秉守我们的一大原则，把问题尽可能往上层抛，我们从祖父节点开始看，设从祖父节点到左边（父节点）某一个叶子节点的路径包含的黑节点为n（父节点以下的黑节点）+1（祖父节点本身），到右边（叔叔节点）某一个叶子节点的路径包含的黑色节点为n-1(叔叔节点以下的黑节点)+1（叔叔节点）+1（祖父节点本身），都为n+1个黑节点。我们将父节点设为黑色，祖父节点设为红色，就解决了红色的子节点是黑色这一条不遵守的问题，但是这样做会带来新的问题， 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点这一条不符合了。相当于祖父节点到父节点这一分支（n+1）多了一个黑节点而到叔叔那一分支(n 少了原祖父节点这一黑节点)少了一个黑节点，这显然违反了我们的原则，那怎么样去调整呢，这个时候我们以父节点为中心开始右旋。使父节点变成祖父节点，那么现在从祖父节点到左边（原父节点）这一分支还是n+1,右边，由于新的祖父节点是祖父节点是黑色节点，所以黑节点+1为n+1,所以从祖父节点开始，都符合红黑树，此时，祖父节点又成为了黑节点，无需再进行改动。</p>
</li>
<li><p>当父节点是红色 叔叔节点是黑色且插入节点是父节点的右节点</p>
<p>很明显当情况为第二种情况的时候，已经调整好了，所以我们只需要将这种情况调整为第二种情况即可。如何做到第二种情况，以父节点为中心，进行左旋操作即可。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//先将插入的节点设为红色，为什么设为红色，设为红色不会违背，每个节点都其子孙节点的路径经过的黑色节点都一样多这条原则，我们调整红黑树的原则是让他尽可能的少违背红黑树的五大原则，然后就是尽可能的先做到局部符合原则。但是设为红色可能会违反红色节点的子节点一定是黑色这条原则，那么我们就来穷举下违背原则时可能出现的所有情况，有时候你别看着穷举好像很笨的样子，但是有时候大道至简才是真理，最直观的去分析可能会更快的得出结论。</span></span><br><span class="line"> 暴力穷举 </span><br><span class="line"> <span class="number">1</span>.父节点是红色节点，叔叔节点是红色节点</span><br><span class="line">   将父节点和叔叔节点都涂黑，将祖父节点涂红，此时，从祖父节点开始局部符合原则，然后把问题往上抛，将祖父节点设为当前节点。</span><br><span class="line"> <span class="number">2</span>.父节点是红色节点，叔叔节点是黑色节点</span><br><span class="line">    I.父节点是红色节点，叔叔节点是黑色节点，且当前节点是父节点的左子节点</span><br><span class="line">   	很显然，违反的是红色节点的子节点是黑色节点这一条，那么我们就把父节点涂黑，祖父节点（黑色）涂红，然后以祖父节点右旋一波，perfect，强行稳住了。符合原则。</span><br><span class="line">    II.父节点是红色节点，叔叔节点是黑色节点，且当前节点是父节点的右子节点</span><br><span class="line">    x.red = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">      <span class="comment">//如果是根节点，不多逼逼，直接将其涂黑，搞定</span></span><br><span class="line">        <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//如果父节点不是红色或者祖父节点是空的，即父节点是根节点，这里根节点必须是黑节点呀，为什么还要加一个祖父节点为空的判断呀</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">      <span class="comment">//如果父节点是祖父节点的左节点</span></span><br><span class="line">        <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">          <span class="comment">//如果叔叔节点是红色</span></span><br><span class="line">            <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123;</span><br><span class="line">              <span class="comment">//      将父节点和叔叔节点都涂黑，将祖父节点涂红，此时，从祖父节点开始局部符合原则，然后把问题往上抛，将祖父节点设为当前节点。</span></span><br><span class="line">              xppr.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//叔叔节点是黑色</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//如果当前节点是父节店的右子节点，情况2的I</span></span><br><span class="line">                <span class="keyword">if</span> (x == xp.right) &#123;</span><br><span class="line">                  <span class="comment">//以父节点为中心强行来一波左旋操作，使得父节点变为当前节点的左子节点，然后将父节点置为当前节点</span></span><br><span class="line">                  <span class="comment">//也就是变为当前节点是父节点左子节点的情况</span></span><br><span class="line">                    root = rotateLeft(root, x = xp);</span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">//现在就是到了情况2的II了</span></span><br><span class="line">              <span class="comment">//如果父节点不为空</span></span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="comment">//父节点置为黑色</span></span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                      <span class="comment">//祖父节点置为红色</span></span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                      <span class="comment">//右旋</span></span><br><span class="line">                        root = rotateRight(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (xppl != <span class="keyword">null</span> &amp;&amp; xppl.red) &#123;</span><br><span class="line">                xppl.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == xp.left) &#123;</span><br><span class="line">                    root = rotateRight(root, x = xp);</span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateLeft(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个左旋的代码，看着其实很烦呀，虽然一眼看过去很简洁，但是太多骚操作了，在之前代码简洁之道的学习中，我们多次强调过千万不要在平时编程中写只有自己看的懂代码，千万不要喜欢用三元表达式，最好做到一句话只做一件事，写代码，让机器看得懂是最简单的事，如何让人看懂才是问题的关键所在。当然编写JDK源码的人都是大神，追求简单高效无可厚非，我们这些平凡人还是不要秀骚操作比较好。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateLeft</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class="line">	<span class="comment">//左旋操作，实际就是更改下节点的互相指向</span></span><br><span class="line">	<span class="comment">//左旋操作前提，首先右子节点要存在     当前节点指p.right</span></span><br><span class="line"><span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (r = p.right) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//这句代码其实做了两件事（具体的分还不止）,首先进行链式赋值，然后判断值是否为null</span></span><br><span class="line">  <span class="comment">//如果当前节点有左孩子的话，将当前节点的左节点赋给父节点的右孩子</span></span><br><span class="line">                <span class="keyword">if</span> ((rl = p.right = r.left) != <span class="keyword">null</span>)</span><br><span class="line">                  <span class="comment">//然后让当前节点的左节点的父节点设为父节点</span></span><br><span class="line">                    rl.parent = p;</span><br><span class="line">  <span class="comment">//赋值操作：得到祖父节点，并将祖父节点置为当前节点的父节点</span></span><br><span class="line">  <span class="comment">//判断操作，判断父节点是不是根节点，如果是根节点，那么当前节点就会被置为根节点，根节点默认为black</span></span><br><span class="line">                <span class="keyword">if</span> ((pp = r.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">                    (root = r).red = <span class="keyword">false</span>;</span><br><span class="line">  <span class="comment">//新的关系连接起来，很好看懂</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p)</span><br><span class="line">                    pp.left = r;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pp.right = r;</span><br><span class="line">                r.left = p;</span><br><span class="line">                p.parent = r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="REMOVE"><a href="#REMOVE" class="headerlink" title="REMOVE"></a>REMOVE</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public V remove(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    return (e = removeNode(hash(key), key, null, false, true)) == null ?</span><br><span class="line">        null : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">          (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">          Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">  	<span class="comment">//如果是头结点（）</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">              ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">              node = p;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                  node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="keyword">do</span> &#123;</span><br><span class="line">                      <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                          ((k = e.key) == key ||</span><br><span class="line">                           (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                          node = e;</span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">                      p = e;</span><br><span class="line">                  &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                               (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">              <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                  ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                  tab[index] = node.next;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                  p.next = node.next;</span><br><span class="line">              ++modCount;</span><br><span class="line">              --size;</span><br><span class="line">              afterNodeRemoval(node);</span><br><span class="line">              <span class="keyword">return</span> node;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>红黑树的删除</p>
<p> 删除操作应该是红黑树中最难的操作了，说实话，我看了四五遍了，都不是很明白。</p>
<p>首先删除节点就分三种情况，</p>
<ul>
<li><p>无子节点，最简单，直接删除，不多逼逼</p>
<p>如果删除的节点是红色的节点，不用处理，如果是黑色节点就需要调整红黑树的结构。</p>
</li>
<li><p>一个子节点，不多逼逼，直接替代删除节点</p>
<p>如果删除的节点是红色的节点，依旧是不需要处理，但是如果删除的是黑色节点，需要调整红黑树的结构</p>
</li>
<li><p>两个子节点，瞬间爆炸，愣是好几次都没搞透彻。在学习二叉树的删除的时候，对这种情况已经说过了，要灵活思考，找到删除节点的后续节点，然后将后续节点替代删除节点，然后来删除后续节点。</p>
<p>中序后续节点是二叉树中Key大于删除节点的最小值，也就是删除节点的右子树的左子树中最左边的节点。该节点不可能存在左节点，只可能有右节点。后继节点只可能有右节点或者没有子节点，也就对应着前面说的头两种情况了，只不过当前节点从要删除的节点变成了后继节点。</p>
<p>​         当后继节点含有右节点时，</p>
<p>​    删除后续节点，将后续节点的右节点称为后续节点的父节点的左节点。</p>
<p>​    我们就来通过后继节点的子节点和父节点来分析，称后继节点的子节点为当前节点。</p>
<ul>
<li><p>如果当前节点是红色的，说明刚刚移走的后继节点是黑色的，那么不管后继节点的父节点是啥颜色，我们只要将当前节点涂黑就可以了，红-黑树的平衡性就可以恢复。</p>
</li>
<li><p>所以注意分析的情况就是当前节点是黑色的情况</p>
<ul>
<li><p>这种情况是可以直接解决红黑树调整的情况。在这种情况下，我们把兄弟节点的颜色和父节点颜色调换一下（这样一来就给当前节点那一分支添加了一个黑色节点，然后兄弟节点这一分支也并没有少黑色节点，但是还有可能出现的情况需要再考虑：原来的父节点是红色节点，那么就会造成现在的兄弟节点和兄弟节点的右节点都是红色节点，就很尴尬，会造成红色节点的子节点还是红节点的情况，那么这时我们就需要做出改变了</p>
<p>），所以我们还需要将现在的兄弟节点的右节点变为黑色，但是这样又使得兄弟节点这一分支的黑色节点多了一个，这个时候咋办呢，围绕当前的父节点来一波左旋操作，便解决了多一个黑节点的问题，同时最重要的是兄弟节点（颜色是原来的父节点的颜色，这很重要）成为了父节点，目前，父节点及其以下分支已经完成了红黑树调整，又有新的父节点的颜色和原有的父节点相同，这就是说已经完成了所有的调整操作了。</p>
<p>​</p>
</li>
<li><p>当前节点是黑色的，且兄弟节点是黑色的，且兄弟节点的两个子节点均为黑色的；</p>
<p>把兄弟节点涂成红色，这样在父节点及以下分支实现了符合红黑树，但是整体来说就使得父节点之一分支相对于其他分支少了个黑色节点，也就是说，我们这样左就把调整红黑树的任务推给了上一层节点，把问题不停的往上抛，直到根节点，也就自然的解决了问题，把问题逐层往上抛在插入的时候已经强调过实用性和重要性了，然后我们就可以把父节点设为当前节点继续调整了。</p>
</li>
<li><p>当前节点是黑色的，且兄弟节点是黑色的，且兄弟节点的左子节点是红色，右子节点时黑色的；</p>
<p>这个你做一个旋转操作，自然就变成了第一种情况啦，将兄弟节点的左子节点变为黑色，兄弟节点变为红色，以兄弟节点为中心，来一波右旋操作，就成了第一种情况啦。</p>
</li>
<li><p>当前节点是黑色的，且兄弟节点是红色的（那么父节点和兄弟节点的子节点肯定是黑色的）；</p>
<p>很显然，这种情况只要先把他转化为当前节点和兄弟节点都是黑色的情况就好啦。</p>
<p>怎么做呢，这里相关的节点都是能确定颜色的，要完成这个操作还是比较简单的。</p>
<p>先将兄弟节点和父节点的颜色调换，然后以父节点为中心左旋即可。</p>
</li>
</ul>
</li>
</ul>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>我们注意到我们分析两个子节点时，当后续节点有子节点时，我们给出了具体调整红黑树的方案</p>
<p>那我们有没有办法在其他情况下也用到这种解决方案呢，如果能用到那我们就解决了红黑树删除节点的问题了。</p>
<p>那我们再回头来分析下我们在后续节点有子节点是怎么解决的。</p>
<p>我们是将右子节点补上后继的位置，我们称这个右子节点为替代节点replacement节点，成为后继节点父节点的子节点，然后用replacement和其父节点和其兄弟节点的各种情况来分析得到解决方案。</p>
<p>那么对于其他情况下，我们能不能尝试得到replacement来构造这种解决方案呢。</p>
<p>1、我们来看之前说的当前节点只有一个子节点的情况，我们说过这种情况是将子节点代替删除节点，当删除节点为黑色节点的时候是需要看是否需要调整红黑树的。那么这种情况我们可以很容易的得到这里可以将子节点设为replacement</p>
<p>2、删除节点没有子节点</p>
<p>这种情况下当删除节点是黑色的时候是一定会出现违反红黑树定义的情况的，但是这个时候没有子节点呀，咋办呀，上哪找replacement呀，这个时候我们就把当前要删除的节点当做是replacement，就当此时这个分支当前是少一个黑节点的（为什么呢，因为这个replacement节点终于要删除的），然后使用replacement调整红黑树、</p>
<p>3.后继节点是没有子节点的</p>
<p>那这种情况那和2一样，也是抓当前要删除的节点当做replacement的，最后把这个给删了。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeTreeNode</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        <span class="comment">//为什么JDK源码要整这么多骚操作呀，这个局部变量的命名我真的了</span></span><br><span class="line">            TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl;</span><br><span class="line">            TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev;</span><br><span class="line">        <span class="comment">//去掉要删除的节点</span></span><br><span class="line">            <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">                tab[index] = first = succ;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pred.next = succ;</span><br><span class="line">            <span class="keyword">if</span> (succ != <span class="keyword">null</span>)</span><br><span class="line">                succ.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (root.parent != <span class="keyword">null</span>)</span><br><span class="line">                root = root.root();</span><br><span class="line">            <span class="keyword">if</span> (root == <span class="keyword">null</span> || root.right == <span class="keyword">null</span> ||</span><br><span class="line">                (rl = root.left) == <span class="keyword">null</span> || rl.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                tab[index] = first.untreeify(map);  <span class="comment">// too small</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>, pl = left, pr = right, replacement;</span><br><span class="line">            <span class="keyword">if</span> (pl != <span class="keyword">null</span> &amp;&amp; pr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; s = pr, sl;</span><br><span class="line">              <span class="comment">//找到后继节点</span></span><br><span class="line">                <span class="keyword">while</span> ((sl = s.left) != <span class="keyword">null</span>) <span class="comment">// find successor</span></span><br><span class="line">                    s = sl;</span><br><span class="line">              <span class="comment">//交换颜色</span></span><br><span class="line">                <span class="keyword">boolean</span> c = s.red; s.red = p.red; p.red = c; <span class="comment">// swap colors</span></span><br><span class="line">                TreeNode&lt;K,V&gt; sr = s.right;</span><br><span class="line">                TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">              <span class="comment">//如果后继节点就是当前节点的右子节点，即右子节点没有左子树</span></span><br><span class="line">                <span class="keyword">if</span> (s == pr) &#123; <span class="comment">// p was s's direct parent</span></span><br><span class="line">                  <span class="comment">//两个交换一下</span></span><br><span class="line">                    p.parent = s;</span><br><span class="line">                    s.right = p;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">//后继节点的父节点</span></span><br><span class="line">                    TreeNode&lt;K,V&gt; sp = s.parent;</span><br><span class="line">                  <span class="comment">//后继节点的父节点成为当前接的父节点</span></span><br><span class="line">                  <span class="comment">//用当前节点代替后继节点</span></span><br><span class="line">                    <span class="keyword">if</span> ((p.parent = sp) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                      <span class="comment">//如果后继节点是其父节点的左节点，则当前节点设为其父节点的左节点</span></span><br><span class="line">                        <span class="keyword">if</span> (s == sp.left)</span><br><span class="line">                            sp.left = p;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            sp.right = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="comment">//将后继节点代替当前节点的位置</span></span><br><span class="line">                    <span class="keyword">if</span> ((s.right = pr) != <span class="keyword">null</span>)</span><br><span class="line">                        pr.parent = s;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">//相当于将当前节点和后继节点互相换位置，包括颜色</span></span><br><span class="line">             <span class="comment">//因为当前节点要代替当前节点，当然p.left==null；</span></span><br><span class="line">                p.left = <span class="keyword">null</span>;</span><br><span class="line">              <span class="comment">//继续完成当前节点代替后继节点的操作</span></span><br><span class="line">                <span class="keyword">if</span> ((p.right = sr) != <span class="keyword">null</span>)</span><br><span class="line">                    sr.parent = p;</span><br><span class="line">              <span class="comment">//将后继节点代替当前节点的位置</span></span><br><span class="line">                <span class="keyword">if</span> ((s.left = pl) != <span class="keyword">null</span>)</span><br><span class="line">                    pl.parent = s;</span><br><span class="line">              <span class="comment">//如果当前节点是根节点，直接替代根节点</span></span><br><span class="line">                <span class="keyword">if</span> ((s.parent = pp) == <span class="keyword">null</span>)</span><br><span class="line">                    root = s;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                    pp.left = s;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pp.right = s;</span><br><span class="line">              <span class="comment">//前面就是完成后继节点和当前节点位置互换的操作。不难理解，但是目前没理解的是，为什么要用当前节点来替代后继节点的位置，这个位置不是要删除掉的吗</span></span><br><span class="line">              <span class="comment">//接下来的操作就需要思考了</span></span><br><span class="line">              <span class="comment">//如果后继节点的右子树存在</span></span><br><span class="line">                <span class="keyword">if</span> (sr != <span class="keyword">null</span>)</span><br><span class="line">                    replacement = sr;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    replacement = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pl != <span class="keyword">null</span>)</span><br><span class="line">                replacement = pl;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pr != <span class="keyword">null</span>)</span><br><span class="line">                replacement = pr;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                replacement = p;</span><br><span class="line">        <span class="comment">//当前节点有两个孩子</span></span><br><span class="line">        <span class="comment">//如果后继节点没有孩子节点，则replacement=p;</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">//如果有右孩子节点repalcement都不会为当前节点p而是后继节点的右孩子</span></span><br><span class="line">               <span class="comment">//如果当前节点没有孩子节点，repalcement=p;</span></span><br><span class="line">        <span class="comment">//如果有一个节点的情况 replacement=相应的孩子节点</span></span><br><span class="line">            <span class="keyword">if</span> (replacement != p) &#123;</span><br><span class="line">              <span class="comment">//虽然到这里我终于看懂了，但是为什么我觉得这个操作非常非常的多余呀</span></span><br><span class="line">                TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;</span><br><span class="line">                <span class="keyword">if</span> (pp == <span class="keyword">null</span>)</span><br><span class="line">                    root = replacement;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                    pp.left = replacement;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pp.right = replacement;</span><br><span class="line">                p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">	<span class="comment">//因为后继节点和当前节点的颜色互换了。p.red就代表后继节点的颜色，很明显，当要真正删除的后继节点是红色的时候，不会对红黑树有任何影响，不需要做任何改动，而当后继节点的颜色是黑色时，就有可能影响节点到子孙的路径中黑色节点的个数相同这一条，就需要调整红黑树</span></span><br><span class="line">        </span><br><span class="line">            TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);</span><br><span class="line"><span class="comment">//如果后继节点没有子节点或者删除节点本身就没有子节点，我们只能拿要删除的节点先去顶上，然后执行完</span></span><br><span class="line">       <span class="comment">// balanceDeletion操作之后再去删除</span></span><br><span class="line">            <span class="keyword">if</span> (replacement == p) &#123;  <span class="comment">// detach</span></span><br><span class="line">                TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">                p.parent = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (pp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                        pp.left = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.right)</span><br><span class="line">                        pp.right = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (movable)</span><br><span class="line">                moveRootToFront(tab, r);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceDeletion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpl, xpr;;)  &#123;</span><br><span class="line">            <span class="comment">//如果当前节点就是root节点，直接返回</span></span><br><span class="line">              <span class="keyword">if</span> (x == <span class="keyword">null</span> || x == root)</span><br><span class="line">                  <span class="keyword">return</span> root;</span><br><span class="line">            <span class="comment">//如果删除的就是root节点，当前节点就顶上去成为root节点，这个时候要记得颜色要置为black</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//置为  </span></span><br><span class="line">                x.red = <span class="keyword">false</span>;</span><br><span class="line">                  <span class="keyword">return</span> x;</span><br><span class="line">              &#125;</span><br><span class="line">   	<span class="comment">//如果当前节点是红色，将当前节点改为黑色就行了，因为如果当前节点是红色，我们只要把节点改为黑色既可以弥补去掉后继节点所失去的一个黑色节点。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (x.red) &#123;</span><br><span class="line">			                </span><br><span class="line">                  x.red = <span class="keyword">false</span>;</span><br><span class="line">                  <span class="keyword">return</span> root;</span><br><span class="line">              &#125;</span><br><span class="line">            <span class="comment">//两种情况，当前节点是左孩子，或当前节点是右孩子，我们只需对其中一种情况分析即可，因为这两种情况是对称的。</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> ((xpl = xp.left) == x) &#123;</span><br><span class="line">                <span class="comment">//当前节点是黑色的，，则他的兄弟节点要么是黑色要么是红色</span></span><br><span class="line">                <span class="comment">//如果是红色，那兄弟节点的孩子节点是黑色，父节点肯定是黑色。</span></span><br><span class="line">                <span class="comment">//也就是说，红色节点这种情况是唯一确定的，而兄弟节点是黑色的情况会有好几种情况</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                所以，我们就先将</span></span><br><span class="line"><span class="comment">                1.兄弟节点是红色，这种情况转化为当前节点和兄弟节点都是黑色的情况。</span></span><br><span class="line"><span class="comment">                </span></span><br><span class="line"><span class="comment">                </span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                  <span class="keyword">if</span> ((xpr = xp.right) != <span class="keyword">null</span> &amp;&amp; xpr.red) &#123;</span><br><span class="line">                      xpr.red = <span class="keyword">false</span>;</span><br><span class="line">                      xp.red = <span class="keyword">true</span>;</span><br><span class="line">                      root = rotateLeft(root, xp);</span><br><span class="line">                      xpr = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.right;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span> (xpr == <span class="keyword">null</span>)</span><br><span class="line">                      x = xp;</span><br><span class="line">                  <span class="keyword">else</span> &#123;</span><br><span class="line">                      TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right;</span><br><span class="line">                      <span class="keyword">if</span> ((sr == <span class="keyword">null</span> || !sr.red) &amp;&amp;</span><br><span class="line">                          (sl == <span class="keyword">null</span> || !sl.red)) &#123;</span><br><span class="line">                          xpr.red = <span class="keyword">true</span>;</span><br><span class="line">                          x = xp;</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="keyword">else</span> &#123;</span><br><span class="line">                          <span class="keyword">if</span> (sr == <span class="keyword">null</span> || !sr.red) &#123;</span><br><span class="line">                              <span class="keyword">if</span> (sl != <span class="keyword">null</span>)</span><br><span class="line">                                  sl.red = <span class="keyword">false</span>;</span><br><span class="line">                              xpr.red = <span class="keyword">true</span>;</span><br><span class="line">                              root = rotateRight(root, xpr);</span><br><span class="line">                              xpr = (xp = x.parent) == <span class="keyword">null</span> ?</span><br><span class="line">                                  <span class="keyword">null</span> : xp.right;</span><br><span class="line">                          &#125;</span><br><span class="line">                          <span class="keyword">if</span> (xpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                              xpr.red = (xp == <span class="keyword">null</span>) ? <span class="keyword">false</span> : xp.red;</span><br><span class="line">                              <span class="keyword">if</span> ((sr = xpr.right) != <span class="keyword">null</span>)</span><br><span class="line">                                  sr.red = <span class="keyword">false</span>;</span><br><span class="line">                          &#125;</span><br><span class="line">                          <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                              xp.red = <span class="keyword">false</span>;</span><br><span class="line">                              root = rotateLeft(root, xp);</span><br><span class="line">                          &#125;</span><br><span class="line">                          x = root;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span> &#123; <span class="comment">// symmetric</span></span><br><span class="line">                  <span class="keyword">if</span> (xpl != <span class="keyword">null</span> &amp;&amp; xpl.red) &#123;</span><br><span class="line">                      xpl.red = <span class="keyword">false</span>;</span><br><span class="line">                      xp.red = <span class="keyword">true</span>;</span><br><span class="line">                      root = rotateRight(root, xp);</span><br><span class="line">                      xpl = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.left;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span> (xpl == <span class="keyword">null</span>)</span><br><span class="line">                      x = xp;</span><br><span class="line">                  <span class="keyword">else</span> &#123;</span><br><span class="line">                      TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right;</span><br><span class="line">                      <span class="keyword">if</span> ((sl == <span class="keyword">null</span> || !sl.red) &amp;&amp;</span><br><span class="line">                          (sr == <span class="keyword">null</span> || !sr.red)) &#123;</span><br><span class="line">                          xpl.red = <span class="keyword">true</span>;</span><br><span class="line">                          x = xp;</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="keyword">else</span> &#123;</span><br><span class="line">                          <span class="keyword">if</span> (sl == <span class="keyword">null</span> || !sl.red) &#123;</span><br><span class="line">                              <span class="keyword">if</span> (sr != <span class="keyword">null</span>)</span><br><span class="line">                                  sr.red = <span class="keyword">false</span>;</span><br><span class="line">                              xpl.red = <span class="keyword">true</span>;</span><br><span class="line">                              root = rotateLeft(root, xpl);</span><br><span class="line">                              xpl = (xp = x.parent) == <span class="keyword">null</span> ?</span><br><span class="line">                                  <span class="keyword">null</span> : xp.left;</span><br><span class="line">                          &#125;</span><br><span class="line">                          <span class="keyword">if</span> (xpl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                              xpl.red = (xp == <span class="keyword">null</span>) ? <span class="keyword">false</span> : xp.red;</span><br><span class="line">                              <span class="keyword">if</span> ((sl = xpl.left) != <span class="keyword">null</span>)</span><br><span class="line">                                  sl.red = <span class="keyword">false</span>;</span><br><span class="line">                          &#125;</span><br><span class="line">                          <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                              xp.red = <span class="keyword">false</span>;</span><br><span class="line">                              root = rotateRight(root, xp);</span><br><span class="line">                          &#125;</span><br><span class="line">                          x = root;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h3 id="RESIZE"><a href="#RESIZE" class="headerlink" title="RESIZE()"></a>RESIZE()</h3><p>最后，我们再来看看resize()的改动</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">       <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">       <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">       <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">               threshold = Integer.MAX_VALUE;</span><br><span class="line">               <span class="keyword">return</span> oldTab;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">               newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">           newCap = oldThr;</span><br><span class="line">       <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">           newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">           newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">           newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">       &#125;</span><br><span class="line">       threshold = newThr;</span><br><span class="line">       <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">           Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">       table = newTab;</span><br><span class="line">       <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">               Node&lt;K,V&gt; e;</span><br><span class="line">               <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                   <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                       newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                       ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                   <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                       Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; next;</span><br><span class="line">                       <span class="keyword">do</span> &#123;</span><br><span class="line">                           next = e.next;</span><br><span class="line">                           <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                               <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                   loHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   loTail.next = e;</span><br><span class="line">                               loTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="keyword">else</span> &#123;</span><br><span class="line">                               <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                   hiHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   hiTail.next = e;</span><br><span class="line">                               hiTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                       <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                           newTab[j] = loHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                           newTab[j + oldCap] = hiHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> newTab;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>代码比较简单，就不细说了，很容易看懂，差别就在jdk7扩容的时候会让链表倒置，而jdk8不会倒置链表</p>
<p>。jdk8中用hash&amp;newcap-1的方法来确定元素位于的hash桶的位置，为0不用移位置，为1就在table[i+oldCap]上了。</p>
<p>当然resize()的时候会对TreeNode红黑树有一些改动，如果新的红黑树长度小于6，就要还原成链表。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2017/11/19/HashMap/" data-id="cjab84a9w0001pobzqqi9osnk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/19/hello-world/" class="article-date">
  <time datetime="2017-11-19T09:55:11.801Z" itemprop="datePublished">2017-11-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/19/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cong96.github.io/2017/11/19/hello-world/" data-id="cjab84aa00002pobzn8t1t57a" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java基础/">Java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mybatis/">Mybatis</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/11/29/Memory Leak/">Memory</a>
          </li>
        
          <li>
            <a href="/2017/11/26/ResultSetHandler/">ResultSetHandler</a>
          </li>
        
          <li>
            <a href="/2017/11/26/ParameterHandler/">ParameterHandler</a>
          </li>
        
          <li>
            <a href="/2017/11/26/StatementHandler/">StatementHandler</a>
          </li>
        
          <li>
            <a href="/2017/11/26/Executor/">Executor</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>